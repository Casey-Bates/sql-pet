[
["chapter-sql-joins-complex.html", "Chapter 13 SQL joins and complex queries 13.1 Database Privileges 13.2 Database constraints 13.3 Making up data for Join Examples 13.4 SQL Multi-Row Insert Data Syntax 13.5 SQL Multi-Row Insert Data Example 13.6 Messy Data 13.7 Joins 13.8 Natural Join Delayed Time Bomb 13.9 Join Templates 13.10 SQL anti join Costs 13.11 dplyr Anti joins 13.12 Exercises 13.13 Store analysis 13.14 Different strategies for interacting with the database", " Chapter 13 SQL joins and complex queries This chapter demonstrates how to: Use primary and foreign keys to retrieve specific rows of a table do different kinds of join queries Exercises Query the database to get basic information about each dvdrental story How to interact with the database using different strategies These packages are called in almost every chapter of the book: Verify Docker is up and running: sp_check_that_docker_is_up() ## [1] &quot;Docker is up, running these containers:&quot; ## [2] &quot;CONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES&quot; ## [3] &quot;4a810387a90c postgres-dvdrental \\&quot;docker-entrypoint.sâ\\200¦\\&quot; 5 weeks ago Up 4 hours 0.0.0.0:5432-&gt;5432/tcp sql-pet&quot; Verify pet DB is available, it may be stopped. r sp_show_all_docker_containers() ## CONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES ## 4a810387a90c postgres-dvdrental &quot;docker-entrypoint.sâ€¦&quot; 5 weeks ago Up 4 hours 0.0.0.0:5432-&gt;5432/tcp sql-pet Start up the docker-pet container. sp_docker_start(&quot;sql-pet&quot;) Now connect to the database with R. Need to wait for Docker &amp; PostgreSQL to come up before connecting. con &lt;- sp_get_postgres_connection( user = Sys.getenv(&quot;DEFAULT_POSTGRES_USER_NAME&quot;), password = Sys.getenv(&quot;DEFAULT_POSTGRES_PASSWORD&quot;), dbname = &quot;dvdrental&quot;, seconds_to_test = 30 ) 13.1 Database Privileges In the DVD rental database, you have all database privileges to perform any create, read, update or delete(CRUD) operation on any database object. As a data analyst, you typically only get select privilege which allows you to read only a subset of the tables in a database. Occasionally, a proof of concept project may have a sandbox spun up where users are granted additional priviledges. 13.2 Database constraints As a data analyst, you really do not need to worry about database constraints since you are primarily writing dplyr/SQL queries to pull data out of the database. Constraints can be enforced at multiple levels: column, table, multiple tables, or at the schema itself. The common database constraints are a column is NOT NULL, a column is UNIQUE, a column is a PRIMARY KEY, both NOT NULL and UNIQUE, or a column is a FOREIGN KEY relationship to the PRIMARY KEY on another table. Constraints restrict column values to a set of defined values and help enforce referential integrity between tables. 13.2.1 DVD Rental Primary Foreign Key Constraints For this tutorial, we are primarily concerned with primary and foreign key relationships between tables in order to correctly join the data between tables. If one looks at all the tables in the DVD Rental ERD the first column is the name of the table followed by “_id“. Entity Relationship diagram for the dvdrental database This is the primary key on the table. In some of the tables, there are other columns that begin with the name of a different table, the foreign table, and end in “_id“. These are foreign keys and the foreign key value is the primary key value on the foreign table. The DBA will index the primary and foreign key columns to speed up query performanace. In the table below, all the primary foreign key relationships are shown because the DVD rental system is small. Real world databases typically have hundreds or thousands of primary foreign key relationships. In the search box, enter ‘PRIMARY’ or ‘FOREIGN’ to see the table primary key or the table’s foreign key relationships. Searching for ‘FOREIGN’ in the table above, one sees that the column_name matches the ref_table_col. This is pretty typical, but not always the case. This can occur because of an inconsistent naming convention in the application design or a table contains multiple references to the same table foreign table and each reference indicates a different role. A non-DVD rental example of the latter is a patient transaction record that has a referring doctor and and performing doctor. The two columns will have different names, but may refer to the same or different doctors in the doctor table. In this case you may hear one say that the doctor table is performing two different roles. 13.3 Making up data for Join Examples Each chapter in the book stands on its own. If you have worked through the code blocks in this chapter in a previous session, you created some new customer records in order to work through material in the rest of the chapter. In the next couple of code blocks, we delete the new data and then recreate the data for the join examples in the next chapter. 13.3.1 SQL Delete Data Syntax DELETE FROM &lt;source&gt; WHERE &lt;where_clause&gt;; 13.3.2 Delete New Practice Customers from the Customer table. In the next code block we delete out the new customers that were added when the book was compliled or added working through the exercises. Out of the box, the DVD rental database’s highest customer_id = 599. dbExecute() always returns a scalar numeric that specifies the number of rows affected by the statement. dbExecute( con, &quot;delete from customer where customer_id &gt;= 600; &quot; ) ## [1] 7 The number above tells us how many rows were actually deleted from the customer table. 13.3.3 Delete New Practice Films from the Film table. In the next code block we delete out the new films that were added when the book was compliled or added working through the exercises. Out of the box, the DVD film database’s highest film_id = 1000. dbExecute( con, &quot;delete from film where film_id &gt; 1000; &quot; ) ## [1] 1 13.3.4 SQL Single Row Insert Data Syntax INSERT INTO &lt;target&gt; &lt;column_list&gt; VALUES &lt;values list&gt;; &lt;target&gt; : target table/view &lt;column list&gt; : csv list of columns &lt;values list&gt; : values assoicated with the column list. The column list is the list of column names on the table and the corresponding list of values have to have the correct data type. The following code block returns the CUSTOMER column names and data types. customer_cols &lt;- dbGetQuery( con, &quot;select table_name, column_name, ordinal_position, data_type from information_schema.columns where table_catalog = &#39;dvdrental&#39; and table_name = &#39;customer&#39; ;&quot; ) sp_print_df(customer_cols) In the next code block, we insert Sophie as a new customer into the customer table via a SQL insert statement. The columns list clause has three id columns, customer_id, store_id, and address_id. The customer_id is a primary key column and the other two ‘look like’ foreign key columns. For now, we are interested in getting some new customers into the customer table. We look at the relations between the customer table and the store and address tables later in this chapter. dbExecute( con, &quot;insert into customer (customer_id,store_id,first_name,last_name,email,address_id,activebool ,create_date,last_update,active) values(600,3,&#39;Sophie&#39;,&#39;Yang&#39;,&#39;sophie.yang@sakilacustomer.org&#39;,1,TRUE,now(),now()::date,1) &quot; ) ## [1] 1 new_customers &lt;- dbGetQuery(con, &quot;select * from customer where customer_id &gt;= 600;&quot;) sp_print_df(new_customers) 13.3.5 Primary and Foreign Key Constraint Error Messages For the new customers, we are concerned with not violating the PK and FK constraints. If the customer_id = 600 value is changed to 599, the database throws the following error message. Error in result_create(conn@ptr, statement) : Failed to fetch row: ERROR: duplicate key value violates unique constraint &quot;customer_pkey&quot; DETAIL: Key (customer_id)=(599) already exists. If the address_id value = 1 is changed to 611, the database throws the following error message: Error in result_create(conn@ptr, statement) : Failed to fetch row: ERROR: insert or update on table &quot;customer&quot; violates foreign key constraint &quot;customer_address_id_fkey&quot; DETAIL: Key (address_id)=(611) is not present in table &quot;address&quot;. 13.3.6 R Exercise: Inserting a Single Row via a Dataframe In the following code block replace Sophie Yang with your name where appropriate. Note: The last data frame parameter sets the stringsAsFactors is FALSE. Databases do not have a native FACTOR type. The dataframe column names must match the table column names. The dbWriteTable function needs append = true to actually insert the new row. The dbWriteTable function has an option ‘overwrite’. It is set to FALSE by default. If it is set to TRUE, the table is first truncated. No write occurs if both overwrite and append = FALSE. df &lt;- data.frame( customer_id = 601 , store_id = 2 , first_name = &quot;Sophie&quot; , last_name = &quot;Yang&quot; , email = &quot;sophie.yang@sakilacustomer.org&quot; , address_id = 1 , activebool = TRUE , create_date = Sys.Date() , last_update = Sys.time() , active = 1 , stringsAsFactors = FALSE ) dbWriteTable(con, &quot;customer&quot;, value = df, append = TRUE, row.names = FALSE) new_customers &lt;- dbGetQuery(con, &quot;select * from customer where customer_id &gt;= 600;&quot;) sp_print_df(new_customers) 13.4 SQL Multi-Row Insert Data Syntax INSERT INTO &lt;target&gt; &lt;column_list&gt; VALUES &lt;values list1&gt;, ... &lt;values listn&gt;; &lt;target&gt; : target table/view &lt;column list&gt; : csv list of columns &lt;values list&gt; : values assoicated with the column list. PostgreSQL and some other flavors of SQL allow multiple rows to be inserted at a time. The syntax is identical to the Single Row syntax, but includes multiple &lt;values list&gt; clauses separated by commas. The following code block illustrates the SQL multi-row insert. Note that the customer_id column takes on sequential values to satisfy the PK constraint. 13.5 SQL Multi-Row Insert Data Example # dbExecute( con, &quot;insert into customer (customer_id,store_id,first_name,last_name,email,address_id,activebool ,create_date,last_update,active) values(602,1,&#39;John&#39;,&#39;Smith&#39;,&#39;john.smith@sakilacustomer.org&#39;,2,TRUE ,now()::date,now()::date,1) ,(603,1,&#39;Ian&#39;,&#39;Frantz&#39;,&#39;ian.frantz@sakilacustomer.org&#39;,3,TRUE ,now()::date,now()::date,1) ,(604,1,&#39;Ed&#39;,&#39;Borasky&#39;,&#39;ed.borasky@sakilacustomer.org&#39;,4,TRUE ,now()::date,now()::date,1) ;&quot; ) ## [1] 3 The PostgreSQL R multi-row insert is similar to the single row insert. The single column values are converted to a vector of values. 13.5.1 R Exercise: Inserting Multiple Rows via a Dataframe Replace the two first_name, last_name, and email column values with your own made up values. customer_id &lt;- c(605, 606) store_id &lt;- c(3, 4) first_name &lt;- c(&quot;John&quot;, &quot;Ian&quot;) last_name &lt;- c(&quot;Smith&quot;, &quot;Frantz&quot;) email &lt;- c( &quot;john.smith@sakilacustomer.org&quot;, &quot;ian.frantz@sakilacustomer.org&quot; ) address_id &lt;- c(3, 4) activebool &lt;- c(TRUE, TRUE) create_date &lt;- c(Sys.Date(), Sys.Date()) last_update &lt;- c(Sys.time(), Sys.time()) active &lt;- c(1, 1) df2 &lt;- data.frame(customer_id, store_id, first_name, last_name, email, address_id, activebool, create_date, last_update, active, stringsAsFactors = FALSE ) dbWriteTable(con, &quot;customer&quot;, value = df2, append = TRUE, row.names = FALSE ) new_customers &lt;- dbGetQuery(con, &quot;select * from customer where customer_id &gt;= 600;&quot;) sp_print_df(new_customers) The film table has a primary key, film_id, and a foreign key column, language_id. In the next code bloock we see five sample rows from the film table. films &lt;- dbGetQuery( con, &quot;select film_id,title, language_id from film order by film_id limit 5 ;&quot; ) sp_print_df(films) The next code block shows all the rows in the language table. languages &lt;- dbGetQuery( con, &quot;select language_id, name, last_update from language ;&quot; ) sp_print_df(languages) One cannot insert/update a row into the film table with a language_id = 10 because of a constraint on the language_id column. The language_id value must already exist in the language table, values 1 - 6, before the database will allow the new row to be inserted into the table. 13.6 Messy Data The data in the DVD rental system is too clean to show some of the issues one comes across in the real world. In the following code blocks, we look at one row in the film table where the film_id = 1. We first reinitialize language_id to 1 and display the row. dbExecute(con, &quot;update film set language_id = 1 where film_id = 1;&quot;) ## [1] 1 dbGetQuery(con, &quot;select &#39;1. Update language_id = 1 successful&#39; step ,film_id, language_id from film where film_id = 1;&quot;) ## step film_id language_id ## 1 1. Update language_id = 1 successful 1 1 The following code block is an example of a SQL anonymous code block that gracefully handles the exception error when we try and update the row with language_id = 10. Note that the language_id is still 1. dbExecute(con, &quot; do $$ DECLARE v_id INTEGER; begin v_id = 10; update film set language_id = v_id where film_id = 1; exception when foreign_key_violation then raise notice &#39;SQLERRM = %, language_id = %&#39;, SQLERRM, v_id; when others then raise notice &#39;SQLERRM = % SQLSTATE =%&#39;, SQLERRM, SQLSTATE; end; $$ language &#39;plpgsql&#39;;&quot;) ## [1] 0 dbGetQuery(con, &quot;select &#39;2. Update language_id = 10 failed&#39; step ,film_id, language_id from film where film_id = 1;&quot;) ## step film_id language_id ## 1 2. Update language_id = 10 failed 1 1 13.6.1 Messing up the row The following code block disables all the database constraints on the film table Updates the row with language_id = 10. Re-enabes the database constraints on the film table # dbExecute(con, &quot;ALTER TABLE film DISABLE TRIGGER ALL;&quot;) ## [1] 0 count &lt;- dbExecute(con, &quot;update film set language_id = 10 where film_id = 1;&quot;) While the film table constraints are disabled, we will insert a new film with a language_id = 10. dbExecute( con, &quot;insert into film (film_id,title,description,release_year,language_id ,rental_duration,rental_rate,length,replacement_cost,rating ,last_update,special_features,fulltext) values(1001,&#39;Sophie&#39;&#39;s Choice&#39;,&#39;orphaned language_id=10&#39;,2018,10 ,7,4.99,120,14.99,&#39;PG&#39; ,now()::date,&#39;{Trailers}&#39;,&#39;&#39;) ; &quot; ) ## [1] 1 In the following code block we re-enable the film table constraints and confirm that the new record exists. dbExecute(con, &quot;ALTER TABLE film ENABLE TRIGGER ALL;&quot;) ## [1] 0 dbGetQuery( con, &quot;select film_id,title,description,language_id from film where film_id = 1001;&quot; ) ## film_id title description language_id ## 1 1001 Sophie&#39;s Choice orphaned language_id=10 10 13.7 Joins In section ‘SQL Quick Start Simple Retrieval’, there is a brief discussion of databases and 3NF. One of the goals of normalization is to eliminate redundant data being kept in multiple tables and having each table contain a very granular level of detail. If a record then needs to be updated, it is updated in one table instead of multiple tables improving overall system performance. This also helps simplify and maintain referential integerity between tables. Bill Kent famously summarized 3NF as every non-key column “must provide a fact about the key,the whole key, and nothing but the key, so help me Codd.” Normalization breaks data down and JOINs denormalizes the data and builds it back up. The tables are typically related via a primary key - foreign key relationship. The PostgreSQL database enforces the primary and foreign key constraints in the DVD rental database. 13.7.1 Join Types SQL_JOIN_TYPES The above diagram can be found here There are additional graphics at the link, but the explanations are poorly worded and hard to follow. The diagram above shows nicely the hierarchy of different types of joins. For this tutorial, we can think of joins as either an Inner Join or an Outer Join. Instead of showing standard Venn diagrams showing the different JOINS, we use an analogy. For those interested though, the typical Venn diagrams can be found here. 13.7.2 Valentines Party Imagine you are at a large costume Valentine’s Day dance party. The hostess of the party, a data scientist, would like to learn more about the people attending her party. When the band takes a break, she lets everyone know it is time for the judges to evaluate the winners for best costumes and associated prizes. ValentinesDay She requests the following: All the couples at the party line up in front of her in a single line with the men on her left and the women on her right, (inner join) All the remaining men to form a second line two feet behind the married men, (left outer join, all couples + unattached men) All the remaining women to form a third line two feet in front of the married women, (right outer join, all couples + unattached women) As our data scientist looks out, she can clearly see the three distinct lines, the single men, the man woman couples, and the single women, a full outer join. As the three judges start walking down the lines, she makes one more announcement. There is a special prize for the man and woman who can guess the average age of the members of the opposite sex. To give everyone a chance to come up with an average age, she asks the men to stay in line and the women to move down the mens line in order circling back around until they get back to their starting point in line, (cartesian join, every man seen by every woman and vice versa). It is hard enough to tell someone’s age when they don’t have a mask, how do you get the average age when people have masks? The hostess knows that there is usually some data anomolies. As she looks out she sees a small cluster of people who did not line up. Being the hostess with the mostest, she wants to get to know that small cluster better. Since they are far off and in costume, she cannot tell if they are men or women. More importantly, she does not know if they identify as a man or a woman, both – (kind of a stretch for a self join), neither, or something else. Ahh, the inquisitive mind wants to know. 13.7.3 Join Syntax The table below shows the two R join function call formats, standalone function call and pipe function call and the corresponding SQL join format. Join dplyr sql inner inner_join(customer_tbl, rental_tbl, by = ‘customer_id’, suffix = c(“.c”, “.r”)) from customer c join rental r on c.customer_id = r.customer_id customer_tbl %&gt;% inner_join(rental_tbl, by = ‘customer_id’, suffix = c(“.c”, “.r”)) left left_join(customer_tbl, rental_tbl, by = ‘customer_id’, suffix = c(“.c”, “.r”)) from customer c left outer join rental r on c.customer_id = r.customer_id customer_tbl %&gt;% left_join(rental_tbl, by = ‘customer_id’, suffix = c(“.c”, “.r”)) right right_join(customer_tbl, rental_tbl, by = ‘customer_id’, suffix = c(“.c”, “.r”)) from customer c right outer join rental r on c.customer_id = r.customer_id customer_tbl %&gt;% right_join(rental_tbl, by = ‘customer_id’, suffix = c(“.c”, “.r”)) full full_join(customer_tbl, rental_tbl, by = ‘customer_id’, suffix = c(“.c”, “.r”)) from customer c full outer join rental r on c.customer_id = r.customer_id customer_tbl %&gt;% full_join(rental_tbl, by = ‘customer_id’, suffix = c(“.c”, “.r”)) 13.7.4 Join Tables The dplyr join documentation describes two different types of joins, mutating and filtering joins. For those coming to R with a SQL background, the mutating documentation is misleading in one respect. Here is the inner_join documentation. inner_join() return all rows from x where there are matching values in y, and all columns from x and y. If there are multiple matches between x and y, all combination of the matches are returned. The misleading part is that all the columns from x and y. If the join column is KEY, SQL will return x.KEY and y.KEY. Dplyr retuns KEY. It appears that the KEY value comes from the driving table. This difference should become clear in the outer join examples. In the next couple of examples, we will pull all the language and film table data from the database into memory because the tables are small. In the *_join verbs, the by and suffix parameters are included because it helps document the actual join and the source of join columns. 13.8 Natural Join Delayed Time Bomb The dplyr default join is a natural join, joining tables on common column names. One of many links why one should not use natural joins can be found here. If two tables are joined via a natural join on column C1 the join continues to work as long as no additional common columns are added to either table. If a new new column C2 is added to one of the tables and C2 already exists in the other table, BOOM, the delayed time bomb goes off. The natural join still executes, doesn’t throw any errors, but the returned result set may be smaller, much smaller, than before the new C2 column was added. 13.8.1 SQL Language_id Distribution The next code block calculates the language_id distribution in the film and language tables. The results will be used in following sections to validate different join result sets. lang_distribution_sql &lt;- dbGetQuery(con ,&quot;select &#39;film&#39; tbl,language_id,count(*) count from film group by language_id union select &#39;language&#39; tbl,language_id,count(*) count from language group by language_id order by tbl,language_id;&quot; ) sp_print_df(lang_distribution_sql) 13.8.2 dplyr language distribution Exercise Execute and Review the output from the code block below. Union and arrange the output to match the SQL output in the previous code block. language_table &lt;- DBI::dbReadTable(con, &quot;language&quot;) film_table &lt;- DBI::dbReadTable(con, &quot;film&quot;) language_summary &lt;- language_table %&gt;% group_by(language_id) %&gt;% summarize(count=n()) %&gt;% mutate(table=&#39;language&#39;) %&gt;% select(table,language_id,count) film_summary &lt;- film_table %&gt;% group_by(language_id) %&gt;% summarize(count=n()) %&gt;% mutate(table=&#39;film&#39;) %&gt;% select(table,language_id,count) sp_print_df(language_summary) sp_print_df(film_summary) ## UNION the two summary tables and ARRANGE the output to match the SQL output from the previouse code block 13.9 Join Templates In this section we perform various joins using dplyr and SQL. Each dplyr code block has three purposes. Show a working join example. The code blocks can be used as templates for beginning more complex dplyr pipes. The code blocks show the number of joins performed. In these examples, the join condition, the by parameter, by = c(&#39;language_id&#39;,&#39;language_id&#39;) the two columns are the same. In multi-column joins, each language_id would be replaced with a vector of column names used in the join by position. Note the column names do not need to be identical by position. The suffix parameter is a way to distinguish the same column name in the joined tables. The suffixes are usually an single letter to represent the name of the table. 13.9.1 dplyr Inner Join Template For an inner join between two tables, it doesn’t matter which table is on the left, the first table, and which is on the right, the second table, because join conditions on both tables must be satisfied. languages_ij &lt;- language_table %&gt;% inner_join(film_table, by = c(&quot;language_id&quot; = &quot;language_id&quot;), suffix(c(&quot;.l&quot;, &quot;.f&quot;))) %&gt;% group_by(language_id, name) %&gt;% summarize(inner_joins = n()) sp_print_df(languages_ij) 13.9.1.1 SQL Inner Join The dplyr suffix is similar to the SQL table. In the previous code block, .l and .f were used in the inner_join suffix parameter. l. and f. are used as aliases in the SQL version below. The role of the dplyr suffix and the SQL alias is to disambiguate duplicate table and column names referenced. rs &lt;- dbGetQuery( con, &quot;select l.language_id,l.name,count(*) n from language l join film f on l.language_id = f.language_id group by l.language_id,l.name;&quot; ) sp_print_df(rs) The output tells us that there are 4.945544610^{-321} inner joins occurred between the language_table and the film_table. 13.9.2 dplyr Left Outer Join Template For a left outer join between two tables, it does matter which table is on the left, the first table, and which is on the right, the second table, because every row in the left table that satsifies the filter/where conditions are returned. The second table returns rows if the join condition is met or returns a row of all null column values. languages_loj &lt;- language_table %&gt;% left_join(film_table, by = c(&quot;language_id&quot;, &quot;language_id&quot;), suffix(c(&quot;.l&quot;, &quot;.f&quot;))) %&gt;% mutate( join_type = &quot;loj&quot;, film_lang_id = if_else(is.na(film_id), film_id, language_id) ) %&gt;% group_by(join_type, language_id, name, film_lang_id) %&gt;% summarize(lojs = n()) %&gt;% select(join_type, language_id, film_lang_id, name, lojs) print(languages_loj) ## # A tibble: 6 x 5 ## # Groups: join_type, language_id, name [6] ## join_type language_id film_lang_id name lojs ## &lt;chr&gt; &lt;int&gt; &lt;int&gt; &lt;chr&gt; &lt;int&gt; ## 1 loj 1 1 &quot;English &quot; 999 ## 2 loj 2 NA &quot;Italian &quot; 1 ## 3 loj 3 NA &quot;Japanese &quot; 1 ## 4 loj 4 NA &quot;Mandarin &quot; 1 ## 5 loj 5 NA &quot;French &quot; 1 ## 6 loj 6 NA &quot;German &quot; 1 sp_print_df(languages_loj) Compare the mutate verb in the above code block with film_lang_id in the equivalent SQL code block below. 13.9.2.1 SQL Left Outer Join rs &lt;- dbGetQuery( con, &quot;select l.language_id ,f.language_id film_lang_id ,trim(l.name) as name ,count(*) lojs from language l left outer join film f on l.language_id = f.language_id group by l.language_id,l.name,f.language_id order by l.language_id;&quot; ) sp_print_df(rs) The lojs column returns the number of rows found on the keys from the left table, language, and the right table, the film table. For the “English” row, the language_id and film_lang_id match and 4.945544610^{-321} inner joins were performed. For all the other languages, there was only 1 join and they all came from the left outer table, the language table, language_id’s 2 - 6. The right table, the film table returned NA, because no match was found. The left outer join always returns all rows from the left table, the driving/key table, if not reduced via a filter()/where clause. All rows that inner join returns all the columns/derived columns specified in the select clause from both the left and right tables. All rows from the left table, the outer table, without a matching row on the right returns all the columns/derived column values specified in the select clause from the left, but the values from right table have all values of NA. 13.9.2.2 dplyr Right Outer Join languages_roj &lt;- language_table %&gt;% right_join(film_table, by = c(&quot;language_id&quot;, &quot;language_id&quot;), suffix(c(&quot;.l&quot;, &quot;.f&quot;)), all = film_table) %&gt;% mutate( lang_id = if_else(is.na(name), 0L, language_id), join_type = &quot;rojs&quot; ) %&gt;% group_by(join_type, language_id, name, lang_id) %&gt;% summarize(rojs = n()) %&gt;% select(join_type, lang_id, language_id, name, rojs) sp_print_df(languages_roj) languages_roj ## # A tibble: 2 x 5 ## # Groups: join_type, language_id, name [2] ## join_type lang_id language_id name rojs ## &lt;chr&gt; &lt;int&gt; &lt;int&gt; &lt;chr&gt; &lt;int&gt; ## 1 rojs 1 1 &quot;English &quot; 999 ## 2 rojs 0 10 &lt;NA&gt; 2 Review the mutate above with l.language_id below. 13.9.2.3 SQL Right Outer Join rs &lt;- dbGetQuery( con, &quot;select &#39;roj&#39; join_type,l.language_id,f.language_id language_id_f,l.name,count(*) rojs from language l right outer join film f on l.language_id = f.language_id group by l.language_id,l.name,f.language_id order by l.language_id;&quot; ) sp_print_df(rs) rs ## join_type language_id language_id_f name rojs ## 1 roj 1 1 English 999 ## 2 roj NA 10 &lt;NA&gt; 2 The rojs column returns the number of rows found on the keys from the right table, film, and the left table, the language table. For the “English” row, the language_id and film_lang_id match and a 1000 inner joins were performed. For language_id = 30 from the right table, there was only 1 join to a non-existant row in the language table on the left. The right outer join always returns all rows from the right table, the driving/key table, if not reduced via a filter()/where clause. All rows that inner join returns all the columns/derived columns specified in the select clause from both the left and right tables. All rows from the right table, the outer table, without a matching row on the left returns all the columns/derived column values specified in the select clause from the right, but the values from left table have all values of NA. 13.9.2.4 dplyr Full Outer Join languages_foj &lt;- language_table %&gt;% full_join(film_table, by = c(&quot;language_id&quot;, &quot;language_id&quot;), suffix(c(&quot;.l&quot;, &quot;.f&quot;))) %&gt;% mutate(film_lang = if_else(is.na(film_id), paste0(&quot;No &quot;, name, &quot; films.&quot;), if_else(is.na(name), &quot;Alien&quot;, name))) %&gt;% group_by(language_id, name, film_lang) %&gt;% summarize(n = n()) sp_print_df(languages_foj) languages_foj ## # A tibble: 7 x 4 ## # Groups: language_id, name [?] ## language_id name film_lang n ## &lt;int&gt; &lt;chr&gt; &lt;chr&gt; &lt;int&gt; ## 1 1 &quot;English &quot; &quot;English &quot; 999 ## 2 2 &quot;Italian &quot; No Italian films. 1 ## 3 3 &quot;Japanese &quot; No Japanese films. 1 ## 4 4 &quot;Mandarin &quot; No Mandarin films. 1 ## 5 5 &quot;French &quot; No French films. 1 ## 6 6 &quot;German &quot; No German films. 1 ## 7 10 &lt;NA&gt; Alien 2 13.9.2.5 SQL full Outer Join rs &lt;- dbGetQuery( con, &quot;select l.language_id,l.name,f.language_id language_id_f,count(*) fojs from language l full outer join film f on l.language_id = f.language_id group by l.language_id,l.name,f.language_id order by l.language_id;&quot; ) sp_print_df(rs) rs ## language_id name language_id_f fojs ## 1 1 English 1 999 ## 2 2 Italian NA 1 ## 3 3 Japanese NA 1 ## 4 4 Mandarin NA 1 ## 5 5 French NA 1 ## 6 6 German NA 1 ## 7 NA &lt;NA&gt; 10 2 Looking at the SQL output, the full outer join is the combination of the left and right outer joins. Language_id = 1 is the inner join. Language_id = 2 - 6 is the left outer join Language_id = 30 is the right outer join. One can also just look at the language_id on the left and language_id_f on the right for a non NA value to see which side is outer side/driving side of the join. 13.9.2.6 dplyr anti Join The anti join is a left outer join without the inner joined rows. It only returns the rows from the left table that do not have a match from the right table. languages_aj &lt;- language_table %&gt;% anti_join(film_table, by = c(&quot;language_id&quot;, &quot;language_id&quot;), suffix(c(&quot;.l&quot;, &quot;.f&quot;))) %&gt;% mutate(type = &quot;anti_join&quot;) %&gt;% group_by(type, language_id, name) %&gt;% summarize(anti_joins = n()) %&gt;% select(type, language_id, name, anti_joins) sp_print_df(languages_aj) languages_aj ## # A tibble: 5 x 4 ## # Groups: type, language_id [5] ## type language_id name anti_joins ## &lt;chr&gt; &lt;int&gt; &lt;chr&gt; &lt;int&gt; ## 1 anti_join 2 &quot;Italian &quot; 1 ## 2 anti_join 3 &quot;Japanese &quot; 1 ## 3 anti_join 4 &quot;Mandarin &quot; 1 ## 4 anti_join 5 &quot;French &quot; 1 ## 5 anti_join 6 &quot;German &quot; 1 13.9.2.7 SQL anti Join 1, Left Outer Join where NULL on Right SQL doesn’t have an anti join key word. Here are three different ways to achieve the same result. rs &lt;- dbGetQuery( con, &quot;select l.language_id,l.name,count(*) fojs from language l left outer join film f on l.language_id = f.language_id where f.language_id is null group by l.language_id,l.name order by l.language_id;&quot; ) sp_print_df(rs) rs ## language_id name fojs ## 1 2 Italian 1 ## 2 3 Japanese 1 ## 3 4 Mandarin 1 ## 4 5 French 1 ## 5 6 German 1 13.9.2.8 SQL anti Join 2, ID in driving table and NOT IN lookup table rs &lt;- dbGetQuery( con, &quot;select l.language_id,l.name,count(*) fojs from language l where l.language_id NOT IN (select language_id from film) group by l.language_id,l.name order by l.language_id;&quot; ) sp_print_df(rs) rs ## language_id name fojs ## 1 2 Italian 1 ## 2 3 Japanese 1 ## 3 4 Mandarin 1 ## 4 5 French 1 ## 5 6 German 1 13.9.2.9 SQL anti Join 3, NOT EXISTS and Correlated subquery rs &lt;- dbGetQuery( con, &quot;select l.language_id,l.name,count(*) fojs from language l where not exists (select language_id from film f where f.language_id = l.language_id) group by l.language_id,l.name &quot; ) sp_print_df(rs) rs ## language_id name fojs ## 1 6 German 1 ## 2 3 Japanese 1 ## 3 5 French 1 ## 4 4 Mandarin 1 ## 5 2 Italian 1 13.10 SQL anti join Costs sql_aj1 &lt;- dbGetQuery( con, &quot;explain analyze select l.language_id,l.name,count(*) fojs from language l left outer join film f on l.language_id = f.language_id where f.language_id is null group by l.language_id,l.name &quot; ) sql_aj2 &lt;- dbGetQuery( con, &quot;explain analyze select l.language_id,l.name,count(*) fojs from language l where l.language_id NOT IN (select language_id from film) group by l.language_id,l.name &quot; ) sql_aj3 &lt;- dbGetQuery( con, &quot;explain analyze select l.language_id,l.name,count(*) fojs from language l where not exists (select language_id from film f where f.language_id = l.language_id) group by l.language_id,l.name &quot; ) 13.10.0.0.1 SQL Costs print(glue(&quot;sql_aj1 loj-null costs=&quot;, sql_aj1[1, 1])) ## sql_aj1 loj-null costs=HashAggregate (cost=3.15..3.20 rows=5 width=96) (actual time=0.077..0.081 rows=5 loops=1) print(glue(&quot;sql_aj2 not in costs=&quot;, sql_aj2[1, 1])) ## sql_aj2 not in costs=GroupAggregate (cost=67.60..67.65 rows=3 width=96) (actual time=1.919..1.928 rows=5 loops=1) print(glue(&quot;sql_aj3 not exist costs=&quot;, sql_aj3[1, 1])) ## sql_aj3 not exist costs=HashAggregate (cost=3.15..3.20 rows=5 width=96) (actual time=0.086..0.092 rows=5 loops=1) 13.11 dplyr Anti joins In this next section we look at two methods to implemnt an anti join in dplyr. customer_table &lt;- tbl(con, &quot;customer&quot;) # DBI::dbReadTable(con, &quot;customer&quot;) rental_table &lt;- tbl(con, &quot;rental&quot;) # DBI::dbReadTable(con, &quot;rental&quot;) Method 1. dplyr anti_join daj1 &lt;- anti_join(customer_table, rental_table, by = &quot;customer_id&quot;, suffix = c(&quot;.c&quot;, &quot;.r&quot;)) %&gt;% select(c(&quot;first_name&quot;, &quot;last_name&quot;, &quot;email&quot;)) %&gt;% explain() ## &lt;SQL&gt; ## SELECT &quot;first_name&quot;, &quot;last_name&quot;, &quot;email&quot; ## FROM (SELECT * FROM &quot;customer&quot; AS &quot;TBL_LEFT&quot; ## ## WHERE NOT EXISTS ( ## SELECT 1 FROM &quot;rental&quot; AS &quot;TBL_RIGHT&quot; ## WHERE (&quot;TBL_LEFT&quot;.&quot;customer_id&quot; = &quot;TBL_RIGHT&quot;.&quot;customer_id&quot;) ## )) &quot;vvgblxmrcz&quot; ## ## &lt;PLAN&gt; ## Hash Anti Join (cost=510.99..529.72 rows=1 width=45) ## Hash Cond: (&quot;TBL_LEFT&quot;.customer_id = &quot;TBL_RIGHT&quot;.customer_id) ## -&gt; Seq Scan on customer &quot;TBL_LEFT&quot; (cost=0.00..14.99 rows=599 width=49) ## -&gt; Hash (cost=310.44..310.44 rows=16044 width=2) ## -&gt; Seq Scan on rental &quot;TBL_RIGHT&quot; (cost=0.00..310.44 rows=16044 width=2) customer_table &lt;- tbl(con, &quot;customer&quot;) # DBI::dbReadTable(con, &quot;customer&quot;) rental_table &lt;- tbl(con, &quot;rental&quot;) # DBI::dbReadTable(con, &quot;rental&quot;) Method 2. dplyr loj with NA daj2 &lt;- left_join(customer_table, rental_table, by = c(&quot;customer_id&quot;, &quot;customer_id&quot;), suffix = c(&quot;.c&quot;, &quot;.r&quot;)) %&gt;% filter(is.na(rental_id)) %&gt;% select(c(&quot;first_name&quot;, &quot;last_name&quot;, &quot;email&quot;)) %&gt;% explain() ## &lt;SQL&gt; ## SELECT &quot;first_name&quot;, &quot;last_name&quot;, &quot;email&quot; ## FROM (SELECT &quot;TBL_LEFT&quot;.&quot;customer_id&quot; AS &quot;customer_id&quot;, &quot;TBL_LEFT&quot;.&quot;store_id&quot; AS &quot;store_id&quot;, &quot;TBL_LEFT&quot;.&quot;first_name&quot; AS &quot;first_name&quot;, &quot;TBL_LEFT&quot;.&quot;last_name&quot; AS &quot;last_name&quot;, &quot;TBL_LEFT&quot;.&quot;email&quot; AS &quot;email&quot;, &quot;TBL_LEFT&quot;.&quot;address_id&quot; AS &quot;address_id&quot;, &quot;TBL_LEFT&quot;.&quot;activebool&quot; AS &quot;activebool&quot;, &quot;TBL_LEFT&quot;.&quot;create_date&quot; AS &quot;create_date&quot;, &quot;TBL_LEFT&quot;.&quot;last_update&quot; AS &quot;last_update.c&quot;, &quot;TBL_LEFT&quot;.&quot;active&quot; AS &quot;active&quot;, &quot;TBL_RIGHT&quot;.&quot;rental_id&quot; AS &quot;rental_id&quot;, &quot;TBL_RIGHT&quot;.&quot;rental_date&quot; AS &quot;rental_date&quot;, &quot;TBL_RIGHT&quot;.&quot;inventory_id&quot; AS &quot;inventory_id&quot;, &quot;TBL_RIGHT&quot;.&quot;return_date&quot; AS &quot;return_date&quot;, &quot;TBL_RIGHT&quot;.&quot;staff_id&quot; AS &quot;staff_id&quot;, &quot;TBL_RIGHT&quot;.&quot;last_update&quot; AS &quot;last_update.r&quot; ## FROM &quot;customer&quot; AS &quot;TBL_LEFT&quot; ## LEFT JOIN &quot;rental&quot; AS &quot;TBL_RIGHT&quot; ## ON (&quot;TBL_LEFT&quot;.&quot;customer_id&quot; = &quot;TBL_RIGHT&quot;.&quot;customer_id&quot;) ## ) &quot;kxatatjmzx&quot; ## WHERE (((&quot;rental_id&quot;) IS NULL)) ## ## &lt;PLAN&gt; ## Hash Right Join (cost=22.48..375.33 rows=1 width=45) ## Hash Cond: (&quot;TBL_RIGHT&quot;.customer_id = &quot;TBL_LEFT&quot;.customer_id) ## Filter: (&quot;TBL_RIGHT&quot;.rental_id IS NULL) ## -&gt; Seq Scan on rental &quot;TBL_RIGHT&quot; (cost=0.00..310.44 rows=16044 width=6) ## -&gt; Hash (cost=14.99..14.99 rows=599 width=49) ## -&gt; Seq Scan on customer &quot;TBL_LEFT&quot; (cost=0.00..14.99 rows=599 width=49) 13.11.1 dplyr Costs &lt;PLAN&gt; Hash Anti Join (cost=510.99..529.72 rows=1 width=45) Hash Cond: (&quot;TBL_LEFT&quot;.customer_id = &quot;TBL_RIGHT&quot;.customer_id) -&gt; Seq Scan on customer &quot;TBL_LEFT&quot; (cost=0.00..14.99 rows=599 width=49) -&gt; Hash (cost=310.44..310.44 rows=16044 width=2) -&gt; Seq Scan on rental &quot;TBL_RIGHT&quot; (cost=0.00..310.44 rows=16044 width=2) &lt;PLAN&gt; Hash Right Join (cost=22.48..375.33 rows=1 width=45) Hash Cond: (&quot;TBL_RIGHT&quot;.customer_id = &quot;TBL_LEFT&quot;.customer_id) Filter: (&quot;TBL_RIGHT&quot;.rental_id IS NULL) -&gt; Seq Scan on rental &quot;TBL_RIGHT&quot; (cost=0.00..310.44 rows=16044 width=6) -&gt; Hash (cost=14.99..14.99 rows=599 width=49) -&gt; Seq Scan on customer &quot;TBL_LEFT&quot; (cost=0.00..14.99 rows=599 width=49) In this example, the dplyr anti_join verb is 1.4113447 to 22.7308719 times more expensive than the left outer join with a null condition. sql_aj1 &lt;- dbGetQuery( con, &quot;explain analyze select c.customer_id,count(*) lojs from customer c left outer join rental r on c.customer_id = r.customer_id where r.customer_id is null group by c.customer_id order by c.customer_id;&quot; ) sp_print_df(sql_aj1) sql_aj1 ## QUERY PLAN ## 1 GroupAggregate (cost=529.73..529.75 rows=1 width=12) (actual time=26.980..26.993 rows=7 loops=1) ## 2 Group Key: c.customer_id ## 3 -&gt; Sort (cost=529.73..529.74 rows=1 width=4) (actual time=26.972..26.977 rows=7 loops=1) ## 4 Sort Key: c.customer_id ## 5 Sort Method: quicksort Memory: 25kB ## 6 -&gt; Hash Anti Join (cost=510.99..529.72 rows=1 width=4) (actual time=26.944..26.957 rows=7 loops=1) ## 7 Hash Cond: (c.customer_id = r.customer_id) ## 8 -&gt; Seq Scan on customer c (cost=0.00..14.99 rows=599 width=4) (actual time=0.006..0.530 rows=606 loops=1) ## 9 -&gt; Hash (cost=310.44..310.44 rows=16044 width=2) (actual time=25.857..25.858 rows=16044 loops=1) ## 10 Buckets: 16384 Batches: 1 Memory Usage: 661kB ## 11 -&gt; Seq Scan on rental r (cost=0.00..310.44 rows=16044 width=2) (actual time=0.009..14.197 rows=16044 loops=1) ## 12 Planning time: 0.197 ms ## 13 Execution time: 27.039 ms sql_aj3 &lt;- dbGetQuery( con, &quot;explain analyze select c.customer_id,count(*) lojs from customer c where not exists (select customer_id from rental r where c.customer_id = r.customer_id) group by c.customer_id &quot; ) print(glue(&quot;sql_aj1 loj-null costs=&quot;, sql_aj1[1, 1])) ## sql_aj1 loj-null costs=GroupAggregate (cost=529.73..529.75 rows=1 width=12) (actual time=26.980..26.993 rows=7 loops=1) print(glue(&quot;sql_aj3 not exist costs=&quot;, sql_aj3[1, 1])) ## sql_aj3 not exist costs=GroupAggregate (cost=529.73..529.75 rows=1 width=12) (actual time=28.181..28.195 rows=7 loops=1) 13.12 Exercises 13.12.1 Anti joins – Find customers who have never rented a movie, take 2. This is a left outer join from customer to the rental table with an NA rental_id. 13.12.1.1 SQL Anti-Join rs &lt;- dbGetQuery( con, &quot;select c.first_name ,c.last_name ,c.email from customer c left outer join rental r on c.customer_id = r.customer_id where r.rental_id is null; &quot; ) sp_print_df(head(rs)) &lt;– Add dplyr semi-join example –&gt; 13.12.2 SQL Rows Per Table In the examples above, we looked at how many rows were involved in each of the join examples and which side of the join they came from. It is often helpful to know how many rows are in each table as a sanity check on the joins. Below is the SQL version to return all the row counts from each table in the DVD Rental System. rs &lt;- dbGetQuery( con, &quot;select * from ( select &#39;actor&#39; tbl_name,count(*) from actor union select &#39;category&#39; tbl_name,count(*) from category union select &#39;film&#39; tbl_name,count(*) from film union select &#39;film_actor&#39; tbl_name,count(*) from film_actor union select &#39;film_category&#39; tbl_name,count(*) from film_category union select &#39;language&#39; tbl_name,count(*) from language union select &#39;inventory&#39; tbl_name,count(*) from inventory union select &#39;rental&#39; tbl_name,count(*) from rental union select &#39;payment&#39; tbl_name,count(*) from payment union select &#39;staff&#39; tbl_name,count(*) from staff union select &#39;customer&#39; tbl_name,count(*) from customer union select &#39;address&#39; tbl_name,count(*) from address union select &#39;city&#39; tbl_name,count(*) from city union select &#39;country&#39; tbl_name,count(*) from country union select &#39;store&#39; tbl_name,count(*) from store ) counts order by tbl_name ; &quot; ) sp_print_df(head(rs)) rs ## tbl_name count ## 1 actor 200 ## 2 address 603 ## 3 category 16 ## 4 city 600 ## 5 country 109 ## 6 customer 606 ## 7 film 1001 ## 8 film_actor 5462 ## 9 film_category 1000 ## 10 inventory 4581 ## 11 language 6 ## 12 payment 14596 ## 13 rental 16044 ## 14 staff 2 ## 15 store 3 13.12.2.1 Exercise dplyr Rows Per Table In the code block below Get the row counts for a couple more tables What is the structure of film_table object? film_table &lt;- tbl(con, &quot;film&quot;) # DBI::dbReadTable(con, &quot;customer&quot;) language_table &lt;- tbl(con, &quot;language&quot;) # DBI::dbReadTable(con, &quot;rental&quot;) film_rows &lt;- film_table %&gt;% mutate(name = &quot;film&quot;) %&gt;% group_by(name) %&gt;% summarize(rows = n()) language_rows &lt;- language_table %&gt;% mutate(name = &quot;language&quot;) %&gt;% group_by(name) %&gt;% summarize(rows = n()) rows_per_table &lt;- rbind(as.data.frame(film_rows), as.data.frame(language_rows)) rows_per_table ## name rows ## 1 film 1001 ## 2 language 6 13.12.2.2 SQL film distribution based on language The SQL below is very similar to the SQL full Outer Join above. Instead of counting the joins, it counts the number films associated with each language. rs &lt;- dbGetQuery( con, &quot;select l.language_id id ,l.name ,sum(case when f.language_id is not null then 1 else 0 end) total from language l full outer join film f on l.language_id = f.language_id group by l.language_id,l.name order by l.name; ; &quot; ) sp_print_df(head(rs)) rs ## id name total ## 1 1 English 999 ## 2 5 French 0 ## 3 6 German 0 ## 4 2 Italian 0 ## 5 3 Japanese 0 ## 6 4 Mandarin 0 ## 7 NA &lt;NA&gt; 2 13.12.2.3 Exercise dplyr film distribution based on language Below is the code block from the dplyr Full Outer Join section above. Modify the code block to match the output from the SQL version. rs &lt;- dbGetQuery( con, &quot;select l.language_id,l.name,f.language_id language_id_f,count(*) fojs from language l full outer join film f on l.language_id = f.language_id group by l.language_id,l.name,f.language_id order by l.language_id;&quot; ) sp_print_df(rs) rs ## language_id name language_id_f fojs ## 1 1 English 1 999 ## 2 2 Italian NA 1 ## 3 3 Japanese NA 1 ## 4 4 Mandarin NA 1 ## 5 5 French NA 1 ## 6 6 German NA 1 ## 7 NA &lt;NA&gt; 10 2 13.13 Store analysis How are the stores performing. 13.13.1 SQL store revenue stream How are the stores performing? The SQL code shows the payments made to each store in the business. rs &lt;- dbGetQuery( con, &quot;select store_id,sum(p.amount) amt,count(*) cnt from payment p join staff s on p.staff_id = s.staff_id group by store_id order by 2 desc ; &quot; ) sp_print_df(head(rs)) 13.13.1.1 Exercise dplyr store revenue stream Complete the following code block to return the payments made to each store. payment_table &lt;- tbl(con, &quot;payment&quot;) # DBI::dbReadTable(con, &quot;payment&quot;) staff_table &lt;- tbl(con, &quot;staff&quot;) # DBI::dbReadTable(con, &quot;staff&quot;) store_revenue &lt;- payment_table %&gt;% inner_join(staff_table, by = &quot;staff_id&quot;, suffix = c(&quot;.p&quot;, &quot;.s&quot;)) %&gt;% head() store_revenue ## # Source: lazy query [?? x 16] ## # Database: postgres [postgres@localhost:5432/dvdrental] ## payment_id customer_id staff_id rental_id amount payment_date ## &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;dbl&gt; &lt;dttm&gt; ## 1 17503 341 2 1520 7.99 2007-02-15 22:25:46 ## 2 17504 341 1 1778 1.99 2007-02-16 17:23:14 ## 3 17505 341 1 1849 7.99 2007-02-16 22:41:45 ## 4 17506 341 2 2829 2.99 2007-02-19 19:39:56 ## 5 17507 341 2 3130 7.99 2007-02-20 17:31:48 ## 6 17508 341 1 3382 5.99 2007-02-21 12:33:49 ## # ... with 10 more variables: first_name &lt;chr&gt;, last_name &lt;chr&gt;, ## # address_id &lt;int&gt;, email &lt;chr&gt;, store_id &lt;int&gt;, active &lt;lgl&gt;, ## # username &lt;chr&gt;, password &lt;chr&gt;, last_update &lt;dttm&gt;, picture &lt;blob&gt; 13.13.2 SQL:Estimate Outstanding Balance The following SQL code calculates for each store the number of payments still open and closed from the DVD Rental Stores customer base. the total amount that their customers have paid the average price per/movie based off of the movies that have been paid. the estimated outstanding balance based off the open unpaid rentals * the average price per paid movie. rs &lt;- dbGetQuery( con, &quot;SELECT s.store_id store,sum(CASE WHEN payment_id IS NULL THEN 1 ELSE 0 END) open ,sum(CASE WHEN payment_id IS NOT NULL THEN 1 ELSE 0 END) paid ,sum(p.amount) paid_amt ,count(*) rentals ,round(sum(p.amount) / sum(CASE WHEN payment_id IS NOT NULL THEN 1 ELSE 0 END), 2) avg_price ,round(round(sum(p.amount) / sum(CASE WHEN payment_id IS NOT NULL THEN 1 ELSE 0 END), 2) * sum(CASE WHEN payment_id IS NULL THEN 1 ELSE 0 END), 2) est_balance FROM rental r LEFT JOIN payment p ON r.rental_id = p.rental_id JOIN staff s ON r.staff_id = s.staff_id group by s.store_id; &quot; ) sp_print_df(head(rs)) rs ## store open paid paid_amt rentals avg_price est_balance ## 1 1 713 7331 30498.71 8044 4.16 2966.08 ## 2 2 739 7265 30813.33 8004 4.24 3133.36 13.13.2.1 Exercise Dplyr Modify the following dplyr code to match the SQL output from above. payment_table &lt;- tbl(con, &quot;payment&quot;) # DBI::dbReadTable(con, &quot;payment&quot;) rental_table &lt;- tbl(con, &quot;rental&quot;) # DBI::dbReadTable(con, &quot;rental&quot;) est_bal &lt;- rental_table %&gt;% left_join(payment_table, by = c(&quot;rental_id&quot;, &quot;rental_id&quot;), suffix = c(&quot;.r&quot;, &quot;.p&quot;)) %&gt;% mutate( missing = ifelse(is.na(payment_id), 1, 0), found = ifelse(!is.na(payment_id), 1, 0) ) %&gt;% summarize( open = sum(missing, na.rm = TRUE), paid = sum(found, na.rm = TRUE), paid_amt = sum(amount, na.rm = TRUE), rentals = n() ) %&gt;% summarize( open = open, paid = paid, paid_amt = paid_amt, rentals = rentals, avg_price = paid_amt / paid, est_balance = paid_amt / paid * open ) est_bal ## # Source: lazy query [?? x 6] ## # Database: postgres [postgres@localhost:5432/dvdrental] ## open paid paid_amt rentals avg_price est_balance ## &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;S3: integer64&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 1452 14596 61312. 16048 4.20 6099. 13.13.3 SQL actual outstanding balance In the previous exercise, we estimated the outstanding amount. After reviewing the rental table, the actual movie rental rate is in the table. We use that to calculate the outstanding balance below. rs &lt;- dbGetQuery( con, &quot;SELECT sum(f.rental_rate) open_amt ,count(*) count FROM rental r LEFT JOIN payment p ON r.rental_id = p.rental_id INNER JOIN inventory i ON r.inventory_id = i.inventory_id INNER JOIN film f ON i.film_id = f.film_id WHERE p.rental_id IS NULL ;&quot; ) sp_print_df(head(rs)) rs ## open_amt count ## 1 4297.48 1452 payment_table &lt;- tbl(con, &quot;payment&quot;) # DBI::dbReadTable(con, &quot;payment&quot;) rental_table &lt;- tbl(con, &quot;rental&quot;) # DBI::dbReadTable(con, &quot;rental&quot;) inventory_table &lt;- tbl(con, &quot;inventory&quot;) # DBI::dbReadTable(con, &quot;inventory&quot;) film_table &lt;- tbl(con, &quot;film&quot;) # DBI::dbReadTable(con, &quot;film&quot;) act_bal &lt;- rental_table %&gt;% left_join(payment_table, by = c(&quot;rental_id&quot;, &quot;rental_id&quot;), suffix = c(&quot;.r&quot;, &quot;.p&quot;)) %&gt;% inner_join(inventory_table, by = c(&quot;inventory_id&quot;, &quot;inventory_id&quot;), suffix = c(&quot;.r&quot;, &quot;.i&quot;)) %&gt;% inner_join(film_table, by = c(&quot;film_id&quot;, &quot;film_id&quot;), suffix = c(&quot;.i&quot;, &quot;.f&quot;)) %&gt;% head() act_bal ## # Source: lazy query [?? x 27] ## # Database: postgres [postgres@localhost:5432/dvdrental] ## rental_id rental_date inventory_id customer_id.r ## &lt;int&gt; &lt;dttm&gt; &lt;int&gt; &lt;int&gt; ## 1 4863 2005-07-08 19:03:15 1 431 ## 2 11433 2005-08-02 20:13:10 1 518 ## 3 14714 2005-08-21 21:27:43 1 279 ## 4 972 2005-05-30 20:21:07 2 411 ## 5 2117 2005-06-17 20:24:00 2 170 ## 6 4187 2005-07-07 10:41:31 2 161 ## # ... with 23 more variables: return_date &lt;dttm&gt;, staff_id.r &lt;int&gt;, ## # last_update.r &lt;dttm&gt;, payment_id &lt;int&gt;, customer_id.p &lt;int&gt;, ## # staff_id.p &lt;int&gt;, amount &lt;dbl&gt;, payment_date &lt;dttm&gt;, film_id &lt;int&gt;, ## # store_id &lt;int&gt;, last_update.i &lt;dttm&gt;, title &lt;chr&gt;, description &lt;chr&gt;, ## # release_year &lt;int&gt;, language_id &lt;int&gt;, rental_duration &lt;int&gt;, ## # rental_rate &lt;dbl&gt;, length &lt;int&gt;, replacement_cost &lt;dbl&gt;, rating &lt;S3: ## # pq_mpaa_rating&gt;, last_update &lt;dttm&gt;, special_features &lt;S3: pq__text&gt;, ## # fulltext &lt;S3: pq_tsvector&gt; 13.13.4 Rank customers with highest open amounts rs &lt;- dbGetQuery( con, &quot;select c.customer_id,c.first_name,c.last_name,sum(f.rental_rate) open_amt,count(*) count from rental r left outer join payment p on r.rental_id = p.rental_id join inventory i on r.inventory_id = i.inventory_id join film f on i.film_id = f.film_id join customer c on r.customer_id = c.customer_id where p.rental_id is null group by c.customer_id,c.first_name,c.last_name order by open_amt desc limit 25 ;&quot; ) sp_print_df(head(rs)) rs ## customer_id first_name last_name open_amt count ## 1 293 Mae Fletcher 35.90 10 ## 2 307 Joseph Joy 31.90 10 ## 3 316 Steven Curley 31.90 10 ## 4 299 James Gannon 30.91 9 ## 5 274 Naomi Jennings 29.92 8 ## 6 326 Jose Andrew 28.93 7 ## 7 338 Dennis Gilman 27.92 8 ## 8 277 Olga Jimenez 27.92 8 ## 9 327 Larry Thrasher 26.93 7 ## 10 330 Scott Shelley 26.93 7 ## 11 322 Jason Morrissey 26.91 9 ## 12 340 Patrick Newsom 25.92 8 ## 13 336 Joshua Mark 25.92 8 ## 14 304 David Royal 24.93 7 ## 15 339 Walter Perryman 23.94 6 ## 16 239 Minnie Romero 23.94 6 ## 17 310 Daniel Cabral 22.93 7 ## 18 296 Ramona Hale 22.93 7 ## 19 313 Donald Mahon 22.93 7 ## 20 287 Becky Miles 22.93 7 ## 21 272 Kay Caldwell 22.93 7 ## 22 303 William Satterfield 22.93 7 ## 23 329 Frank Waggoner 22.91 9 ## 24 311 Paul Trout 21.92 8 ## 25 109 Edna West 20.93 7 13.13.5 what film has been rented the most rs &lt;- dbGetQuery( con, &quot;SELECT i.film_id ,f.title ,rental_rate ,sum(rental_rate) revenue ,count(*) count --16044 FROM rental r INNER JOIN inventory i ON r.inventory_id = i.inventory_id INNER JOIN film f ON i.film_id = f.film_id GROUP BY i.film_id ,f.title ,rental_rate ORDER BY count DESC LIMIT 25 ;&quot; ) sp_print_df(head(rs)) rs ## film_id title rental_rate revenue count ## 1 103 Bucket Brotherhood 4.99 169.66 34 ## 2 738 Rocketeer Mother 0.99 32.67 33 ## 3 382 Grit Clockwork 0.99 31.68 32 ## 4 331 Forward Temple 2.99 95.68 32 ## 5 489 Juggler Hardly 0.99 31.68 32 ## 6 767 Scalawag Duck 4.99 159.68 32 ## 7 730 Ridgemont Submarine 0.99 31.68 32 ## 8 1000 Zorro Ark 4.99 154.69 31 ## 9 369 Goodfellas Salute 4.99 154.69 31 ## 10 621 Network Peak 2.99 92.69 31 ## 11 31 Apache Divine 4.99 154.69 31 ## 12 753 Rush Goodfellas 0.99 30.69 31 ## 13 735 Robbers Joon 2.99 92.69 31 ## 14 418 Hobbit Alien 0.99 30.69 31 ## 15 891 Timberland Sky 0.99 30.69 31 ## 16 973 Wife Turn 4.99 154.69 31 ## 17 869 Suspects Quills 2.99 89.70 30 ## 18 450 Idols Snatchers 2.99 89.70 30 ## 19 748 Rugrats Shakespeare 0.99 29.70 30 ## 20 789 Shock Cabin 2.99 89.70 30 ## 21 341 Frost Head 0.99 29.70 30 ## 22 559 Married Go 2.99 89.70 30 ## 23 609 Muscle Bright 2.99 89.70 30 ## 24 127 Cat Coneheads 4.99 149.70 30 ## 25 285 English Bulworth 0.99 29.70 30 13.13.6 what film has been generated the most revenue assuming all amounts are collected rs &lt;- dbGetQuery( con, &quot;select i.film_id,f.title,rental_rate ,sum(rental_rate) revenue,count(*) count --16044 from rental r join inventory i on r.inventory_id = i.inventory_id join film f on i.film_id = f.film_id group by i.film_id,f.title,rental_rate order by revenue desc ;&quot; ) sp_print_df(head(rs)) 13.13.7 which films are in one store but not the other. rs &lt;- dbGetQuery( con, &quot;select coalesce(i1.film_id,i2.film_id) film_id ,f.title,f.rental_rate,i1.store_id,i1.count,i2.store_id,i2.count from (select film_id,store_id,count(*) count from inventory where store_id = 1 group by film_id,store_id) as i1 full outer join (select film_id,store_id,count(*) count from inventory where store_id = 2 group by film_id,store_id ) as i2 on i1.film_id = i2.film_id join film f on coalesce(i1.film_id,i2.film_id) = f.film_id where i1.film_id is null or i2.film_id is null order by f.title ; &quot; ) sp_print_df(head(rs)) 13.13.8 Compute the outstanding balance. rs &lt;- dbGetQuery( con, &quot;select sum(f.rental_rate) open_amt,count(*) count from rental r left outer join payment p on r.rental_id = p.rental_id join inventory i on r.inventory_id = i.inventory_id join film f on i.film_id = f.film_id where p.rental_id is null ;&quot; ) sp_print_df(head(rs)) ### Which Stores Have Movies That Have Never Rented? not_rented &lt;- dbGetQuery(con, &quot;select i.store_id,f.film_id,f.title,f.description,i.last_update from inventory i left outer join rental r on i.inventory_id = r.inventory_id join film f on i.film_id = f.film_id where r.inventory_id is null &quot;) sp_print_df(not_rented) sp_print_df(dbGetQuery(con,&quot;select min(last_update) mn, max(last_update) mx from inventory;&quot;)) sp_print_df(dbGetQuery(con,&quot;select rental_date,count(*) from rental group by rental_date order by rental_date;&quot;)) 13.14 Different strategies for interacting with the database select examples dbGetQuery returns the entire result set as a data frame. For large returned datasets, complex or inefficient SQL statements, this may take a long time. dbSendQuery: parses, compiles, creates the optimized execution plan. dbFetch: Execute optimzed execution plan and return the dataset. dbClearResult: remove pending query results from the database to your R environment 13.14.1 Use dbGetQuery How many customers are there in the DVD Rental System rs1 &lt;- dbGetQuery(con, &quot;select * from customer;&quot;) sp_print_df(head(rs1)) pco &lt;- dbSendQuery(con, &quot;select * from customer;&quot;) rs2 &lt;- dbFetch(pco) dbClearResult(pco) sp_print_df(head(rs2)) 13.14.2 Use dbExecute 13.14.3 Anti join – Find Sophie who has never rented a movie. customer_table &lt;- DBI::dbReadTable(con, &quot;customer&quot;) rental_table &lt;- DBI::dbReadTable(con, &quot;rental&quot;) customer_tbl &lt;- dplyr::tbl(con, &quot;customer&quot;) rental_tbl &lt;- dplyr::tbl(con, &quot;rental&quot;) dplyr_tbl_loj &lt;- left_join(customer_tbl, rental_tbl, by = &quot;customer_id&quot;, suffix = c(&quot;.c&quot;, &quot;.r&quot;)) %&gt;% filter(is.na(rental_id)) %&gt;% select(c(&quot;first_name&quot;, &quot;last_name&quot;, &quot;email&quot;)) %&gt;% collect() rs &lt;- dbGetQuery( con, &quot;select c.first_name ,c.last_name ,c.email from customer c left outer join rental r on c.customer_id = r.customer_id where r.rental_id is null; &quot; ) sp_print_df(head(rs)) sp_print_df(dplyr_tbl_loj) Create an edge data frame, edf Disconnect from the db: dbDisconnect(con) sp_docker_stop(&quot;sql-pet&quot;) knitr::knit_exit() "]
]
