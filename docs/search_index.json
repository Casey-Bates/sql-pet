[
["introduction-to-dbms-queries-11.html", "Chapter 8 Introduction to DBMS queries (11) 8.1 Getting data from the database 8.2 Investigating a single table with R 8.3 Dividing the work between R on your machine and the DBMS 8.4 DBI Package 8.5 Other resources", " Chapter 8 Introduction to DBMS queries (11) The following packages are used in this chapter: library(tidyverse) library(DBI) library(RPostgres) library(dbplyr) require(knitr) library(bookdown) library(sqlpetr) Assume that the Docker container with PostgreSQL and the dvdrental database are ready to go. sp_docker_start(&quot;sql-pet&quot;) Connect to the database: con &lt;- sp_get_postgres_connection(user = Sys.getenv(&quot;DEFAULT_POSTGRES_USER_NAME&quot;), password = Sys.getenv(&quot;DEFAULT_POSTGRES_PASSWORD&quot;), dbname = &quot;dvdrental&quot;, seconds_to_test = 10) 8.1 Getting data from the database As we show later on, the database serves as a store of data and as an engine for sub-setting, joining, and computation on the data. We begin with getting data from the dbms, or “downloading” data. 8.1.1 Finding out what’s there We’ve already seen the simplest way of getting a list of tables in a database with DBI functions that list tables and fields. Generate a vector listing the (public) tables in the database: tables &lt;- DBI::dbListTables(con) tables ## [1] &quot;actor_info&quot; &quot;customer_list&quot; ## [3] &quot;film_list&quot; &quot;nicer_but_slower_film_list&quot; ## [5] &quot;sales_by_film_category&quot; &quot;staff&quot; ## [7] &quot;sales_by_store&quot; &quot;staff_list&quot; ## [9] &quot;category&quot; &quot;film_category&quot; ## [11] &quot;country&quot; &quot;actor&quot; ## [13] &quot;language&quot; &quot;inventory&quot; ## [15] &quot;payment&quot; &quot;rental&quot; ## [17] &quot;city&quot; &quot;store&quot; ## [19] &quot;film&quot; &quot;address&quot; ## [21] &quot;film_actor&quot; &quot;customer&quot; Print a vector with all the fields (or columns or variables) in one specific table: DBI::dbListFields(con, &quot;rental&quot;) ## [1] &quot;rental_id&quot; &quot;rental_date&quot; &quot;inventory_id&quot; &quot;customer_id&quot; ## [5] &quot;return_date&quot; &quot;staff_id&quot; &quot;last_update&quot; 8.1.2 Listing all the fields for all the tables The first example, DBI::dbListTables(con) returned 22 tables and the second example, DBI::dbListFields(con, &quot;rental&quot;) returns 7 fields. Here we combine the two calls to return a list of tables which has a list of all the fields in the table. The code block just shows the first two tables. Use the table_columns &lt;- lapply(tables, dbListFields, conn = con) #rename each list [[1]] ... [[22]] to meaningful table name names(table_columns) &lt;- tables head(table_columns) ## $actor_info ## [1] &quot;actor_id&quot; &quot;first_name&quot; &quot;last_name&quot; &quot;film_info&quot; ## ## $customer_list ## [1] &quot;id&quot; &quot;name&quot; &quot;address&quot; &quot;zip code&quot; &quot;phone&quot; &quot;city&quot; ## [7] &quot;country&quot; &quot;notes&quot; &quot;sid&quot; ## ## $film_list ## [1] &quot;fid&quot; &quot;title&quot; &quot;description&quot; &quot;category&quot; &quot;price&quot; ## [6] &quot;length&quot; &quot;rating&quot; &quot;actors&quot; ## ## $nicer_but_slower_film_list ## [1] &quot;fid&quot; &quot;title&quot; &quot;description&quot; &quot;category&quot; &quot;price&quot; ## [6] &quot;length&quot; &quot;rating&quot; &quot;actors&quot; ## ## $sales_by_film_category ## [1] &quot;category&quot; &quot;total_sales&quot; ## ## $staff ## [1] &quot;staff_id&quot; &quot;first_name&quot; &quot;last_name&quot; &quot;address_id&quot; &quot;email&quot; ## [6] &quot;store_id&quot; &quot;active&quot; &quot;username&quot; &quot;password&quot; &quot;last_update&quot; ## [11] &quot;picture&quot; Later on we’ll discuss how to get more extensive data about each table and column from the database’s own store of metadata using a similar technique. As we go further the issue of scale will come up again and again: you need to be careful about how much data a call to the dbms will return, whether it’s a list of tables or a table that could have millions of rows. 8.1.3 Downloading an entire table There are many different methods of getting data from a DBMS, and we’ll explore the different ways of controlling each one of them. DBI::dbReadTable will download an entire table into an R tibble. rental_tibble &lt;- DBI::dbReadTable(con, &quot;rental&quot;) str(rental_tibble) ## &#39;data.frame&#39;: 16044 obs. of 7 variables: ## $ rental_id : int 2 3 4 5 6 7 8 9 10 11 ... ## $ rental_date : POSIXct, format: &quot;2005-05-24 22:54:33&quot; &quot;2005-05-24 23:03:39&quot; ... ## $ inventory_id: int 1525 1711 2452 2079 2792 3995 2346 2580 1824 4443 ... ## $ customer_id : int 459 408 333 222 549 269 239 126 399 142 ... ## $ return_date : POSIXct, format: &quot;2005-05-28 19:40:33&quot; &quot;2005-06-01 22:12:39&quot; ... ## $ staff_id : int 1 1 2 1 1 2 2 1 2 2 ... ## $ last_update : POSIXct, format: &quot;2006-02-16 02:30:53&quot; &quot;2006-02-16 02:30:53&quot; ... That’s very simple, but if the table is large it may not be a good idea, since R is designed to keep the entire table in memory. Note that the first line of the str() output reports the total number of observations. 8.1.4 Referencing a table for many different purposes The dplyr::tbl function gives us more control over access to a table by enabling control over which columns and rows to download. It creates an object that might look like a data frame, but it’s actually a list object that dplyr uses for constructing queries and retrieving data from the DBMS. rental_table &lt;- dplyr::tbl(con, &quot;rental&quot;) Consider the structure of the connection object: str(rental_table) ## List of 2 ## $ src:List of 2 ## ..$ con :Formal class &#39;PqConnection&#39; [package &quot;RPostgres&quot;] with 3 slots ## .. .. ..@ ptr :&lt;externalptr&gt; ## .. .. ..@ bigint : chr &quot;integer64&quot; ## .. .. ..@ typnames:&#39;data.frame&#39;: 437 obs. of 2 variables: ## .. .. .. ..$ oid : int [1:437] 16 17 18 19 20 21 22 23 24 25 ... ## .. .. .. ..$ typname: chr [1:437] &quot;bool&quot; &quot;bytea&quot; &quot;char&quot; &quot;name&quot; ... ## ..$ disco: NULL ## ..- attr(*, &quot;class&quot;)= chr [1:3] &quot;src_dbi&quot; &quot;src_sql&quot; &quot;src&quot; ## $ ops:List of 2 ## ..$ x : &#39;ident&#39; chr &quot;rental&quot; ## ..$ vars: chr [1:7] &quot;rental_id&quot; &quot;rental_date&quot; &quot;inventory_id&quot; &quot;customer_id&quot; ... ## ..- attr(*, &quot;class&quot;)= chr [1:3] &quot;op_base_remote&quot; &quot;op_base&quot; &quot;op&quot; ## - attr(*, &quot;class&quot;)= chr [1:4] &quot;tbl_dbi&quot; &quot;tbl_sql&quot; &quot;tbl_lazy&quot; &quot;tbl&quot; Notice that the first list contains the source connection information. Among other things it contains a list of variables/columns in the table: rental_table$ops$vars ## [1] &quot;rental_id&quot; &quot;rental_date&quot; &quot;inventory_id&quot; &quot;customer_id&quot; ## [5] &quot;return_date&quot; &quot;staff_id&quot; &quot;last_update&quot; 8.1.5 Paradigm Shift: Lazy Execution R and dplyr is designed to be both lazy and smart. Lazy execution affects when a donwload happens and when processing occurs on the dbms server side. R retrieves the full data set when explicityly told to do so via the collect verb, otherwise it returns only 10 rows. And dplyr tries to get as much work done on the server side as possible before downloading anything. All of this is a key paradigm shift for those new to working with databases using R and dplyr, especially if they have been working in a straight SQL environment. In the code blocks below, we demonstrate three ways to check if dplyr has performed lazy/delayed execution. Display the object. nrow(object) Check the pipe. rental_table &lt;- dplyr::tbl(con, &quot;rental&quot;) rental_table ## # Source: table&lt;rental&gt; [?? x 7] ## # Database: postgres [postgres@localhost:5432/dvdrental] ## rental_id rental_date inventory_id customer_id ## &lt;int&gt; &lt;dttm&gt; &lt;int&gt; &lt;int&gt; ## 1 2 2005-05-24 22:54:33 1525 459 ## 2 3 2005-05-24 23:03:39 1711 408 ## 3 4 2005-05-24 23:04:41 2452 333 ## 4 5 2005-05-24 23:05:21 2079 222 ## 5 6 2005-05-24 23:08:07 2792 549 ## 6 7 2005-05-24 23:11:53 3995 269 ## 7 8 2005-05-24 23:31:46 2346 239 ## 8 9 2005-05-25 00:00:40 2580 126 ## 9 10 2005-05-25 00:02:21 1824 399 ## 10 11 2005-05-25 00:09:02 4443 142 ## # ... with more rows, and 3 more variables: return_date &lt;dttm&gt;, ## # staff_id &lt;int&gt;, last_update &lt;dttm&gt; head(rental_table, n = 25) ## # Source: lazy query [?? x 7] ## # Database: postgres [postgres@localhost:5432/dvdrental] ## rental_id rental_date inventory_id customer_id ## &lt;int&gt; &lt;dttm&gt; &lt;int&gt; &lt;int&gt; ## 1 2 2005-05-24 22:54:33 1525 459 ## 2 3 2005-05-24 23:03:39 1711 408 ## 3 4 2005-05-24 23:04:41 2452 333 ## 4 5 2005-05-24 23:05:21 2079 222 ## 5 6 2005-05-24 23:08:07 2792 549 ## 6 7 2005-05-24 23:11:53 3995 269 ## 7 8 2005-05-24 23:31:46 2346 239 ## 8 9 2005-05-25 00:00:40 2580 126 ## 9 10 2005-05-25 00:02:21 1824 399 ## 10 11 2005-05-25 00:09:02 4443 142 ## # ... with more rows, and 3 more variables: return_date &lt;dttm&gt;, ## # staff_id &lt;int&gt;, last_update &lt;dttm&gt; At the top of the output look for the dimensions, [?? x columns] or at the bottom for ‘… with more rows’ Notice that head should return 25 rows, but only shows the 10 rows it has can retrieve. nrow(rental_table) ## [1] NA The the rental_table is smart enough to returns NA when passed to nrow so no execution is performed. rental_table %&gt;% dplyr::summarise(n = n()) ## # Source: lazy query [?? x 1] ## # Database: postgres [postgres@localhost:5432/dvdrental] ## n ## &lt;S3: integer64&gt; ## 1 16044 rental_table %&gt;% dplyr::summarise(n = n()) %&gt;% show_query() ## &lt;SQL&gt; ## SELECT COUNT(*) AS &quot;n&quot; ## FROM &quot;rental&quot; The dplyr::summarise verb does not force R to download the whole table. It processes the whole table by counting all the rows on the dbms side and then downloads one number. Next we give an example where R gets busy and returns the full data set. rental_table &lt;- dplyr::tbl(con, &quot;rental&quot;) # Lazy collect_rental_table &lt;- rental_table %&gt;% collect() # Busy collect_rental_table ## # A tibble: 16,044 x 7 ## rental_id rental_date inventory_id customer_id ## &lt;int&gt; &lt;dttm&gt; &lt;int&gt; &lt;int&gt; ## 1 2 2005-05-24 22:54:33 1525 459 ## 2 3 2005-05-24 23:03:39 1711 408 ## 3 4 2005-05-24 23:04:41 2452 333 ## 4 5 2005-05-24 23:05:21 2079 222 ## 5 6 2005-05-24 23:08:07 2792 549 ## 6 7 2005-05-24 23:11:53 3995 269 ## 7 8 2005-05-24 23:31:46 2346 239 ## 8 9 2005-05-25 00:00:40 2580 126 ## 9 10 2005-05-25 00:02:21 1824 399 ## 10 11 2005-05-25 00:09:02 4443 142 ## # ... with 16,034 more rows, and 3 more variables: return_date &lt;dttm&gt;, ## # staff_id &lt;int&gt;, last_update &lt;dttm&gt; At the top of the output, # A tibble: 16,044 x 7 and at the bottom of the output, # ... with 16,034 more rows we see that dplyr::tbl returned all the rows associated with collect_rental_table. See Controlling number of rows returned for additional R examples showing R getting to work, and return some or all the rows. See more example of lazy execution can be found Here. 8.1.6 Controlling number of rows returned The collect function triggers the creation of a tibble and controls the number of rows that the DBMS sends to R. Note that in the following examples, the object dimensions are known. rental_table %&gt;% collect(n = 3) %&gt;% head ## # A tibble: 3 x 7 ## rental_id rental_date inventory_id customer_id ## &lt;int&gt; &lt;dttm&gt; &lt;int&gt; &lt;int&gt; ## 1 2 2005-05-24 22:54:33 1525 459 ## 2 3 2005-05-24 23:03:39 1711 408 ## 3 4 2005-05-24 23:04:41 2452 333 ## # ... with 3 more variables: return_date &lt;dttm&gt;, staff_id &lt;int&gt;, ## # last_update &lt;dttm&gt; In this case the collect function triggers the execution of a query that counts the number of records in the table by staff_id: rental_table %&gt;% count(staff_id) %&gt;% collect() ## # A tibble: 2 x 2 ## staff_id n ## &lt;int&gt; &lt;S3: integer64&gt; ## 1 1 8040 ## 2 2 8004 The collect function affects how much is downloaded, not how many rows the DBMS needs to process the query. This query processes all of the rows in the table but only displays one row of output. rental_table %&gt;% count(staff_id) %&gt;% collect(n = 1) ## # A tibble: 1 x 2 ## staff_id n ## &lt;int&gt; &lt;S3: integer64&gt; ## 1 1 8040 8.1.7 Random rows from the dbms When the dbms contains many rows, a sample of the data may be plenty for your purposes. Although dplyr has nice functions to sample a data frame that’s already in R (e.g., the sample_n and sample_frac functions), to get a sample from the dbms we have to use dbGetQuery to send native SQL to the database. To peak ahead, here is one example of a query that retrieves 20 rows from a 1% sample: one_percent_sample &lt;- DBI::dbGetQuery(con, &quot;SELECT rental_id, rental_date, inventory_id, customer_id FROM rental TABLESAMPLE SYSTEM(1) LIMIT 20; &quot;) one_percent_sample ## rental_id rental_date inventory_id customer_id ## 1 5033 2005-07-09 02:42:01 2841 299 ## 2 5034 2005-07-09 02:48:15 340 148 ## 3 5035 2005-07-09 02:51:34 3699 99 ## 4 5036 2005-07-09 02:58:41 75 573 ## 5 5037 2005-07-09 02:59:10 435 524 ## 6 5038 2005-07-09 03:12:52 3086 10 ## 7 5039 2005-07-09 03:14:45 2020 268 ## 8 5040 2005-07-09 03:16:34 2479 405 ## 9 5041 2005-07-09 03:18:51 2711 305 ## 10 5042 2005-07-09 03:20:30 3609 254 ## 11 5043 2005-07-09 03:25:18 2979 369 ## 12 5044 2005-07-09 03:30:25 1625 147 ## 13 5045 2005-07-09 03:33:32 1041 230 ## 14 5046 2005-07-09 03:34:57 1639 227 ## 15 5047 2005-07-09 03:44:15 230 272 ## 16 5048 2005-07-09 03:46:33 1271 466 ## 17 5049 2005-07-09 03:54:12 3336 144 ## 18 5050 2005-07-09 03:54:38 3876 337 ## 19 5051 2005-07-09 03:57:53 4091 85 ## 20 5052 2005-07-09 03:59:43 1884 305 8.1.8 Sub-setting variables A table in the dbms may not only have many more rows than you want and also many more columns. The select command controls which columns are retrieved. rental_table %&gt;% select(rental_date, return_date) %&gt;% head ## # Source: lazy query [?? x 2] ## # Database: postgres [postgres@localhost:5432/dvdrental] ## rental_date return_date ## &lt;dttm&gt; &lt;dttm&gt; ## 1 2005-05-24 22:54:33 2005-05-28 19:40:33 ## 2 2005-05-24 23:03:39 2005-06-01 22:12:39 ## 3 2005-05-24 23:04:41 2005-06-03 01:43:41 ## 4 2005-05-24 23:05:21 2005-06-02 04:33:21 ## 5 2005-05-24 23:08:07 2005-05-27 01:32:07 ## 6 2005-05-24 23:11:53 2005-05-29 20:34:53 We won’t discuss dplyr methods for sub-setting variables, deriving new ones, or sub-setting rows based on the values found in the table because they are covered well in other places, including: Comprehensive reference: https://dplyr.tidyverse.org/ Good tutorial: https://suzan.rbind.io/tags/dplyr/ In practice we find that, renaming variables is often quite important because the names in an SQL database might not meet your needs as an analyst. In “the wild” you will find names that are ambiguous or overly specified, with spaces in them, and other problems that will make them difficult to use in R. It is good practice to do whatever renaming you are going to do in a predictable place like at the top of your code. The names in the dvdrental database are simple and clear, but if they were not, you might rename them for subsequent use in this way: renamed_rental_table &lt;- dplyr::tbl(con, &quot;rental&quot;) %&gt;% rename(rental_id_number = rental_id, inventory_id_number = inventory_id) renamed_rental_table %&gt;% select(rental_id_number, rental_date, inventory_id_number) %&gt;% head() ## # Source: lazy query [?? x 3] ## # Database: postgres [postgres@localhost:5432/dvdrental] ## rental_id_number rental_date inventory_id_number ## &lt;int&gt; &lt;dttm&gt; &lt;int&gt; ## 1 2 2005-05-24 22:54:33 1525 ## 2 3 2005-05-24 23:03:39 1711 ## 3 4 2005-05-24 23:04:41 2452 ## 4 5 2005-05-24 23:05:21 2079 ## 5 6 2005-05-24 23:08:07 2792 ## 6 7 2005-05-24 23:11:53 3995 8.1.9 Examining dplyr’s SQL query and re-using SQL code The show_query function shows how dplyr is translating your query to the dialect of the target dbms: rental_table %&gt;% count(staff_id) %&gt;% show_query() ## &lt;SQL&gt; ## SELECT &quot;staff_id&quot;, COUNT(*) AS &quot;n&quot; ## FROM &quot;rental&quot; ## GROUP BY &quot;staff_id&quot; Here is an extensive discussion of how dplyr code is translated into SQL: https://dbplyr.tidyverse.org/articles/sql-translation.html The SQL code can submit the same query directly to the DBMS with the DBI::dbGetQuery function: DBI::dbGetQuery(con, &#39;SELECT &quot;staff_id&quot;, COUNT(*) AS &quot;n&quot; FROM &quot;rental&quot; GROUP BY &quot;staff_id&quot;; &#39;) ## staff_id n ## 1 1 8040 ## 2 2 8004 &lt;&lt;smy We haven’t investigated this, but it looks like dplyr collect() function triggers a call simmilar to the dbGetQuery call above. The default dplyr behavior looks like dbSendQuery() and dbFetch() model is used.&gt;&gt; When you create a report to run repeatedly, you might want to put that query into R markdown. That way you can also execute that SQL code in a chunk with the following header: {sql, connection=con, output.var = &quot;query_results&quot;} SELECT &quot;staff_id&quot;, COUNT(*) AS &quot;n&quot; FROM &quot;rental&quot; GROUP BY &quot;staff_id&quot;; Rmarkdown stored that query result in a tibble: query_results ## staff_id n ## 1 1 8040 ## 2 2 8004 8.2 Investigating a single table with R Dealing with a large, complex database highlights the utility of specific tools in R. We include brief examples that we find to be handy: Base R structure: str printing out some of the data: datatable, kable, and View summary statistics: summary glimpse oin the tibble package, which is included in the tidyverse skim in the skimr package 8.2.1 str - a base package workhorse str is a workhorse function that lists variables, their type and a sample of the first few variable values. str(rental_tibble) ## &#39;data.frame&#39;: 16044 obs. of 7 variables: ## $ rental_id : int 2 3 4 5 6 7 8 9 10 11 ... ## $ rental_date : POSIXct, format: &quot;2005-05-24 22:54:33&quot; &quot;2005-05-24 23:03:39&quot; ... ## $ inventory_id: int 1525 1711 2452 2079 2792 3995 2346 2580 1824 4443 ... ## $ customer_id : int 459 408 333 222 549 269 239 126 399 142 ... ## $ return_date : POSIXct, format: &quot;2005-05-28 19:40:33&quot; &quot;2005-06-01 22:12:39&quot; ... ## $ staff_id : int 1 1 2 1 1 2 2 1 2 2 ... ## $ last_update : POSIXct, format: &quot;2006-02-16 02:30:53&quot; &quot;2006-02-16 02:30:53&quot; ... 8.2.2 Always just look at your data with head, View, or kable There is no substitute for looking at your data and R provides several ways to just browse it. The head function controls the number of rows that are displayed. Note that tail does not work against a database object. In every-day practice you would look at more than the default 6 rows, but here we wrap head around the data frame: sp_print_df(head(rental_tibble)) 8.2.3 The summary function in base The basic statistics that the base package summary provides can serve a unique diagnostic purpose in this context. For example, the following output shows that rental_id is a sequential number from 1 to 16,049 with no gaps. The same is true of inventory_id. The number of NA’s is a good first guess as to the number of dvd’s rented out or lost on 2005-09-02 02:35:22. summary(rental_tibble) ## rental_id rental_date inventory_id ## Min. : 1 Min. :2005-05-24 22:53:30 Min. : 1 ## 1st Qu.: 4014 1st Qu.:2005-07-07 00:58:40 1st Qu.:1154 ## Median : 8026 Median :2005-07-28 16:04:32 Median :2291 ## Mean : 8025 Mean :2005-07-23 08:13:34 Mean :2292 ## 3rd Qu.:12037 3rd Qu.:2005-08-17 21:16:23 3rd Qu.:3433 ## Max. :16049 Max. :2006-02-14 15:16:03 Max. :4581 ## ## customer_id return_date staff_id ## Min. : 1.0 Min. :2005-05-25 23:55:21 Min. :1.000 ## 1st Qu.:148.0 1st Qu.:2005-07-10 15:49:36 1st Qu.:1.000 ## Median :296.0 Median :2005-08-01 19:45:29 Median :1.000 ## Mean :297.1 Mean :2005-07-25 23:58:03 Mean :1.499 ## 3rd Qu.:446.0 3rd Qu.:2005-08-20 23:35:55 3rd Qu.:2.000 ## Max. :599.0 Max. :2005-09-02 02:35:22 Max. :2.000 ## NA&#39;s :183 ## last_update ## Min. :2006-02-15 21:30:53 ## 1st Qu.:2006-02-16 02:30:53 ## Median :2006-02-16 02:30:53 ## Mean :2006-02-16 02:31:31 ## 3rd Qu.:2006-02-16 02:30:53 ## Max. :2006-02-23 09:12:08 ## 8.2.4 The glimpse function in the tibble package The tibble package’s glimpse function is a more compact version of str: tibble::glimpse(rental_tibble) ## Observations: 16,044 ## Variables: 7 ## $ rental_id &lt;int&gt; 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 1... ## $ rental_date &lt;dttm&gt; 2005-05-24 22:54:33, 2005-05-24 23:03:39, 2005-0... ## $ inventory_id &lt;int&gt; 1525, 1711, 2452, 2079, 2792, 3995, 2346, 2580, 1... ## $ customer_id &lt;int&gt; 459, 408, 333, 222, 549, 269, 239, 126, 399, 142,... ## $ return_date &lt;dttm&gt; 2005-05-28 19:40:33, 2005-06-01 22:12:39, 2005-0... ## $ staff_id &lt;int&gt; 1, 1, 2, 1, 1, 2, 2, 1, 2, 2, 2, 1, 1, 1, 2, 1, 2... ## $ last_update &lt;dttm&gt; 2006-02-16 02:30:53, 2006-02-16 02:30:53, 2006-0... 8.2.5 The skim function in the skimr package The skimr package has several functions that make it easy to examine an unknown data frame and assess what it contains. It is also extensible. library(skimr) ## ## Attaching package: &#39;skimr&#39; ## The following object is masked from &#39;package:knitr&#39;: ## ## kable skim(rental_tibble) ## Skim summary statistics ## n obs: 16044 ## n variables: 7 ## ## ── Variable type:integer ──────────────────────────────────────────────────────────────────────────────────────────────────────────────── ## variable missing complete n mean sd p0 p25 p50 ## customer_id 0 16044 16044 297.14 172.45 1 148 296 ## inventory_id 0 16044 16044 2291.84 1322.21 1 1154 2291 ## rental_id 0 16044 16044 8025.37 4632.78 1 4013.75 8025.5 ## staff_id 0 16044 16044 1.5 0.5 1 1 1 ## p75 p100 hist ## 446 599 ▇▇▇▇▇▇▇▇ ## 3433 4581 ▇▇▇▇▇▇▇▇ ## 12037.25 16049 ▇▇▇▇▇▇▇▇ ## 2 2 ▇▁▁▁▁▁▁▇ ## ## ── Variable type:POSIXct ──────────────────────────────────────────────────────────────────────────────────────────────────────────────── ## variable missing complete n min max median ## last_update 0 16044 16044 2006-02-15 2006-02-23 2006-02-16 ## rental_date 0 16044 16044 2005-05-24 2006-02-14 2005-07-28 ## return_date 183 15861 16044 2005-05-25 2005-09-02 2005-08-01 ## n_unique ## 3 ## 15815 ## 15836 wide_rental_skim &lt;- skim_to_wide(rental_tibble) 8.3 Dividing the work between R on your machine and the DBMS They work together. 8.3.1 Make the server do as much work as you can show_query as a first draft of SQL. May or may not use SQL code submitted directly. 8.3.2 Criteria for choosing between dplyr and native SQL This probably belongs later in the book. performance considerations: first get the right data, then worry about performance Trade offs between leaving the data in PostgreSQL vs what’s kept in R: browsing the data larger samples and complete tables using what you know to write efficient queries that do most of the work on the server 8.3.3 dplyr tools Where you place the collect function matters. dbDisconnect(con) sp_docker_stop(&quot;sql-pet&quot;) ## [1] &quot;sql-pet&quot; 8.4 DBI Package In this chapter we touched on a number of functions from the DBI Package. The table below shows other functions in the package. The Chapter column references a section in the book if we have used it. DBI Chapter Call Example/Notes DBIConnection-class dbAppendTable dbCreateTable dbDisconnect Every Chapter dbExecute 10.4.2 Executes a statement and returns the number of rows affected. dbExecute() comes with a default implementation (which should work with most backends) that calls dbSendStatement(), then dbGetRowsAffected(), ensuring that the result is always free-d by dbClearResult(). dbExistsTable dbExistsTable(con,‘actor’) dbFetch 17.1 dbFecth(rs) dbGetException dbGetInfo dbGetInfo(con) dbGetQuery 10.4.1 dbGetQuery(con,‘select * from store;’) dbIsReadOnly dbIsReadOnly(con) dbIsValid dbIsValid(con) dbListFields 8.1.1 DBI::dbListFields(con, “rental”) dbListObjects dbListObjects(con) dbListResults deprecated dbListTables 8.1.1 DBI::dbListTables(con, “rental”) dbReadTable 8.1.2 DBI::dbReadTable(con, “rental”) dbRemoveTable dbSendQuery 17.1 rs &lt;- dbSendQuery(con, “SELECT * FROM mtcars WHERE cyl = 4”) dbSendStatement The dbSendStatement() method only submits and synchronously executes the SQL data manipulation statement (e.g., UPDATE, DELETE, INSERT INTO, DROP TABLE, …) to the database engine. dbWriteTable 17.1 dbWriteTable(con, “mtcars”, mtcars, overwrite = TRUE) 8.5 Other resources Benjamin S. Baumer, A Grammar for Reproducible and Painless Extract-Transform-Load Operations on Medium Data: https://arxiv.org/pdf/1708.07073 "]
]
