[
["chapter-sql-joins-exercises-answered.html", "Chapter 17 SQL Joins exercises 17.1 Exercise Instructions 17.2 Dplyr tables 17.3 Oveview Exercise 17.4 1. How many rows are in each table? 17.5 Exercises 17.6 Different strategies for interacting with the database", " Chapter 17 SQL Joins exercises This chapter contains questions one may be curious about or asked about the DVD Rental business. The goal of the exercises is extracting useful or questionable insights from one or more tables. Each exercise has has some or all of the following parts. The question. The tables used to answer the question. A hidden SQL code block showing the desired output. Click the code button to see the SQL code. A table of derived values or renamed columns shown in the SQL block to facilitate replicating the desired dplyr solution. Abbreviated column names are used to squeeze in more columns into the answer to reduce scrolling across the screen. A replication section where you recreate the desired output using dplyr syntax. Most columns come directly out of the tables. Each replication code block has three commented function calls sp_tbl_descr(‘store’) –describes a table, store sp_tbl_pk_fk(‘table_name’) –shows a table’s primary and foreign keys sp_print_df(table_rows_sql) –shows table row counts. To keep the exercises concentrated on the joins, all derived dates drop their timestamp. SQL syntax: date_column::DATE Dplyr syntax: as.date(date_colun) 17.1 Exercise Instructions Manually execute all the code blocks up-to the “SQL Union Exercise.” Most of the exercises can be performed in any order. There are function exercises that create a function followed by another code block to call the function in the previous exercise. Use the Show Document Outline, CTL-Shift-O, to navigate to the different exercises. Verify Docker is up and running: sp_check_that_docker_is_up() ## [1] &quot;Docker is up but running no containers&quot; Verify pet DB is available, it may be stopped. sp_show_all_docker_containers() ## CONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES ## 40d1461e33af postgres-dvdrental &quot;docker-entrypoint.s…&quot; 16 minutes ago Exited (0) About a minute ago sql-pet Start up the docker-pet container sp_docker_start(&quot;sql-pet&quot;) Now connect to the database with R # need to wait for Docker &amp; Postgres to come up before connecting. con &lt;- sp_get_postgres_connection( user = Sys.getenv(&quot;DEFAULT_POSTGRES_USER_NAME&quot;), password = Sys.getenv(&quot;DEFAULT_POSTGRES_PASSWORD&quot;), dbname = &quot;dvdrental&quot;, seconds_to_test = 30 ) 17.2 Dplyr tables All the tables defined in the DVD Rental System will fit into memory which is rarely the case when working with a database. Each table is loaded into an R object named TableName_table, via a DBI::dbReadTable call. actor_table &lt;- DBI::dbReadTable(con,“actor”) source(here(&#39;book-src&#39;,&#39;dvdrental-table-declarations.R&#39;), echo = TRUE) ## ## &gt; actor_table &lt;- tbl(con, &quot;actor&quot;) ## ## &gt; address_table &lt;- tbl(con, &quot;address&quot;) ## ## &gt; category_table &lt;- tbl(con, &quot;category&quot;) ## ## &gt; city_table &lt;- tbl(con, &quot;city&quot;) ## ## &gt; country_table &lt;- tbl(con, &quot;country&quot;) ## ## &gt; customer_table &lt;- tbl(con, &quot;customer&quot;) ## ## &gt; film_table &lt;- tbl(con, &quot;film&quot;) ## ## &gt; film_actor_table &lt;- tbl(con, &quot;film_actor&quot;) ## ## &gt; film_category_table &lt;- tbl(con, &quot;film_category&quot;) ## ## &gt; inventory_table &lt;- tbl(con, &quot;inventory&quot;) ## ## &gt; language_table &lt;- tbl(con, &quot;language&quot;) ## ## &gt; rental_table &lt;- tbl(con, &quot;rental&quot;) ## ## &gt; payment_table &lt;- tbl(con, &quot;payment&quot;) ## ## &gt; staff_table &lt;- tbl(con, &quot;staff&quot;) ## ## &gt; store_table &lt;- tbl(con, &quot;store&quot;) The following code block deletes and inserts records into the different tables used in the exercises in this chpater. The techniques used in this code block are discussed in detail in the appendix, ??add link here.?? source(file=here::here(&#39;book-src&#39;,&#39;sql_pet_data.R&#39;),echo=TRUE) ## ## &gt; dbExecute(con, &quot;delete from film_category where film_id &gt;= 1001;&quot;) ## [1] 2 ## ## &gt; dbExecute(con, &quot;delete from rental where rental_id &gt;= 16050;&quot;) ## [1] 1 ## ## &gt; dbExecute(con, &quot;delete from inventory where film_id &gt;= 1001;&quot;) ## [1] 2 ## ## &gt; dbExecute(con, &quot;delete from film where film_id &gt;= 1001;&quot;) ## [1] 1 ## ## &gt; dbExecute(con, &quot;delete from customer where customer_id &gt;= 600;&quot;) ## [1] 5 ## ## &gt; dbExecute(con, &quot;delete from store where store_id &gt; 2;&quot;) ## [1] 1 ## ## &gt; dbExecute(con, &quot;insert into customer\\n (customer_id,store_id,first_name,last_name,email,address_id,activebool\\n ,create_date,last_update,active)\\n ...&quot; ... [TRUNCATED] ## [1] 5 ## ## &gt; dbExecute(con, &quot;ALTER TABLE store DISABLE TRIGGER ALL;&quot;) ## [1] 0 ## ## &gt; df &lt;- data.frame(store_id = 10, manager_staff_id = 10, ## + address_id = 10, last_update = Sys.time()) ## ## &gt; dbWriteTable(con, &quot;store&quot;, value = df, append = TRUE, ## + row.names = FALSE) ## ## &gt; dbExecute(con, &quot;ALTER TABLE store ENABLE TRIGGER ALL;&quot;) ## [1] 0 ## ## &gt; dbExecute(con, &quot;insert into film\\n (film_id,title,description,release_year,language_id\\n ,rental_duration,rental_rate,length,replacement_cost,rati ...&quot; ... [TRUNCATED] ## [1] 1 ## ## &gt; dbExecute(con, &quot;insert into film_category\\n (film_id,category_id,last_update)\\n values(1001,6,now()::date)\\n ,(1001,7,now()::date)\\n ;&quot;) ## [1] 2 ## ## &gt; dbExecute(con, &quot;insert into inventory\\n (inventory_id,film_id,store_id,last_update)\\n values(4582,1001,1,now()::date)\\n ,(4583,1001,2,now()::date ...&quot; ... [TRUNCATED] ## [1] 2 ## ## &gt; dbExecute(con, &quot;insert into rental\\n (rental_id,rental_date,inventory_id,customer_id,return_date,staff_id,last_update)\\n values(16050,now()::date ...&quot; ... [TRUNCATED] ## [1] 1 17.3 Oveview Exercise When joining many tables, it is helpful to have the number of rows from each table as an initial sanity check that the joins are returning a reasonable number of rows. 17.4 1. How many rows are in each table? table_rows_sql &lt;- dbGetQuery( con, &quot;select * from ( select &#39;actor&#39; tbl_name,count(*) from actor union select &#39;category&#39; tbl_name,count(*) from category union select &#39;film&#39; tbl_name,count(*) from film union select &#39;film_actor&#39; tbl_name,count(*) from film_actor union select &#39;film_category&#39; tbl_name,count(*) from film_category union select &#39;language&#39; tbl_name,count(*) from language union select &#39;inventory&#39; tbl_name,count(*) from inventory union select &#39;rental&#39; tbl_name,count(*) from rental union select &#39;payment&#39; tbl_name,count(*) from payment union select &#39;staff&#39; tbl_name,count(*) from staff union select &#39;customer&#39; tbl_name,count(*) from customer union select &#39;address&#39; tbl_name,count(*) from address union select &#39;city&#39; tbl_name,count(*) from city union select &#39;country&#39; tbl_name,count(*) from country union select &#39;store&#39; tbl_name,count(*) from store ) counts order by tbl_name ; &quot; ) sp_print_df(table_rows_sql) 17.4.0.1 Replicate the output above using dplyr syntax. # sp_tbl_descr(&#39;table_name&#39;) # sp_tbl_pk_fk(&#39;table_name&#39;) # sp_print_df(table_rows_sql) table_rows_dplyr &lt;- as.data.frame(actor_table %&gt;% mutate(name = &quot;actor&quot;) %&gt;% group_by(name) %&gt;% summarize(rows = n())) %&gt;% union(as.data.frame(address_table %&gt;% mutate(name = &quot;address&quot;) %&gt;% group_by(name) %&gt;% summarize(rows = n()))) %&gt;% union (as.data.frame(category_table %&gt;% mutate(name = &quot;category&quot;) %&gt;% group_by(name) %&gt;% summarize(rows = n()))) %&gt;% union(as.data.frame(country_table %&gt;% mutate(name = &quot;city&quot;) %&gt;% group_by(name) %&gt;% summarize(rows = n()))) %&gt;% union(as.data.frame(country_table %&gt;% mutate(name = &quot;country&quot;) %&gt;% group_by(name) %&gt;% summarize(rows = n()))) %&gt;% union(as.data.frame(customer_table %&gt;% mutate(name = &quot;customer&quot;) %&gt;% group_by(name) %&gt;% summarize(rows = n()))) %&gt;% union(as.data.frame(film_table %&gt;% mutate(name = &quot;film&quot;) %&gt;% group_by(name) %&gt;% summarize(rows = n()))) %&gt;% union(as.data.frame(film_actor_table %&gt;% mutate(name = &quot;film_actor&quot;) %&gt;% group_by(name) %&gt;% summarize(rows = n()))) %&gt;% union(as.data.frame(film_category_table %&gt;% mutate(name = &quot;film_category&quot;) %&gt;% group_by(name) %&gt;% summarize(rows = n()))) %&gt;% union(as.data.frame(inventory_table %&gt;% mutate(name = &quot;inventory&quot;) %&gt;% group_by(name) %&gt;% summarize(rows = n()))) %&gt;% union(as.data.frame(language_table %&gt;% mutate(name = &quot;language&quot;) %&gt;% group_by(name) %&gt;% summarize(rows = n()))) %&gt;% union(as.data.frame(rental_table %&gt;% mutate(name = &quot;rental&quot;) %&gt;% group_by(name) %&gt;% summarize(rows = n()))) %&gt;% union(as.data.frame(payment_table %&gt;% mutate(name = &quot;payment&quot;) %&gt;% group_by(name) %&gt;% summarize(rows = n()))) %&gt;% union(as.data.frame(staff_table %&gt;% mutate(name = &quot;staff&quot;) %&gt;% group_by(name) %&gt;% summarize(rows = n()))) %&gt;% union(as.data.frame(store_table %&gt;% mutate(name = &quot;store&quot;) %&gt;% group_by(name) %&gt;% summarize(rows = n()))) %&gt;% arrange(name) sp_print_df(table_rows_dplyr) 17.5 Exercises 17.5.1 1. Where is the DVD Rental Business located? To answer this question we look at the store, address, city, and country tables to answer this question. store_locations_sql &lt;- dbGetQuery(con, &quot;select s.store_id ,a.address ,c.city ,a.district ,a.postal_code ,c2.country ,s.last_update from store s join address a on s.address_id = a.address_id join city c on a.city_id = c.city_id join country c2 on c.country_id = c2.country_id &quot;) sp_print_df(store_locations_sql) Our DVD Rental business is international and operates in three countries, Canada, Austraila, and the United States. Each country has one store. 17.5.1.1 Replicate the output above using dplyr syntax. # sp_tbl_descr(&#39;table_name&#39;) # sp_tbl_pk_fk(&#39;table_name&#39;) # sp_print_df(table_rows_sql) store_locations_dplyr &lt;- store_table %&gt;% inner_join(address_table, by = c(&quot;address_id&quot; = &quot;address_id&quot;), suffix(c(&quot;.s&quot;, &quot;.a&quot;))) %&gt;% inner_join(city_table, by = c(&quot;city_id&quot; = &quot;city_id&quot;), suffix(c(&quot;.a&quot;, &quot;.c&quot;))) %&gt;% inner_join(country_table, by = c(&quot;country_id&quot; = &quot;country_id&quot;), suffix(c(&quot;.a&quot;, &quot;.c&quot;))) %&gt;% select (store_id,address,city,district,postal_code,country,last_update.x) %&gt;% collect() sp_print_df(store_locations_dplyr) 17.5.2 2. List Each Store and the Staff Contact Information? To answer this question we look at the store, staff, address, city, and country tables. store_employees_sql &lt;- dbGetQuery(con, &quot;select st.store_id ,s.first_name ,s.last_name ,s.email ,a.phone ,a.address ,c.city ,a.district ,a.postal_code ,c2.country from store st left join staff s on st.manager_staff_id = s.staff_id left join address a on s.address_id = a.address_id left join city c on a.city_id = c.city_id left join country c2 on c.country_id = c2.country_id &quot;) sp_print_df(store_employees_sql) Our DVD Rental business is international and operates in three countries, Canada, Austraila, and the United States. Each country has one store. The stores in Canada and Austrailia have one employee each, Mike Hillyer and Jon Stephens respectively. The store in the United States has no employees yet. 17.5.2.1 Replicate the output above using dplyr syntax. # sp_tbl_descr(&#39;table_name&#39;) # sp_tbl_pk_fk(&#39;table_name&#39;) # sp_print_df(table_rows_sql) store_employees_dplyr &lt;- store_table %&gt;% left_join (staff_table, by = c(&quot;manager_staff_id&quot; = &quot;staff_id&quot;),suffix(c(&#39;sto&#39;,&#39;sta&#39;))) %&gt;% left_join(address_table, by = c(&quot;address_id.y&quot; = &quot;address_id&quot;), suffix(c(&quot;.sta&quot;, &quot;.a&quot;))) %&gt;% left_join(city_table, by = c(&quot;city_id&quot; = &quot;city_id&quot;), suffix(c(&quot;.sta&quot;, &quot;.city&quot;))) %&gt;% left_join(country_table, by = c(&quot;country_id&quot; = &quot;country_id&quot;), suffix(c(&quot;.city&quot;, &quot;.cnt&quot;))) %&gt;% select(store_id.x,first_name,last_name,email,phone,address,city,district,postal_code,country) %&gt;% collect() sp_print_df(store_employees_dplyr) 17.5.3 3. How Many Active, Inactive, and Total Customers Does the DVD Rental Business Have? To answer this question we look at the customer table. In a previous chapter we observed that there are two columns, activebool and active. We consider active = 1 as active. customer_cnt_sql &lt;- dbGetQuery(con, &quot;SELECT sum(case when active = 1 then 1 else 0 end) active ,sum(case when active = 0 then 1 else 0 end) inactive ,count(*) total from customer &quot;) sp_print_df(customer_cnt_sql) Our DVD Rental business is international and operates in three countries, Canada, Austraila, and the United States. Each country has one store. The stores in Canada and Austrailia have one employee each. The store in the United States has no employees yet. The business has 604 international customers, 589 are active and 15 inactive. 17.5.3.1 Replicate the output above using dplyr syntax. customer_cnt_dplyr &lt;- customer_table %&gt;% mutate(inactive = ifelse(active==0,1,0)) %&gt;% summarize(active = sum(active) ,inactive = sum(inactive) ,total = n() ) %&gt;% collect() ## Warning: Missing values are always removed in SQL. ## Use `SUM(x, na.rm = TRUE)` to silence this warning ## Warning: Missing values are always removed in SQL. ## Use `SUM(x, na.rm = TRUE)` to silence this warning sp_print_df(customer_cnt_dplyr) 17.5.4 4. How Many and What Percent of Customers Are From Each Country? To answer this question we look at the customer, address, city, and country tables. customers_sql &lt;- dbGetQuery(con, &quot;select c.active,country.country,count(*) count ,round(100 * count(*) / sum(count(*)) over(),4) as pct from customer c join address a on c.address_id = a.address_id join city on a.city_id = city.city_id join country on city.country_id = country.country_id group by c.active,country order by count(*) desc &quot;) sp_print_df(customers_sql) Based on the table above, the DVD Rental business has customers in 118 countries. The DVD Rental business cannot have many walk in customers. It may possibly use a mail order distribution model. For an international company, how are the different currencies converted to a standard currency? Looking at the ERD, there is no currency conversion rate. 17.5.4.1 Replicate the output above using dplyr syntax. # sp_tbl_descr(&#39;table_name&#39;) # sp_tbl_pk_fk(&#39;table_name&#39;) # sp_print_df(table_rows_sql) # customers_dplyr &lt;- customer_table %&gt;% # inner_join(address_table, by = c(&quot;address_id&quot; = &quot;address_id&quot;), suffix(c(&quot;.s&quot;, &quot;.a&quot;))) %&gt;% # inner_join(city_table, by = c(&quot;city_id&quot; = &quot;city_id&quot;), suffix(c(&quot;.a&quot;, &quot;.c&quot;))) %&gt;% # inner_join(country_table, by = c(&quot;country_id&quot; = &quot;country_id&quot;), suffix(c(&quot;.a&quot;, &quot;.c&quot;))) %&gt;% # group_by(active,country) %&gt;% # summarize(count=n()) %&gt;% # mutate(total=nrow(customer_table) # ,pct=round(100 * count/total,4) # ) %&gt;% # arrange(desc(count)) %&gt;% # select (active,country,count,pct) # # sp_print_df(customers_dplyr) 17.5.5 5 What Countries Constitute the Top 25% of the Customer Base? Using the previous code, add two new columns. One column shows a running total and the second column shows a running percentage. Order the data by count then by country. To answer this question we look at the customer, address, city, and country tables again. country_sql &lt;- dbGetQuery(con, &quot;select active,country,count ,sum(count) over (order by count desc,country rows between unbounded preceding and current row) running_total , pct ,sum(pct) over (order by pct desc,country rows between unbounded preceding and current row) running_pct from (-- Start of inner SQL Block select c.active,country.country,count(*) count ,round(100 * count(*) / sum(count(*)) over(),4) as pct from customer c join address a on c.address_id = a.address_id join city on a.city_id = city.city_id join country on city.country_id = country.country_id group by c.active,country ) ctry -- End of inner SQL Block order by count desc,country &quot;) sp_print_df(country_sql) The top 25% of the customer base are from India, China, the United States, and Japan. The next six countries, the top 10, Mexico, Brazil, Russian Federation, Philipines, Indonesia, and Turkey round out the top 50% of the businesses customer base. 17.5.5.1 Replicate the output above using dplyr syntax. ?? # sp_tbl_descr(&#39;table_name&#39;) # sp_tbl_pk_fk(&#39;table_name&#39;) # sp_print_df(table_rows_sql) # country_dplyr &lt;- customer_table %&gt;% # inner_join(address_table, by = c(&quot;address_id&quot; = &quot;address_id&quot;), suffix(c(&quot;.s&quot;, &quot;.a&quot;))) %&gt;% # inner_join(city_table, by = c(&quot;city_id&quot; = &quot;city_id&quot;), suffix(c(&quot;.a&quot;, &quot;.c&quot;))) %&gt;% # inner_join(country_table, by = c(&quot;country_id&quot; = &quot;country_id&quot;), suffix(c(&quot;.a&quot;, &quot;.c&quot;))) %&gt;% # group_by(active,country) %&gt;% # summarize(count=n()) %&gt;% # mutate(total=nrow(customer_table) # ,pct=round(100 * count/total,4) # ,csp=1 # ) %&gt;% # arrange(desc(count)) %&gt;% # # group_by(csp) %&gt;% # # mutate(running_pct=cumsum(pct) # ,running_total=cumsum(count)) %&gt;% # select (csp,active,country,count,running_total,pct,running_pct) # # sp_print_df(country_dplyr) 17.5.6 6. How many customers are in Australia and Canada? To answer this question we use the results from the previous exercise. country_au_ca_sql &lt;- country_sql %&gt;% filter(country == &#39;Australia&#39; | country == &#39;Canada&#39;) sp_print_df(country_au_ca_sql) There are 10 customers in Austrailia and Canada where the brick and mortar stores are located. The 20 customers are less than 2% of the world wide customer base. 17.5.6.1 Replicate the output above using dplyr syntax. # sp_tbl_descr(&#39;table_name&#39;) # sp_tbl_pk_fk(&#39;table_name&#39;) # sp_print_df(table_rows_sql) # country_au_ca_dplyr &lt;- country_dplyr %&gt;% filter(country == &#39;Australia&#39; | country == &#39;Canada&#39;) # sp_print_df(country_au_ca_dplyr) 17.5.7 7. How Many Languages? With an international customer base, how many languages does the DVD Rental business distribute DVD’s in. To answer this question we look at the language table. languages_sql &lt;- dbGetQuery(con, &quot; select * from language &quot;) sp_print_df(languages_sql) DVD’s are distributed in six languages. 17.5.7.1 Replicate the output above using dplyr syntax. # sp_tbl_descr(&#39;table_name&#39;) # sp_tbl_pk_fk(&#39;table_name&#39;) # sp_print_df(table_rows_sql) languages_dplyr &lt;- language_table %&gt;% collect() sp_print_df(languages_dplyr) 17.5.8 8. What is the distribution of DVD’s by Language To answer this question we look at the language and film tables. language_distribution_sql &lt;- dbGetQuery(con, &#39; select l.language_id,name &quot;language&quot;,count(f.film_id) from language l left join film f on l.language_id = f.language_id group by l.language_id,name order by l.language_id &#39;) sp_print_df(language_distribution_sql) This is a surprise. For an international customer base, the entire stock of 1001 DVD’s are in English only. 17.5.8.1 Replicate the output above using dplyr syntax. # sp_tbl_descr(&#39;table_name&#39;) # sp_tbl_pk_fk(&#39;table_name&#39;) # sp_print_df(table_rows_sql) language_distribution_dplyr &lt;- language_table %&gt;% left_join(film_table, by = c(&quot;language_id&quot; = &quot;language_id&quot;), suffix(c(&quot;.s&quot;, &quot;.a&quot;))) %&gt;% group_by(language_id,name) %&gt;% summarize(count = sum(ifelse(!is.na(title),1,0)),na.rm=TRUE) %&gt;% collect() ## Warning: Missing values are always removed in SQL. ## Use `SUM(x, na.rm = TRUE)` to silence this warning sp_print_df(language_distribution_dplyr) 17.5.9 9. What are the number of rentals and rented amount by store, by month? To answer this question we look at the rental, inventory, and film tables to answer this question. store_rentals_by_mth_sql &lt;- dbGetQuery(con, &quot;select * ,sum(rental_amt) over (order by yyyy_mm,store_id rows between unbounded preceding and current row) running_rental_amt from (select yyyy_mm,store_id,rentals,rental_amt ,sum(rentals) over(partition by yyyy_mm order by store_id) mo_rentals ,sum(rental_amt) over (partition by yyyy_mm order by store_id) mo_rental_amt from (select to_char(rental_date,&#39;yyyy-mm&#39;) yyyy_mm ,i.store_id,count(*) rentals, sum(f.rental_rate) rental_amt from rental r join inventory i on r.inventory_id = i.inventory_id join film f on i.film_id = f.film_id group by to_char(rental_date,&#39;yyyy-mm&#39;),i.store_id ) as details ) as mo_running order by yyyy_mm,store_id &quot;) sp_print_df(store_rentals_by_mth_sql) The current entry, row 11, is our new rental row we added to show the different joins in a previous chapter. 17.5.9.1 Replicate the output above using dplyr syntax. # sp_tbl_descr(&#39;table_name&#39;) # sp_tbl_pk_fk(&#39;table_name&#39;) # sp_print_df(table_rows_sql) store_rentals_by_mth_dplyr &lt;- rental_table %&gt;% inner_join(inventory_table, by = c(&quot;inventory_id&quot; = &quot;inventory_id&quot;), suffix(c(&quot;.r&quot;, &quot;.i&quot;))) %&gt;% inner_join(film_table, by = c(&quot;film_id&quot; = &quot;film_id&quot;), suffix(c(&quot;.i&quot;, &quot;.f&quot;))) %&gt;% collect() %&gt;% # format functions not allowed in dbplyr code! mutate(YYYY_MM = format(rental_date,&quot;%Y-%m&quot;) ,running_total = &#39;running_total&#39; ) %&gt;% group_by(running_total,YYYY_MM,store_id) %&gt;% summarise(rentals = n() ,rental_amt = sum(rental_rate) ) %&gt;% mutate(mo_rentals=order_by(store_id,cumsum(rentals)) ,mo_rental_amt=order_by(store_id,cumsum(rental_amt)) ) %&gt;% group_by(running_total) %&gt;% mutate(running_rental_amt = cumsum(rental_amt)) %&gt;% select(-running_total) ## Adding missing grouping variables: `running_total` sp_print_df(head(store_rentals_by_mth_dplyr, n=25)) 17.5.10 10. Rank Films Based on the Number of Times Rented and Associated Revenue To answer this question we look at the rental, inventory, and film tables. film_rank_sql &lt;- dbGetQuery(con, &quot;select f.film_id,f.title,f.rental_rate,count(*) count,f.rental_rate * count(*) rental_amt from rental r join inventory i on r.inventory_id = i.inventory_id join film f on i.film_id = f.film_id group by f.film_id,f.title,f.rental_rate order by count(*) desc&quot;) sp_print_df(film_rank_sql) The most frequently rented movie, 34 times, is ‘Bucket Brotherhood’ followed by Rocketeer Mother, 33 times. 17.5.10.1 Replicate the output above using dplyr syntax. # sp_tbl_descr(&#39;table_name&#39;) # sp_tbl_pk_fk(&#39;table_name&#39;) # sp_print_df(table_rows_sql) film_rank_dplyr &lt;- rental_table %&gt;% inner_join(inventory_table, by = c(&quot;inventory_id&quot; = &quot;inventory_id&quot;), suffix(c(&quot;.r&quot;, &quot;.i&quot;))) %&gt;% inner_join(film_table, by = c(&quot;film_id&quot; = &quot;film_id&quot;), suffix(c(&quot;.f&quot;, &quot;.i&quot;))) %&gt;% group_by(film_id,title,rental_rate) %&gt;% summarize(count = n() ,rental_amt = sum(rental_rate) ) %&gt;% arrange(desc(count)) %&gt;% collect() ## Warning: Missing values are always removed in SQL. ## Use `SUM(x, na.rm = TRUE)` to silence this warning sp_print_df(film_rank_dplyr) 17.5.11 11 What is the rental distribution/DVD for the top two rented films? From the previous exercise we know that the top two films are Bucket Brotherhood and Rocketeer Mother. To answer this question we look at the rental, inventory, and film tables again. Instead of looking at the film level, we need to drill down to the individual dvd’s for each film to answer this question. film_rank2_sql &lt;- dbGetQuery(con, &quot;select i.store_id,i.film_id,f.title,i.inventory_id,count(*) from rental r join inventory i on r.inventory_id = i.inventory_id join film f on i.film_id = f.film_id where i.film_id in (103,738) group by i.store_id,i.film_id,f.title,i.inventory_id&quot;) sp_print_df(film_rank2_sql) The ‘Bucket Brotherhood’ and ‘Rocketeer Mother’ DVD’s are equally distributed between the two stores, 4 dvd’s each per film. The ‘Bucket Brotherhood’ was rented 17 times from both stores. The ‘Rocketeer Mother’ was rented 15 times from store 1 and 18 times from store 2. 17.5.11.1 Replicate the output above using dplyr syntax. # sp_tbl_descr(&#39;table_name&#39;) # sp_tbl_pk_fk(&#39;table_name&#39;) # sp_print_df(table_rows_sql) film_rank2_dplyr &lt;- rental_table %&gt;% inner_join(inventory_table, by = c(&quot;inventory_id&quot; = &quot;inventory_id&quot;), suffix(c(&quot;.r&quot;, &quot;.i&quot;))) %&gt;% inner_join(film_table, by = c(&quot;film_id&quot; = &quot;film_id&quot;), suffix(c(&quot;.f&quot;, &quot;.i&quot;))) %&gt;% filter(film_id %in% c(103,738)) %&gt;% group_by(store_id,film_id,title,inventory_id) %&gt;% summarize(count = n()) %&gt;% arrange(film_id,store_id,inventory_id) %&gt;% collect() sp_print_df(film_rank2_dplyr) 17.5.12 12. List staffing information for store 1 associated with the Bucket Brother rentals? To answer this question we look at the rental, inventory, film, staff, address, city, and country tables. film_103_details_sql &lt;- dbGetQuery(con, &quot;select i.store_id,i.film_id,f.title,i.inventory_id inv_id,i.store_id inv_store_id ,r.rental_date::date rented,r.return_date::date returned ,s.staff_id,s.store_id staff_store_id,concat(s.first_name,&#39; &#39;,s.last_name) staff,ctry.country from rental r join inventory i on r.inventory_id = i.inventory_id join film f on i.film_id = f.film_id join staff s on r.staff_id = s.staff_id join address a on s.address_id = a.address_id join city c on a.city_id = c.city_id join country ctry on c.country_id = ctry.country_id where i.film_id in (103) and r.rental_date::date between &#39;2005-05-01&#39;::date and &#39;2005-06-01&#39;::date order by r.rental_date &quot;) sp_print_df(film_103_details_sql) In a previous exercise we saw that store 1 based in Canada and store 2 based in Austrailia each had one employee, staff_id 1 and 2 respectively. We see that Mike from store 1, Canada, had transactions in store 1 and store 2 on 5/25/2005. Similarly Jon from store 2, Australia, had transaction in store 2 and store 1 on 5/31/2005. Is this phsically possible, or a key in error? 17.5.12.1 Replicate the output above using dplyr syntax. column mapping definition inv_id inventory.inventory_id inv_store_id inventory.store_id rented rental.rental_date returned rental.return_date staff_store_id store.store_id staff first_name+last_name # sp_tbl_descr(&#39;table_name&#39;) # sp_tbl_pk_fk(&#39;table_name&#39;) # sp_print_df(table_rows_sql) film_103_details_dplyr &lt;- inventory_table %&gt;% filter(film_id == 103) %&gt;% inner_join(film_table, by=c(&#39;film_id&#39; = &#39;film_id&#39;),suffix(c(&#39;.f&#39;,&#39;r&#39;))) %&gt;% inner_join(rental_table, by=c(&#39;inventory_id&#39; = &#39;inventory_id&#39;),suffix(c(&#39;.i&#39;,&#39;r&#39;))) %&gt;% filter(rental_date &lt; &#39;2005-06-01&#39;) %&gt;% inner_join(staff_table, by=c(&#39;staff_id&#39; = &#39;staff_id&#39;),suffix(c(&#39;.x&#39;,&#39;r&#39;))) %&gt;% inner_join(address_table, by=c(&#39;address_id&#39; = &#39;address_id&#39;),suffix(c(&#39;.a&#39;,&#39;r&#39;))) %&gt;% inner_join(city_table, by=c(&#39;city_id&#39; = &#39;city_id&#39;),suffix(c(&#39;.c&#39;,&#39;a&#39;))) %&gt;% inner_join(country_table, by=c(&#39;country_id&#39; = &#39;country_id&#39;),suffix(c(&#39;.ctry&#39;,&#39;city&#39;))) %&gt;% collect() %&gt;% # as.Date function can&#39;t be translated by dbplyr mutate(rented = as.Date(rental_date) ,returned = as.Date(return_date) ,staff = paste0(first_name,&#39; &#39;,last_name) ) %&gt;% rename(inv_store = store_id.x ,staff_store_id=store_id.y ,inv_id = inventory_id ) %&gt;% select(inv_store,film_id,title,inv_id,rented,returned,staff_id,staff_store_id ,staff,country) %&gt;% arrange(rented) sp_print_df(film_103_details_dplyr) 17.5.13 13. Which film(s) have never been rented To answer this question we look at the film, inventory and rental tables. never_rented_dvds_sql &lt;- dbGetQuery(con, &#39;select i.store_id,f.film_id, f.title,f.description, i.inventory_id from film f join inventory i on f.film_id = i.film_id left join rental r on i.inventory_id = r.inventory_id where r.inventory_id is null &#39; ) sp_print_df(never_rented_dvds_sql) There are only two movies that have not been rented, Academy Dinousaur and Sophie’s Choice. 17.5.13.1 Replicate the output above using dplyr syntax. # sp_tbl_descr(&#39;table_name&#39;) # sp_tbl_pk_fk(&#39;table_name&#39;) # sp_print_df(table_rows_sql) never_rented_dvds_dplyr &lt;- film_table %&gt;% inner_join(inventory_table, by = c(&quot;film_id&quot; = &quot;film_id&quot;), suffix(c(&quot;.f&quot;, &quot;.i&quot;))) %&gt;% anti_join(rental_table, by = c(&#39;inventory_id&#39;,&#39;inventory_id&#39;), suffix(c(&#39;.i&#39;,&#39;.r&#39;))) %&gt;% select(film_id,title,description,inventory_id) %&gt;% collect() sp_print_df(never_rented_dvds_dplyr) 17.5.14 14. How many films are in each film rating? To answer this question we look at the film table to answer this question. film_ratings_sql &lt;- dbGetQuery(con, &#39;select f.rating,count(*) from film f group by f.rating order by count(*) desc &#39; ) sp_print_df(film_ratings_sql) There are 5 ratings and all 5 have roughly 200 movies. 17.5.14.1 Replicate the output above using dplyr syntax. # sp_tbl_descr(&#39;table_name&#39;) # sp_tbl_pk_fk(&#39;table_name&#39;) # sp_print_df(table_rows_sql) film_ratings_dplyr &lt;- film_table %&gt;% group_by(rating) %&gt;% summarize(count=n()) %&gt;% arrange(desc(count)) %&gt;% collect() sp_print_df(film_ratings_dplyr) 17.5.15 15. What are the different film categories? To answer this question we look at the category table to answer this question. film_categories_sql &lt;- dbGetQuery(con, &#39;select * from category&#39; ) sp_print_df(film_categories_sql) There are 16 different categories 17.5.15.1 Replicate the output above using dplyr syntax. # sp_tbl_descr(&#39;table_name&#39;) # sp_tbl_pk_fk(&#39;table_name&#39;) # sp_print_df(table_rows_sql) film_categories_dplyr &lt;- category_table %&gt;% collect() sp_print_df(film_categories_dplyr) 17.5.16 16. How many DVD’s are in each film categeory? To answer this question we look at the category table again. film_categories2_sql &lt;- dbGetQuery(con, &#39;select c.name,count(*) count from category c join film_category fc on c.category_id = fc.category_id group by c.name order by count(*) desc &#39; ) sp_print_df(film_categories2_sql) There are 16 film categories. The highest category, Sports, has 77 films followed by the International category which has 76 film. What is an example of an international category film where all films are currently in English? 17.5.16.1 Replicate the output above using dplyr syntax. # sp_tbl_descr(&#39;table_name&#39;) # sp_tbl_pk_fk(&#39;table_name&#39;) # sp_print_df(table_rows_sql) film_categories2_dplyr &lt;- category_table %&gt;% inner_join(film_category_table, by =c(&#39;category_id&#39;=&#39;category_id&#39;) ,suffix(c(&#39;.c&#39;,&#39;.fc&#39;))) %&gt;% group_by(name) %&gt;% summarise(count=n()) %&gt;% arrange(desc(count)) %&gt;% collect() sp_print_df(film_categories2_dplyr) 17.5.17 17. Which films are listed in multiple categories? To answer this question we look at the film, film_category and category tables. multiple_categories_sql &lt;- dbGetQuery(con, &#39;select f.film_id, f.title,c.name from film_category fc join film f on fc.film_id = f.film_id join category c on fc.category_id = c.category_id where fc.film_id in (select fc.film_id from film f join film_category fc on f.film_id = fc.film_id group by fc.film_id having count(*) &gt; 1 ) &#39; ) sp_print_df(multiple_categories_sql) There is only one film which has two categories, Sophie’s Choice. 17.5.17.1 Replicate the output above using dplyr syntax. # sp_tbl_descr(&#39;table_name&#39;) # sp_tbl_pk_fk(&#39;table_name&#39;) # sp_print_df(table_rows_sql) multiple_categories_dplyr &lt;- # compute films with multiple categories film_table %&gt;% inner_join(film_category_table,by=c(&#39;film_id&#39;=&#39;film_id&#39;), suffix(c(&#39;.f&#39;,&#39;.fc&#39;))) %&gt;% group_by(film_id,title) %&gt;% summarise(count=n()) %&gt;% filter(count &gt; 1) %&gt;% # get the category ids inner_join(film_category_table, by = c(&#39;film_id&#39;=&#39;film_id&#39;),suffix(c(&#39;.f&#39;,&#39;.fc&#39;))) %&gt;% # get the category names inner_join(category_table, by=c(&#39;category_id&#39;=&#39;category_id&#39;)) %&gt;% select(film_id,title,name) %&gt;% collect() sp_print_df(multiple_categories_dplyr) 17.5.18 18. Which DVD’s are in one store’s inventory but not the other In the table below we show the first 10 rows. To answer this question we look at the inventory and film tables. dvd_in_1_store_sql &lt;- dbGetQuery( con, &quot; -- select store1,count(count1) films_not_in_store_2,sum(coalesce(count1,0)) dvds_not_in_store_1 -- ,store2,count(count2) films_not_in_store_1,sum(coalesce(count2,0)) dvds_not_in_store_2 -- from ( select coalesce(i1.film_id,i2.film_id) film_id,f.title,f.rental_rate ,1 store1,coalesce(i1.count,0) count1 ,2 store2,coalesce(i2.count,0) count2 -- dvd inventory in store 1 from (select film_id,store_id,count(*) count from inventory where store_id = 1 group by film_id,store_id ) as i1 full outer join -- dvd inventory in store 2 (select film_id,store_id,count(*) count from inventory where store_id = 2 group by film_id,store_id ) as i2 on i1.film_id = i2.film_id join film f on coalesce(i1.film_id,i2.film_id) = f.film_id where i1.film_id is null or i2.film_id is null order by f.title -- ) as src -- group by store1,store2 &quot; ) if(HEAD_N &gt; 0) { sp_print_df(head(dvd_in_1_store_sql,n=HEAD_N)) } else { sp_print_df(dvd_in_1_store_sql) } Store 1 has 196 films, (576 dvd’s), that are not in store 2. Store 2 has 199 films, (607 dvd’s), that are not in store 1. 17.5.18.1 Replicate the output above using dplyr syntax. The following code isn’t working yet. # sp_tbl_descr(&#39;table_name&#39;) # sp_tbl_pk_fk(&#39;table_name&#39;) # sp_print_df(table_rows_sql) inv_tbl1 &lt;- inventory_table %&gt;% filter(store_id == 1 ) %&gt;% group_by(film_id) %&gt;% summarise(count=n()) %&gt;% collect() inv_tbl2 &lt;- inventory_table %&gt;% filter(store_id == 2 ) %&gt;% group_by(film_id) %&gt;% summarise(count=n()) %&gt;% collect() dvd_in_1_store_dplyr &lt;- inv_tbl1 %&gt;% full_join(inv_tbl2, by=c(&#39;film_id&#39;,&#39;film_id&#39;),suffix(c(&#39;.i1&#39;,&#39;.i2&#39;))) %&gt;% filter(is.na(count.x) | is.na(count.y)) %&gt;% # filter(is.na(count.x + count.y)) %&gt;% #this works also mutate_all(funs(ifelse(is.na(.), 0, .))) %&gt;% inner_join(film_table,by=c(&#39;film_id&#39;,&#39;film_id&#39;), copy =TRUE) %&gt;% mutate(store_id1 = 1, store_id2 = 2) %&gt;% select (film_id,title,rental_rate,store_id1,count.x,store_id2,count.y) %&gt;% arrange(film_id) %&gt;% collect() ## Warning: funs() is soft deprecated as of dplyr 0.8.0 ## please use list() instead ## ## # Before: ## funs(name = f(.) ## ## # After: ## list(name = ~f(.)) ## This warning is displayed once per session. if(HEAD_N &gt; 0) { sp_print_df(head(dvd_in_1_store_dplyr,n=HEAD_N)) } else { sp_print_df(dvd_in_1_store_dplyr) } 17.5.19 19. Which films are not tracked in inventory? To answer this question we look at the film and rental tables. films_no_inventory_sql &lt;- dbGetQuery(con, &quot; select f.film_id,title,rating,rental_rate,replacement_cost from film f left outer join inventory i on f.film_id = i.film_id where i.film_id is null; &quot;) if(HEAD_N &gt; 0) { sp_print_df(head(films_no_inventory_sql,n=HEAD_N)) } else { sp_print_df(films_no_inventory_sql) } There are 42 films that do not exist in inventory or in either store. These may be DVD’s that have been ordered but the business has not received them. Looking at the price and the replacement cost, it doesn’t look like there is any rhyme or reason to the setting of the price. 17.5.19.1 Replicate the output above using dplyr syntax. # sp_tbl_descr(&#39;table_name&#39;) # sp_tbl_pk_fk(&#39;table_name&#39;) # sp_print_df(table_rows_sql) films_no_inventory_dplyr &lt;- film_table %&gt;% anti_join(inventory_table, by=(c(&#39;film_id&#39;=&#39;film_id&#39;))) %&gt;% select (film_id,title,rating,rental_rate,replacement_cost) %&gt;% collect() if(HEAD_N &gt; 0) { sp_print_df(head(films_no_inventory_dplyr,n=HEAD_N)) } else { sp_print_df(films_no_inventory_dplyr) } 17.5.20 20 List film categories in descending accounts receivable. To answer this question we look at the rental, inventory, film, film_category and category tables. film_category_AR_rank_sql &lt;- dbGetQuery(con, &quot; select category,AR ,sum(AR) over (order by AR desc rows between unbounded preceding and current row) running_AR ,rentals ,sum(rentals) over (order by AR desc rows between unbounded preceding and current row) running_rentals from (select c.name category, sum(f.rental_rate) AR, count(*) rentals from rental r join inventory i on r.inventory_id = i.inventory_id join film f on i.film_id = f.film_id join film_category fc on f.film_id = fc.film_id join category c on fc.category_id = c.category_id group by c.name ) src &quot;) sp_print_df(film_category_AR_rank_sql) There are 16 film categories. The top three categories based on highest AR amounts are Sports, Drama, and Sci-Fi. The total number of rentals are 16046 with an AR amount of 47221.54. 17.5.20.1 Replicate the output above using dplyr syntax. column mapping definition category category.name ar f.rental_rate running_ar accumulated ar amounts based on ratings rentals number of rentals associated with the rating running_rentals running rating rentals # sp_tbl_descr(&#39;table_name&#39;) # sp_tbl_pk_fk(&#39;table_name&#39;) # sp_print_df(table_rows_sql) film_category_AR_rank_dplyr &lt;- rental_table %&gt;% inner_join(inventory_table, by=c(&#39;inventory_id&#39;=&#39;inventory_id&#39;)) %&gt;% inner_join(film_table, by=c(&#39;film_id&#39;=&#39;film_id&#39;)) %&gt;% inner_join(film_category_table, by=c(&#39;film_id&#39;=&#39;film_id&#39;)) %&gt;% inner_join(category_table,by=c(&#39;category_id&#39;=&#39;category_id&#39;)) %&gt;% group_by(name) %&gt;% summarize(rentals=n() ,AR=sum(rental_rate, na.rm = TRUE) ) %&gt;% arrange(desc(AR)) %&gt;% mutate(running_ar=cumsum(AR) ,running_rentals=cumsum(rentals) ) %&gt;% rename(category=name) %&gt;% select(category,AR,running_ar,rentals,running_rentals) %&gt;% collect() sp_print_df(film_category_AR_rank_dplyr) 17.5.21 21. List film ratings in descending accounts receivable order. To answer this question we look at the rental, inventory, and film tables. film_rating_rank_sql &lt;- dbGetQuery(con, &quot;select rating,AR ,sum(AR) over (order by AR desc rows between unbounded preceding and current row) running_AR ,rentals ,sum(rentals) over (order by AR desc rows between unbounded preceding and current row) running_rentals from (select f.rating, sum(f.rental_rate) AR, count(*) rentals from rental r join inventory i on r.inventory_id = i.inventory_id join film f on i.film_id = f.film_id group by f.rating ) as src &quot;) sp_print_df(film_rating_rank_sql) There are 5 film ratings. The total number of rentals are 16045 with an AR amount of 47216.55. Why do the film categories revenue and film rating revenue amounts and counts differ, 16046 and 47221.54? 17.5.21.1 Replicate the output above using dplyr syntax. column mapping definition rating film.rating ar f.rental_rate running_ar accumulated ar amounts based on ratings rentals number of rentals associated with the rating running_rentals running rating rentals # sp_tbl_descr(&#39;table_name&#39;) # sp_tbl_pk_fk(&#39;table_name&#39;) # sp_print_df(table_rows_sql) film_rating_rank_dplyr &lt;- rental_table %&gt;% inner_join(inventory_table, by=c(&#39;inventory_id&#39;=&#39;inventory_id&#39;)) %&gt;% inner_join(film_table, by=c(&#39;film_id&#39;=&#39;film_id&#39;)) %&gt;% group_by(rating) %&gt;% summarize(rentals=n() ,AR=sum(rental_rate, na.rm = TRUE) ) %&gt;% arrange(desc(AR)) %&gt;% mutate(running_ar=cumsum(AR) ,running_rentals=cumsum(rentals) ) %&gt;% select(rating,AR,running_ar,rentals,running_rentals) %&gt;% collect() sp_print_df(film_rating_rank_dplyr) 17.5.22 22. How many rentals were returned on time, returned late, never returned? To answer this question we look at the rental, inventory, and film tables. returned_sql &lt;- dbGetQuery(con, &quot;with details as (select case when r.return_date is null then null else r.return_date::date - (r.rental_date + INTERVAL &#39;1 day&#39; * f.rental_duration)::date end rtn_days ,case when r.return_date is null then 1 else 0 end not_rtn from rental r join inventory i on r.inventory_id = i.inventory_id join film f on i.film_id = f.film_id ) select sum(case when rtn_days &lt;= 0 then 1 else 0 end) on_time ,sum(case when rtn_days &gt; 0 then 1 else 0 end) late ,sum(not_rtn) not_rtn ,count(*) rented ,round(100. * sum(case when rtn_days &lt;= 0 then 1 else 0 end)/count(*),2) on_time_pct ,round(100. * sum(case when rtn_days &gt; 0 then 1 else 0 end)/count(*),2) late_pct ,round(100. * sum(not_rtn)/count(*),2) not_rtn_pct from details &quot;) sp_print_df(returned_sql) To date 53.56% of the rented DVD’s were returned on time, 45.30% were returned late, and 1.14% were never returned. 17.5.22.1 Replicate the output above using dplyr syntax. column mapping definition on_time number of DVD’s where rental.return_date &lt;= rental.rental_date + film.rental_duration late number of DVD’s where rental.return_date &gt; rental.rental_date + film.rental_duration not_rtn number of DVD’s not returned; rental.return_date is null rented number of DVD’s rented. on_time_pct Percent of DVD’s returned on time late_pct Percent of DVD’s returned late not_rtn_pct Percent of DVD’s not returned. # sp_tbl_descr(&#39;table_name&#39;) # sp_tbl_pk_fk(&#39;table_name&#39;) # sp_print_df(table_rows_sql) returned_dplyr &lt;- rental_table %&gt;% inner_join(inventory_table, by=c(&#39;inventory_id&#39;=&#39;inventory_id&#39;)) %&gt;% inner_join(film_table, by=c(&#39;film_id&#39;=&#39;film_id&#39;)) %&gt;% collect() %&gt;% # lubrdiate functions can&#39;t be translated by dplyr mutate(rtn_days= lubridate::date(return_date) - (lubridate::date(rental_date) + rental_duration) ,not_returned=ifelse(is.na(return_date),1,0) ) %&gt;% summarize(on_time = sum(ifelse(rtn_days &lt;= 0,1,0),na.rm = TRUE) ,late = sum(ifelse(rtn_days &gt; 0,1,0),na.rm = TRUE) ,not_rtn=sum(not_returned) ,rented = n() ) %&gt;% mutate(on_time_pct = round(100.0 * on_time/rented,2) ,late_pct = round(100.0 * late/rented,2) ,not_rtn_pct = round(100.0 * not_rtn/rented,2) ) sp_print_df(returned_dplyr) 17.5.23 23. Are there duplicate customers? To answer this question we look at the customer, address, city, and country tables. We assume that if the customer first and last name match in two different rows, then it is a duplicate customer. customer_dupes_sql &lt;- dbGetQuery( con, &quot;select cust.customer_id id ,cust.store_id store ,concat(cust.first_name,&#39; &#39;,cust.last_name) customer ,cust.email -- ,a.phone ,a.address ,c.city ,a.postal_code zip ,a.district ,ctry.country from customer cust join address a on cust.address_id = a.address_id join city c on a.city_id = c.city_id join country ctry on c.country_id = ctry.country_id where concat(cust.first_name,cust.last_name) in (select concat(first_name,last_name) from customer group by concat(first_name,last_name) having count(*) &gt;1 ) &quot;) sp_print_df(customer_dupes_sql) Sophie is the only duplicate customer. The only difference between the two records is the store. Record 600 is associated with store 3, which has no employees, and 601 is associated with store 2 17.5.23.1 Replicate the output above using dplyr syntax. column mapping definition id customer.customer_id store customer.store_id customer first_name + last_name zip address.postal_code # sp_tbl_descr(&#39;table_name&#39;) # sp_tbl_pk_fk(&#39;table_name&#39;) # sp_print_df(table_rows_sql) customer_dupes_dplyr &lt;- customer_table %&gt;% group_by(first_name,last_name) %&gt;% summarize(n = n()) %&gt;% filter(n &gt; 1) %&gt;% inner_join(customer_table,by=c(&quot;first_name&quot;=&quot;first_name&quot;,&quot;last_name&quot;=&quot;last_name&quot;)) %&gt;% inner_join(address_table, by = c(&quot;address_id&quot; = &quot;address_id&quot;), suffix(c(&quot;.s&quot;, &quot;.a&quot;))) %&gt;% inner_join(city_table, by = c(&quot;city_id&quot; = &quot;city_id&quot;), suffix(c(&quot;.a&quot;, &quot;.c&quot;))) %&gt;% inner_join(country_table, by = c(&quot;country_id&quot; = &quot;country_id&quot;), suffix(c(&quot;.a&quot;, &quot;.c&quot;))) %&gt;% mutate(customer=paste0(first_name,last_name,sep=&#39; &#39;)) %&gt;% group_by(customer) %&gt;% rename(id=customer_id ,store=store_id ,zip=postal_code ) %&gt;% select(id,store,customer,email,address,city,zip,district,country) %&gt;% collect() sp_print_df(customer_dupes_dplyr) 17.5.24 24. Which customers have never rented a movie? To answer this question we look at the customer and rental tables. customer_no_rentals_sql &lt;- dbGetQuery( con, &quot;select c.customer_id id ,c.first_name ,c.last_name ,c.email ,a.phone ,city.city ,ctry.country ,c.active ,c.create_date -- ,c.last_update from customer c left join rental r on c.customer_id = r.customer_id left join address a on c.address_id = a.address_id left join city on a.city_id = city.city_id left join country ctry on city.country_id = ctry.country_id where r.rental_id is null order by c.customer_id &quot; ) sp_print_df(customer_no_rentals_sql) We see that there are four new customers who have never rented a movie. These four customers are in the countries that have a manned store. column mapping definition id customer.customer_id 17.5.24.1 Replicate the output above using dplyr syntax. # sp_tbl_descr(&#39;table_name&#39;) # sp_tbl_pk_fk(&#39;table_name&#39;) # sp_print_df(table_rows_sql) customer_no_rentals_dplyr &lt;- customer_table %&gt;% anti_join(rental_table, by = &quot;customer_id&quot; ) %&gt;% inner_join(address_table, by = c(&#39;address_id&#39;=&#39;address_id&#39;)) %&gt;% inner_join(city_table, by = c(&#39;city_id&#39;=&#39;city_id&#39;)) %&gt;% inner_join(country_table, by=c(&#39;country_id&#39;=&#39;country_id&#39;)) %&gt;% rename(id=customer_id) %&gt;% select(id,first_name,last_name,email,phone,active,city,country,create_date) %&gt;% collect() sp_print_df(customer_no_rentals_dplyr) 17.5.25 25. Who are the top 5 customers with the most rentals and associated payments? This exercise uses the customer, rental, and payment tables. customer_top_rentals_sql &lt;- dbGetQuery( con, &quot;select c.customer_id id,c.store_id ,concat(c.first_name,&#39; &#39;,c.last_name) customer ,min(rental_date)::date mn_rental_dt ,max(rental_date)::date mx_rental_dt ,sum(COALESCE(p.amount,0.)) paid ,count(r.rental_id) rentals from customer c left join rental r on c.customer_id = r.customer_id left join payment p on r.rental_id = p.rental_id group by c.customer_id ,c.first_name ,c.last_name ,c.store_id order by count(r.rental_id) desc limit 5 &quot; ) sp_print_df(customer_top_rentals_sql) The top 5 customers all rented between 41 to 46 DVD’s. Three of the top 5 rented about 14 DVD’s per month over a three month period. The other two customers 41 and 42 DVD’s per 12 months. 17.5.25.1 Replicate the output above using dplyr column mapping definition id customer.customer_id customer first_name + last_name mn_rental_dt minimum renal date mx_rental_dt maximum rental date paid paid amount rentals customer rentals Use the dplyr inner_join verb to find the top 5 customers who have rented the most movies. # sp_tbl_descr(&#39;table_name&#39;) # sp_tbl_pk_fk(&#39;table_name&#39;) # sp_print_df(table_rows_sql) customer_top_rentals_dplyr &lt;- customer_table %&gt;% left_join(rental_table, by = c(&quot;customer_id&quot; = &quot;customer_id&quot;), suffix(c(&quot;.c&quot;, &quot;.r&quot;))) %&gt;% left_join(payment_table, by = c(&quot;rental_id&quot; = &quot;rental_id&quot;), suffix(c(&#39;r&#39;,&#39;p&#39;))) %&gt;% mutate(customer=paste(first_name,last_name,sep=&#39; &#39;) ) %&gt;% group_by(customer_id.x,customer,store_id) %&gt;% collect() %&gt;% summarize(rentals=n() ,paid = sum(ifelse(is.na(amount),0,amount)) ,mn_rental_dt = as.Date(min(rental_date)) ,mx_rental_dt = as.Date(max(rental_date)) ) %&gt;% arrange(desc(rentals)) %&gt;% rename(id = customer_id.x) %&gt;% select(id,store_id,customer,mn_rental_dt,mx_rental_dt,paid,rentals) sp_print_df(head(customer_top_rentals_dplyr,n=5)) 17.5.26 26. Combine the top 5 rental customers, (40 or more rentals), and zero rental customers To answer this question we look at the customer, rental, and payments tables again. customer_rental_high_low_sql &lt;- dbGetQuery( con, &quot;select c.customer_id id ,concat(c.first_name,&#39; &#39;,c.last_name) customer ,count(*) cust_cnt ,count(r.rental_id) rentals ,count(p.payment_id) payments ,sum(coalesce(p.amount,0)) paid from customer c left outer join rental r on c.customer_id = r.customer_id left outer join payment p on r.rental_id = p.rental_id group by c.customer_id ,c.first_name ,c.last_name having count(r.rental_id) = 0 or count(r.rental_id) &gt; 40 order by count(r.rental_id) desc &quot; ) sp_print_df(customer_rental_high_low_sql) We see that there are four new customers who have never rented a movie. These four customers are in the countries that have a manned store. We see that there are four new customers who have never rented a movie. These four customers are in the countries that have a manned store. 17.5.26.1 Replicate the output above using dplyr syntax. Column Mapping Definition id customer.customer_id customer first_name + last_name rentals customer rentals payments customer payments paid_amt payment.amount aggregated payment amount # sp_tbl_descr(&#39;table_name&#39;) # sp_tbl_pk_fk(&#39;table_name&#39;) # sp_print_df(table_rows_sql) customer_rental_high_low_dplyr &lt;- customer_table %&gt;% left_join(rental_table, by = c(&quot;customer_id&quot; = &quot;customer_id&quot;), suffix(c(&quot;.c&quot;, &quot;.r&quot;))) %&gt;% left_join(payment_table, by = c(&quot;rental_id&quot; = &quot;rental_id&quot;), suffix(c(&#39;r&#39;,&#39;p&#39;))) %&gt;% mutate(customer=paste(first_name,last_name,sep=&#39; &#39;) ,rented = if_else(is.na(rental_id),0, 1) ,paid = if_else(is.na(payment_id),0,1) ) %&gt;% group_by(customer_id.x,customer,rented) %&gt;% summarize(cust_cnt = n() ,rentals=sum(rented, na.rm = TRUE) ,payments = sum(paid, na.rm = TRUE) ,paid_amt = sum(ifelse(is.na(amount),0,amount), na.rm = TRUE) ) %&gt;% filter( rentals == 0 | rentals &gt; 40) %&gt;% rename(id = customer_id.x) %&gt;% select(id,customer,cust_cnt,rentals,payments,paid_amt) %&gt;% arrange(desc(rentals)) %&gt;% collect() sp_print_df(customer_rental_high_low_dplyr) 17.5.27 27. Who are the top-n1 and bottom-n2 customers? The issue with the two previous reports is that the top end is hardcoded, rentals &gt; 40. Over time, the current customers will always be in the top section and new customers will get added. Another way of looking at the previous report is to show just the top and bottom 5 customers. Parameterize the previous exercise to show the top 5 and bottom 5 customers. To answer this question we look at the customer, rental, and payments tables again. customer_rentals_hi_low_sql &lt;- function(high_n,low_n) { customer_rental_high_low_sql &lt;- dbGetQuery(con, &quot;select * from ( select * ,ROW_NUMBER() OVER(ORDER BY rentals desc) rent_hi_low ,ROW_NUMBER() OVER(ORDER BY rentals ) rent_low_hi FROM ( select c.customer_id id ,concat(c.first_name,&#39; &#39;,c.last_name) customer ,count(*) cust_cnt ,count(r.rental_id) rentals ,count(p.payment_id) payments ,sum(coalesce(p.amount,0)) paid_amt from customer c left outer join rental r on c.customer_id = r.customer_id left outer join payment p on r.rental_id = p.rental_id group by c.customer_id ,c.first_name ,c.last_name ) as summary ) row_nums where rent_hi_low &lt;= $1 or rent_low_hi &lt;= $2 order by rent_hi_low &quot; ,c(high_n,low_n) ) return (customer_rental_high_low_sql) } The next code block executes a sql version of such a function. With top_n = 5 and bot_n = 5, it replicates the hard coded version of the previous exercise. With top_n = 5 and bot_n = 0, it gives a top 5 report. With top_n = 0 and bot_n = 5, the report returns the bottom 5. Change the two parameters to see the output from the different combinations. top_n = 5 bot_n = 5 sp_print_df(customer_rentals_hi_low_sql(top_n,bot_n)) 17.5.27.1 Replicate the function above use dplyr syntax. Column Mapping Definition id customer.customer_id cust_cnt customer count rentals customer rentals payments customer payments paid_amt payment.amount aggregated payment amount rent_hi_low sequence with 1 = customer with highest rentals rent_low_hi sequence with 1 = customer with the lowest rentals # sp_tbl_descr(&#39;table_name&#39;) # sp_tbl_pk_fk(&#39;table_name&#39;) # sp_print_df(table_rows_sql) customer_rentals_hi_low_dplr &lt;- function(high_n,low_n) { customer_table &lt;- DBI::dbReadTable(con, &quot;customer&quot;) rental_table &lt;- DBI::dbReadTable(con, &quot;rental&quot;) customer_rental_loj_hi_low_d &lt;- customer_table %&gt;% left_join(rental_table, by = c(&quot;customer_id&quot; = &quot;customer_id&quot;) , suffix(c(&quot;.c&quot;, &quot;.r&quot;))) %&gt;% left_join(payment_table, by = c(&quot;rental_id&quot; = &quot;rental_id&quot;), suffix(c(&#39;r&#39;,&#39;p&#39;))) %&gt;% mutate(customer=paste(first_name,last_name,sep=&#39; &#39;) ,rented = if_else(is.na(rental_id),0, 1) ,paid = if_else(is.na(payment_id),0,1) ) %&gt;% group_by(customer_id.x,customer,rented) %&gt;% summarize(cust_cnt = n() ,rentals=sum(rented) ,payments = sum(paid) ,paid_amt = sum(ifelse(is.na(amount),0,amount)) ) %&gt;% rename(id=customer_id.x) %&gt;% select(id,customer,cust_cnt,rentals,payments,paid_amt) %&gt;% arrange(desc(rentals)) # # Add the rankings # customer_rental_loj_hi_low_d &lt;- cbind(customer_rental_loj_hi_low_d ,rent_hi_low = 1:nrow(customer_rental_loj_hi_low_d) ,rent_low_hi = nrow(customer_rental_loj_hi_low_d):1 ) customer_rental_loj_hi_low_d %&gt;% filter(rent_hi_low &lt;= high_n | rent_low_hi &lt;= low_n) %&gt;% arrange(rent_hi_low) } The following doesn’t run, so commenting it out: # top_n = 5 # bot_n = 5 # sp_print_df(customer_rentals_hi_low_dplr(top_n,bot_n)) 17.5.28 28. How much has each store collected? How are the stores performing? The SQL code shows the payments made to each store in the business. store_payments_sql &lt;- dbGetQuery( con, &quot;select s.store_id,sum(p.amount) amount,count(*) cnt from payment p join staff s on p.staff_id = s.staff_id group by store_id order by 2 desc ; &quot; ) sp_print_df(store_payments_sql) Each store collected just over 30,000 in revenue and each store had about 7300 rentals. 17.5.28.1 Replicate the output above using dplyr syntax. # sp_tbl_descr(&#39;table_name&#39;) # sp_tbl_pk_fk(&#39;table_name&#39;) # sp_print_df(table_rows_sql) store_payments_dplyr &lt;- payment_table %&gt;% inner_join(staff_table,by=c(&#39;staff_id&#39;,&#39;staff_id&#39;)) %&gt;% group_by(staff_id) %&gt;% summarize(amount=sum(amount,na.rm=TRUE),cnt=n()) %&gt;% arrange(desc(amount)) %&gt;% collect() sp_print_df(store_payments_dplyr) 17.5.29 29. What is the business’ distribution of payments? To answer this question we look at the rental, payment, inventory, and film tables to answer this question. As a sanity check, we first check the number of rentals and amount payments. rentals_payments_sql &lt;- dbGetQuery(con, &quot;select &#39;rentals&#39; rec_type, count(*) cnt_amt from rental union select &#39;payments&#39; rec_type, sum(amount) from payment &quot;) sp_print_df(rentals_payments_sql) business_payment_dist_sql &lt;- dbGetQuery( con, &quot;select no_pay_rec_due ,no_pay_rec_cnt ,round(100.0 * no_pay_rec_cnt/rentals,2) no_pay_rec_pct ,rate_eq_paid ,rate_eq_paid_cnt ,round(100.0 * rate_eq_paid_cnt/rentals,2) rate_eq_paid_pct ,rate_lt_paid ,rate_lt_over_paid ,rate_lt_paid_cnt ,round(100.0 * rate_lt_paid_cnt/rentals,2) rate_lt_paid_pct ,rate_gt_paid_due ,rate_gt_paid_cnt ,round(100.0 * rate_gt_paid_cnt/rentals,2) rate_gt_paid_pct ,rentals ,rate_eq_paid_cnt + rate_lt_paid_cnt + rate_gt_paid_cnt payments ,round(100.0 * (no_pay_rec_cnt + rate_eq_paid_cnt + rate_lt_paid_cnt + rate_gt_paid_cnt)/rentals ,2) pct ,rate_eq_paid + rate_lt_paid + rate_lt_over_paid amt_paid ,no_pay_rec_due + rate_gt_paid_due amt_due from ( select sum(case when p.rental_id is null then rental_rate else 0 end ) no_pay_rec_due ,sum(case when p.rental_id is null then 1 else 0 end) no_pay_rec_cnt ,sum(case when f.rental_rate = p.amount then p.amount else 0 end) rate_eq_paid ,sum(case when f.rental_rate = p.amount then 1 else 0 end ) rate_eq_paid_cnt ,sum(case when f.rental_rate &lt; p.amount then f.rental_rate else 0 end) rate_lt_paid ,sum(case when f.rental_rate &lt; p.amount then p.amount-f.rental_rate else 0 end) rate_lt_over_paid ,sum(case when f.rental_rate &lt; p.amount then 1 else 0 end) rate_lt_paid_cnt ,sum(case when f.rental_rate &gt; p.amount then f.rental_rate - p.amount else 0 end ) rate_gt_paid_due ,sum(case when f.rental_rate &gt; p.amount then 1 else 0 end ) rate_gt_paid_cnt ,count(*) rentals FROM rental r LEFT JOIN payment p ON r.rental_id = p.rental_id and r.customer_id = p.customer_id INNER JOIN inventory i ON r.inventory_id = i.inventory_id INNER JOIN film f ON i.film_id = f.film_id ) as details ;&quot; ) # Rental counts sp_print_df(business_payment_dist_sql %&gt;% select(ends_with(&quot;cnt&quot;),rentals)) # Payments sp_print_df(business_payment_dist_sql %&gt;% select(ends_with(&quot;paid&quot;))) # Not paid amounts sp_print_df(business_payment_dist_sql %&gt;% select(ends_with(&quot;due&quot;))) # Rental payments sp_print_df(business_payment_dist_sql %&gt;% select(ends_with(&quot;pct&quot;))) These are interesting results. 09.06% of the total records have no associated payment record in the amount of 4302.47 49.39% of the rentals have been fully paid in full, 23397.75. 41.40% of the rentals have collected more than the rental amount by 18456.75 00.15% of the rentals have collected less than the rental amount by 67.76. The no_pay_rec_cnt + rate_gt_paid_cnt, \\(1453 + 24 = 1477\\) is the number of rentals which have not been paid in full. The total outstanding balance is \\(4302.47 + 67.76 = 4370.23\\) With over 40 percent over collection, someone needs to find out what is wrong with the collection process. Many customers are owed credits or free rentals. 17.5.29.1 Replicate the output above using dplyr syntax. This table describes the columns in the code block answer that follows. There are payment records where the charged amount, rental rate, is less than the amount paid. These payments are split into two pieces, rate_lt_paid and rate_lt_over_paid. The rate_lt_paid is rental rate amount. The rate_lt_over_paid is the paid amount - rental rate, the over paid amount. Column Mapping Definition no_pay_rec_cnt number of DVD rentals without an associated payment record. rate_eq_paid_cnt number of DVD payments that match the film rental rate. rate_lt_paid_cnt number of DVD rental with rental rate less than the amount paid. rate_gt_paid_cnt number of DVD rentals with rental rate greater than the film rental rate. rentals number of rental records analyzed rate_eq_paid amount paid where the rate charged = amount paid rate_lt_paid amount paid where the rate charged &lt; rate_lt_over_paid rate charged &lt; amount paid; This represents the amount over paid amt_paid Total amount paid no_pay_rec_due DVD rentals charges due without a payment record rate_gt_paid_due DVD rentals charged due with a payment record amt_due Total amount due and not collected. no_pay_rec_pct Percent of rentals without a payment record. rate_lt_paid_pct Percent of rentals where the rental charge is less than the paid amount rate_gt_paid_pct Percent of rentals where the rental charge is greater than the paid amount pct Sum of percentages # sp_tbl_descr(&#39;table_name&#39;) # sp_tbl_pk_fk(&#39;table_name&#39;) # sp_print_df(table_rows_sql) business_payment_dist_dplyr &lt;- rental_table %&gt;% left_join(payment_table , by = c(&quot;rental_id&quot;, &quot;rental_id&quot; ,&quot;customer_id&quot;,&quot;customer_id&quot; ) , suffix = c(&quot;.r&quot;, &quot;.p&quot;)) %&gt;% inner_join(inventory_table, by = c(&quot;inventory_id&quot;, &quot;inventory_id&quot;), suffix = c(&quot;.r&quot;, &quot;.i&quot;)) %&gt;% inner_join(film_table, by = c(&quot;film_id&quot;, &quot;film_id&quot;), suffix = c(&quot;.i&quot;, &quot;.f&quot;)) %&gt;% summarize(rentals = n() ,no_pay_rec_due = sum(ifelse(is.na(payment_id),rental_rate,0),na.rm = TRUE) ,no_pay_rec_cnt = sum(ifelse(is.na(payment_id),1,0),na.rm = TRUE) ,rate_eq_paid = sum(ifelse(rental_rate == amount,amount,0),na.rm = TRUE) ,rate_eq_paid_cnt = sum(ifelse(rental_rate == amount,1,0),na.rm = TRUE) ,rental_amt = sum(ifelse(rental_rate &lt; amount,rental_rate,0),na.rm = TRUE) ,rate_lt_paid = sum(ifelse(rental_rate &lt; amount, rental_rate,0),na.rm = TRUE) ,rate_lt_over_paid = sum(ifelse(rental_rate &lt; amount,amount-rental_rate,0),na.rm = TRUE) ,rate_lt_paid_cnt = sum(ifelse(rental_rate &lt; amount,1,0),na.rm = TRUE) ,rate_gt_paid_due = sum(ifelse(amount &lt; rental_rate,rental_rate-amount,0),na.rm = TRUE) ,rate_gt_paid_cnt = sum(ifelse(amount &lt; rental_rate,1,0),na.rm = TRUE) ) %&gt;% mutate(no_pay_rec_pct = round(100 * no_pay_rec_cnt/rentals,2) ,rate_eq_paid_pct = round(100 * rate_eq_paid_cnt/rentals,2) ,rate_lt_paid_pct = round(100 * rate_lt_paid_cnt/rentals,2) ,rate_gt_paid_pct = round(100 * rate_gt_paid_cnt/rentals,2) ,payments = rate_eq_paid_cnt + rate_lt_paid_cnt + rate_gt_paid_cnt ,amt_paid = rate_eq_paid + rate_lt_over_paid + rental_amt ,pct = no_pay_rec_pct + rate_eq_paid_pct + rate_lt_paid_pct + rate_gt_paid_pct ,amt_due = no_pay_rec_due + rate_gt_paid_due ) %&gt;% select (no_pay_rec_due,no_pay_rec_cnt,no_pay_rec_pct ,rate_eq_paid,rate_eq_paid_cnt,rate_eq_paid_pct ,rate_lt_paid,rate_lt_over_paid,rate_lt_paid_cnt,rate_lt_paid_pct ,rate_gt_paid_due,rate_gt_paid_cnt,rate_gt_paid_pct ,rentals ,payments ,pct ,amt_paid ,amt_due) %&gt;% collect() # Rental counts sp_print_df(business_payment_dist_dplyr %&gt;% select(ends_with(&quot;cnt&quot;),rentals)) # Payments sp_print_df(business_payment_dist_dplyr %&gt;% select(ends_with(&quot;paid&quot;))) # Not paid amounts sp_print_df(business_payment_dist_dplyr %&gt;% select(ends_with(&quot;due&quot;))) # Rental payments sp_print_df(business_payment_dist_dplyr %&gt;% select(ends_with(&quot;pct&quot;))) 17.5.29.2 Bad data analysis Here are the sanity check numbers calculated at the beginning of this exercise. rec_type cnt_amt payments 61312.04 rentals 16045.00 Note that the sanity check numbers above, do not match the numbers above. If you query returned the numbers above, use the following result set ot see where the differences exist. rs &lt;- dbGetQuery( con, &quot;SELECT &#39;correct join&#39; hint,r.rental_id,r.customer_id,p.customer_id payment_customer_id,p.rental_id payment_rental_id,p.amount FROM rental r LEFT JOIN payment p ON r.rental_id = p.rental_id and r.customer_id = p.customer_id where r.rental_id = 4591 UNION SELECT &#39;incorrect join&#39; hint,r.rental_id,r.customer_id,p.customer_id payment_customer_id,p.rental_id payment_rental_id,p.amount FROM rental r LEFT JOIN payment p ON r.rental_id = p.rental_id where r.rental_id = 4591 and p.customer_id != 182 ;&quot;) sp_print_df(head(rs)) 17.5.30 30. Which customers have the highest open amounts? From the previous exercise, we know that there are 1477 missing payment records or not fully paid payment records. List the top 5 customers from each category base on balance due amounts. To answer this question we look at the rental, payment, inventory, film and customer tables to answer this question. customer_open_amts_sql &lt;- dbGetQuery( con, &quot; select customer_id ,concat(first_name,&#39; &#39;,last_name) customer ,pay_record ,rental_amt ,paid_amt ,due_amt ,cnt ,rn from (select c.customer_id ,c.first_name ,c.last_name ,case when p.amount is null then &#39;No&#39; else &#39;Yes&#39; end Pay_record ,sum(f.rental_rate) rental_amt ,sum(coalesce(p.amount,0)) paid_amt ,sum(f.rental_rate - coalesce(p.amount,0)) due_amt ,count(*) cnt ,row_number() over (partition by case when p.amount is null then &#39;No&#39; else &#39;Yes&#39; end order by sum(f.rental_rate - coalesce(p.amount,0)) desc,c.customer_id) rn FROM rental r LEFT JOIN payment p ON r.rental_id = p.rental_id and r.customer_id = p.customer_id INNER JOIN inventory i ON r.inventory_id = i.inventory_id INNER JOIN film f ON i.film_id = f.film_id INNER JOIN customer c ON r.customer_id = c.customer_id WHERE f.rental_rate &gt; coalesce(p.amount, 0) group by c.customer_id,c.first_name,c.last_name,case when p.amount is null then &#39;No&#39; else &#39;Yes&#39; end ) as src where rn &lt;= 5 -- and Pay_record = &#39;No&#39; or Pay_record = &#39;Yes&#39; order by Pay_record,rn &quot;) sp_print_df(customer_open_amts_sql) From the previous exercise we see that the number of rentals that have not been paid in full is 1477. There are 24 records that have a payment record, pay_record = ‘Yes’, all have a 0 paid amount. There are 1453 DVD’s rented out that have no payment record. The top 3 customers have 10 DVD’s each that have not been paid. 17.5.30.1 Replicate the output above using dplyr syntax. column definition mapping customer first_name + last_name Pay_record Payment record exists Y/N case when p.amount is null then ‘No’ else ‘Yes’ end rental_amt aggrgated film.rental_rate paid_amt aggregated payment.amount due_amt aggregated film.rental_rate - payment.amount cnt number of rentals/customer rn row number # sp_tbl_descr(&#39;table_name&#39;) # sp_tbl_pk_fk(&#39;table_name&#39;) # sp_print_df(table_rows_sql) customer_open_amts_dplyr &lt;- rental_table %&gt;% left_join(payment_table , by = c(&quot;rental_id&quot;, &quot;rental_id&quot; ,&quot;customer_id&quot;,&quot;customer_id&quot; ) , suffix = c(&quot;.r&quot;, &quot;.p&quot;)) %&gt;% inner_join(inventory_table, by = c(&quot;inventory_id&quot;, &quot;inventory_id&quot;), suffix = c(&quot;.r&quot;, &quot;.i&quot;)) %&gt;% inner_join(film_table, by = c(&quot;film_id&quot;, &quot;film_id&quot;), suffix = c(&quot;.i&quot;, &quot;.f&quot;)) %&gt;% inner_join(customer_table, by = c(&#39;customer_id&#39; = &#39;customer_id&#39;)) %&gt;% filter(rental_rate &gt; ifelse(is.na(amount), 0,amount)) %&gt;% mutate(customer=paste0(first_name,&#39; &#39;,last_name) ,pay_record = ifelse(is.na(amount),&#39;No&#39;,&#39;Yes&#39;) ,paid = ifelse(is.na(amount),0,amount) ) %&gt;% group_by(customer_id,customer,pay_record) %&gt;% summarize(rental_amt = sum(rental_rate, na.rm = TRUE) ,paid_amt = sum(paid, na.rm = TRUE) ,due_amt = sum(rental_rate - paid, na.rm = TRUE) ,cnt = n() ) %&gt;% arrange(pay_record,desc(due_amt)) %&gt;% group_by(pay_record) %&gt;% mutate(id = row_number()) %&gt;% filter(id &lt;= 5) %&gt;% select(customer_id,customer,pay_record,rental_amt,paid_amt,due_amt,cnt,id) %&gt;% collect() sp_print_df(customer_open_amts_dplyr) 17.5.31 31. What is the business cash flow? In the previous exercise we saw that about 50% of the rentals collected the correct amount and 40% of the rentals over collected. The last 10% were never collected. Calculate the number of days it took before the payment was collected and the amount collected? To answer this question we look at the rental, customer, payment, inventory, payment and film tables to answer this question. cash_flow_sql &lt;- dbGetQuery(con, &quot;SELECT payment_date - exp_rtn_dt payment_days ,sum(coalesce(amount, charges)) paid_or_due ,count(*) late_returns FROM ( SELECT payment_date::DATE ,(r.rental_date + INTERVAL &#39;1 day&#39; * f.rental_duration)::DATE exp_rtn_dt ,p.amount ,f.rental_rate charges ,r.rental_date ,r.return_date FROM rental r LEFT JOIN customer c ON c.customer_id = r.customer_id LEFT JOIN address a ON c.address_id = a.address_id LEFT JOIN city ON city.city_id = a.city_id LEFT JOIN country ctry ON ctry.country_id = city.country_id LEFT JOIN inventory i ON r.inventory_id = i.inventory_id LEFT JOIN payment p ON c.customer_id = p.customer_id AND p.rental_id = r.rental_id LEFT JOIN film f ON i.film_id = f.film_id WHERE return_date &gt; (r.rental_date + INTERVAL &#39;1 day&#39; * f.rental_duration)::DATE ) AS src GROUP BY payment_date - exp_rtn_dt ORDER BY payment_date - exp_rtn_dt DESC&quot;) sp_print_df(cash_flow_sql) Wow those are really generous terms. Customers are paying 1.2 to 1.7 years after they returned the DVD. This business is in serious financial trouble! 17.5.31.1 Replicate the output above using dplyr syntax. column definition mapping paid_or_due paid amt associated with rental or the rental_rate ifelse(is.na(amount),rental_rate,amount) payment_days days til payment payment_date - rental_date # sp_tbl_descr(&#39;table_name&#39;) # sp_tbl_pk_fk(&#39;table_name&#39;) # sp_print_df(table_rows_sql) cash_flow_dplyr &lt;- rental_table %&gt;% left_join(payment_table, by=c(&#39;rental_id&#39;=&#39;rental_id&#39;,&#39;customer_id&#39;=&#39;customer_id&#39;)) %&gt;% left_join(inventory_table, by=(&#39;inventory_id&#39;=&#39;inventory_id&#39;)) %&gt;% left_join(film_table, by=(&#39;film_id&#39;=&#39;film_id&#39;)) %&gt;% collect() %&gt;% mutate(pay_dt = lubridate::date(payment_date) ,exp_rtn_dt = lubridate::date(rental_date) + rental_duration ,rdate=lubridate::date(rental_date) ,payment_days = lubridate::date(payment_date) - (lubridate::date(rental_date) + rental_duration) ) %&gt;% filter(return_date &gt; exp_rtn_dt) %&gt;% group_by(payment_days) %&gt;% summarize(paid_or_due=sum(ifelse(is.na(amount),rental_rate,amount)) ,late_returns=n() ) %&gt;% arrange(desc(payment_days)) %&gt;% select(payment_days,paid_or_due,late_returns) sp_print_df(cash_flow_dplyr) 17.5.32 32. Customer information Create a function that takes a customer id and returns customer address information films rented and returned information customer payment information The hidden code block implements such a function in SQL. To answer this question we look at the rental, customer, address, city,country,inventory,paymentandfilm` tables to answer this question. customer_details_fn_sql &lt;- function(cust_id) { customer_details_sql &lt;- dbGetQuery(con, &quot;select c.customer_id id,concat(first_name,&#39; &#39;,c.last_name) customer ,c.email,a.phone,a.address,address2,city.city,a.postal_code,ctry.country ,c.store_id cust_store_id ,i.store_id inv_store_id ,f.film_id ,f.title ,r.rental_date::date rented ,r.return_date::date returned ,(r.rental_date + INTERVAL &#39;1 day&#39; * f.rental_duration)::date exp_rtn_dt ,case when r.return_date is null then null else r.return_date::date - (r.rental_date + INTERVAL &#39;1 day&#39; * f.rental_duration)::date end rtn_stat ,case when r.rental_id is null then null -- dvd returned when r.return_date is null then 1 else 0 end not_rtn ,payment_date::date pay_dt ,f.rental_rate charges ,p.amount paid ,p.amount-f.rental_rate delta ,p.staff_id pay_staff_id ,payment_date::date - rental_date::date pay_days ,r.rental_id,i.inventory_id,payment_id from customer c left join rental r on c.customer_id = r.customer_id left join address a on c.address_id = a.address_id left join city on city.city_id = a.city_id left join country ctry on ctry.country_id = city.country_id left join inventory i on r.inventory_id = i.inventory_id left join payment p on c.customer_id = p.customer_id and p.rental_id = r.rental_id left join film f on i.film_id = f.film_id where c.customer_id = $1 order by id,rented desc &quot; ,cust_id ) return(customer_details_sql) } The following code block executes the customer function. Change the cust_id value to see differnt customers. cust_id &lt;- 600 sp_print_df( customer_details_fn_sql(cust_id)) 17.5.32.1 Replicate the output above using dplyr syntax. column definition mapping id customer_id customer first_name + last_name exp_rtn_dt expected return date rental.rental_date + film.rental_duration rtn_stat return status rental.return_date - (rental.rental_date + film duration) not_rtn dvd not returned null if rental_id is null;not rented; 1 return_date null else 0 pay_dt payment_date delta payment.amount-film.rental_rate pay_staff_id payment.staff_id payment.staff_id pay_days days til payment payment_date - rental_date # sp_tbl_descr(&#39;table_name&#39;) # sp_tbl_pk_fk(&#39;table_name&#39;) # sp_print_df(table_rows_sql) customer_details_fn_dplyr &lt;- function(cust_id) { customer_details_dplyr &lt;- customer_table %&gt;% left_join(rental_table, by=c(&#39;customer_id&#39;=&#39;customer_id&#39;)) %&gt;% left_join(address_table, by=c(&#39;address_id&#39;=&#39;address_id&#39;)) %&gt;% left_join(city_table,by=c(&#39;city_id&#39;=&#39;city_id&#39;)) %&gt;% left_join(country_table,by=c(&#39;country_id&#39;=&#39;country_id&#39;)) %&gt;% left_join(inventory_table,by=c(&#39;inventory_id&#39;=&#39;inventory_id&#39;)) %&gt;% mutate(inv_store_id = store_id.y) %&gt;% left_join(payment_table,by=c(&#39;customer_id&#39;=&#39;customer_id&#39;,&#39;rental_id&#39;=&#39;rental_id&#39;)) %&gt;% left_join(film_table,by=c(&#39;film_id&#39;=&#39;film_id&#39;)) %&gt;% filter(customer_id == cust_id ) %&gt;% collect() %&gt;% # lubridate functions can&#39;t be translated by dbplyr mutate(customer=paste0(first_name,&#39; &#39;,last_name) ,exp_rtn_dt = lubridate::date(rental_date) + rental_duration ,rtn_days= lubridate::date(return_date) - (lubridate::date(rental_date) + rental_duration) ,rented = as.Date(rental_date) ,returned = as.Date(return_date) ,not_rtn=ifelse(is.na(rental_id),rental_id,ifelse(is.na(return_date),1,0)) ,delta = amount-rental_rate ,pay_days = lubridate::date(payment_date) - (lubridate::date(rental_date) + rental_duration) ) %&gt;% rename(id = customer_id ,cust_store_id = store_id.x ,charges = rental_rate ,paid = amount ,pay_dt = payment_date ,pay_staff_id = staff_id.y ) %&gt;% select(id,customer,email,phone,address,address2,city,postal_code,country ,cust_store_id ,inv_store_id ,film_id,title,rented,returned ,exp_rtn_dt,rtn_days,not_rtn ,pay_dt ,charges,paid,delta,pay_staff_id ,pay_days,film_id,rental_id,inventory_id,payment_id ) return(customer_details_dplyr) } Use the following code block to test the dplyr function. cust_id &lt;- 601 sp_print_df(customer_details_fn_dplyr(cust_id)) 17.6 Different strategies for interacting with the database select examples dbGetQuery returns the entire result set as a data frame. For large returned datasets, complex or inefficient SQL statements, this may take a long time. dbSendQuery: parses, compiles, creates the optimized execution plan. dbFetch: Execute optimzed execution plan and return the dataset. dbClearResult: remove pending query results from the database to your R environment 17.6.1 dbGetQuery Versus dbSendQuery+dbFetch+dbClearResult How many customers are there in the DVD Rental System? rs1 &lt;- dbGetQuery(con, &quot;select * from customer;&quot;) sp_print_df(head(rs1)) fetch &lt;- 0 rows &lt;- 0 pco &lt;- dbSendQuery(con, &quot;select * from customer;&quot;) while(!dbHasCompleted(pco)) { rs2 &lt;- dbFetch(pco,n=100) fetch &lt;- fetch + 1 rows &lt;- rows + nrow(rs2) print(paste0(&quot;fetch=&quot;,fetch,&quot; fetched rows=&quot;,nrow(rs2),&quot; running rows fetched=&quot;,rows)) # add additional code to process fetched records } ## [1] &quot;fetch=1 fetched rows=100 running rows fetched=100&quot; ## [1] &quot;fetch=2 fetched rows=100 running rows fetched=200&quot; ## [1] &quot;fetch=3 fetched rows=100 running rows fetched=300&quot; ## [1] &quot;fetch=4 fetched rows=100 running rows fetched=400&quot; ## [1] &quot;fetch=5 fetched rows=100 running rows fetched=500&quot; ## [1] &quot;fetch=6 fetched rows=100 running rows fetched=600&quot; ## [1] &quot;fetch=7 fetched rows=4 running rows fetched=604&quot; dbClearResult(pco) sp_print_df(head(rs2)) # diconnect from the db dbDisconnect(con) sp_docker_stop(&quot;sql-pet&quot;) # knitr::knit_exit() "]
]
