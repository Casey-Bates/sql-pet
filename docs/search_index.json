[
["chapter-lazy-evaluation-queries.html", "Chapter 10 Lazy Evaluation and Lazy Queries 10.1 Setup 10.2 R is lazy and comes with guardrails 10.3 Lazy evaluation and lazy queries 10.4 When does a lazy query trigger data retrieval? 10.5 Other resources", " Chapter 10 Lazy Evaluation and Lazy Queries This chapter: Reviews lazy loading, lazy evaluation and lazy query execution Demonstrates how dplyr code gets executed (and how R determines what is translated to SQL and what is processed locally by R) Offers some further resources on lazy loading, evaluation, execution, etc. 10.1 Setup The following packages are used in this chapter: library(tidyverse) library(DBI) library(RPostgres) library(dbplyr) require(knitr) library(bookdown) library(sqlpetr) If you have not yet set up the Docker container with PostgreSQL and the dvdrental database, go back to those instructions to configure your environment. Otherwise, start your sql-pet container: sqlpetr::sp_docker_start(&quot;sql-pet&quot;) Connect to the database: con &lt;- sqlpetr::sp_get_postgres_connection( user = Sys.getenv(&quot;DEFAULT_POSTGRES_USER_NAME&quot;), password = Sys.getenv(&quot;DEFAULT_POSTGRES_PASSWORD&quot;), dbname = &quot;dvdrental&quot;, seconds_to_test = 30 ) 10.2 R is lazy and comes with guardrails By design, R is both a language and an interactive development environment (IDE). As a language, R tries to be as efficient as possible. As an IDE, R creates some guardrails to make it easy and safe to work with your data. For example getOption(&quot;max.print&quot;) prevents R from printing more rows of data than you want to handle in an interactive session, with a default of 99999 lines, which may or may not suit you. On the other hand SQL is a “Structured Query Language (SQL): a standard computer language for relational database management and data manipulation.”.1 SQL has various database-specific Interactive Development Environments (IDEs), such as pgAdmin for PostgreSQL. Roger Peng explains in R Programming for Data Science that: R has maintained the original S philosophy, which is that it provides a language that is both useful for interactive work, but contains a powerful programming language for developing new tools. This is complicated when R interacts with SQL. In a vignette for dbplyr Hadley Wickham explains: The most important difference between ordinary data frames and remote database queries is that your R code is translated into SQL and executed in the database on the remote server, not in R on your local machine. When working with databases, dplyr tries to be as lazy as possible: It never pulls data into R unless you explicitly ask for it. It delays doing any work until the last possible moment: it collects together everything you want to do and then sends it to the database in one step. Exactly when, which, and how much data is returned from the dbms is the topic of this chapter. Exactly how the data is represented in the dbms and then translated to a data frame is discussed in the DBI specification. Eventually, if you are interacting with a dbms from R you will need to understand the differences between lazy loading, lazy evaluation, and lazy queries. 10.2.1 Lazy loading “Lazy loading is always used for code in packages but is optional (selected by the package maintainer) for datasets in packages.”2 Lazy loading means that the code for a particular function doesn’t actually get loaded into memory until the last minute – when it’s actually being used. 10.2.2 Lazy evaluation Essentially “Lazy evaluation is a programming strategy that allows a symbol to be evaluated only when needed.”3 That means that lazy evaluation is about symbols such as function arguments4 when they are evaluated. Tidy evaluation complicates lazy evaluation.5 10.2.3 Lazy Queries “When you create a &quot;lazy&quot; query, you’re creating a pointer to a set of conditions on the database, but the query isn’t actually run and the data isn’t actually loaded until you call &quot;next&quot; or some similar method to actually fetch the data and load it into an object.”6 10.3 Lazy evaluation and lazy queries 10.3.1 dplyr connection objects As introduced in the previous chapter, the dplyr::tbl function creates an object that might look like a data frame in that when you enter it on the command line, it prints a bunch of rows from the dbms table. But it is actually a list object that dplyr uses for constructing queries and retrieving data from the DBMS. The following code illustrates these issues. The dplyr::tbl function creates the connection object that we store in an object named rental_table: rental_table &lt;- dplyr::tbl(con, &quot;rental&quot;) At first glance, it acts like a data frame when you print it, although it only prints 10 of the table’s 16,044 rows: rental_table ## # Source: table&lt;rental&gt; [?? x 7] ## # Database: postgres [postgres@localhost:5432/dvdrental] ## rental_id rental_date inventory_id customer_id ## &lt;int&gt; &lt;dttm&gt; &lt;int&gt; &lt;int&gt; ## 1 2 2005-05-24 22:54:33 1525 459 ## 2 3 2005-05-24 23:03:39 1711 408 ## 3 4 2005-05-24 23:04:41 2452 333 ## 4 5 2005-05-24 23:05:21 2079 222 ## 5 6 2005-05-24 23:08:07 2792 549 ## 6 7 2005-05-24 23:11:53 3995 269 ## 7 8 2005-05-24 23:31:46 2346 239 ## 8 9 2005-05-25 00:00:40 2580 126 ## 9 10 2005-05-25 00:02:21 1824 399 ## 10 11 2005-05-25 00:09:02 4443 142 ## # … with more rows, and 3 more variables: return_date &lt;dttm&gt;, ## # staff_id &lt;int&gt;, last_update &lt;dttm&gt; However, notice that the first output line shows ??, rather than providing the number of rows in the table. Similarly, the next to last line shows: ... with more rows, and 3 more variables whereas the output for a normal tbl of this rental data would say: ... with 16,034 more rows, and 3 more variables So even though rental_table is a tbl, it’s also a tbl_PqConnection: class(rental_table) ## [1] &quot;tbl_PqConnection&quot; &quot;tbl_dbi&quot; &quot;tbl_sql&quot; ## [4] &quot;tbl_lazy&quot; &quot;tbl&quot; It is not just a normal tbl of data. We can see that from the structure of rental_table: str(rental_table) ## List of 2 ## $ src:List of 2 ## ..$ con :Formal class &#39;PqConnection&#39; [package &quot;RPostgres&quot;] with 3 slots ## .. .. ..@ ptr :&lt;externalptr&gt; ## .. .. ..@ bigint : chr &quot;integer64&quot; ## .. .. ..@ typnames:&#39;data.frame&#39;: 437 obs. of 2 variables: ## .. .. .. ..$ oid : int [1:437] 16 17 18 19 20 21 22 23 24 25 ... ## .. .. .. ..$ typname: chr [1:437] &quot;bool&quot; &quot;bytea&quot; &quot;char&quot; &quot;name&quot; ... ## ..$ disco: NULL ## ..- attr(*, &quot;class&quot;)= chr [1:4] &quot;src_PqConnection&quot; &quot;src_dbi&quot; &quot;src_sql&quot; &quot;src&quot; ## $ ops:List of 2 ## ..$ x : &#39;ident&#39; chr &quot;rental&quot; ## ..$ vars: chr [1:7] &quot;rental_id&quot; &quot;rental_date&quot; &quot;inventory_id&quot; &quot;customer_id&quot; ... ## ..- attr(*, &quot;class&quot;)= chr [1:3] &quot;op_base_remote&quot; &quot;op_base&quot; &quot;op&quot; ## - attr(*, &quot;class&quot;)= chr [1:5] &quot;tbl_PqConnection&quot; &quot;tbl_dbi&quot; &quot;tbl_sql&quot; &quot;tbl_lazy&quot; ... It has only two rows! The first row contains all the information in the con object, which contains information about all the tables and objects in the database: rental_table$src$con@typnames$typname[380:437] ## [1] &quot;customer&quot; &quot;_customer&quot; ## [3] &quot;actor_actor_id_seq&quot; &quot;actor&quot; ## [5] &quot;_actor&quot; &quot;category_category_id_seq&quot; ## [7] &quot;category&quot; &quot;_category&quot; ## [9] &quot;film_film_id_seq&quot; &quot;film&quot; ## [11] &quot;_film&quot; &quot;pg_toast_16434&quot; ## [13] &quot;film_actor&quot; &quot;_film_actor&quot; ## [15] &quot;film_category&quot; &quot;_film_category&quot; ## [17] &quot;actor_info&quot; &quot;_actor_info&quot; ## [19] &quot;address_address_id_seq&quot; &quot;address&quot; ## [21] &quot;_address&quot; &quot;city_city_id_seq&quot; ## [23] &quot;city&quot; &quot;_city&quot; ## [25] &quot;country_country_id_seq&quot; &quot;country&quot; ## [27] &quot;_country&quot; &quot;customer_list&quot; ## [29] &quot;_customer_list&quot; &quot;film_list&quot; ## [31] &quot;_film_list&quot; &quot;inventory_inventory_id_seq&quot; ## [33] &quot;inventory&quot; &quot;_inventory&quot; ## [35] &quot;language_language_id_seq&quot; &quot;language&quot; ## [37] &quot;_language&quot; &quot;nicer_but_slower_film_list&quot; ## [39] &quot;_nicer_but_slower_film_list&quot; &quot;payment_payment_id_seq&quot; ## [41] &quot;payment&quot; &quot;_payment&quot; ## [43] &quot;rental_rental_id_seq&quot; &quot;rental&quot; ## [45] &quot;_rental&quot; &quot;sales_by_film_category&quot; ## [47] &quot;_sales_by_film_category&quot; &quot;staff_staff_id_seq&quot; ## [49] &quot;staff&quot; &quot;_staff&quot; ## [51] &quot;pg_toast_16529&quot; &quot;store_store_id_seq&quot; ## [53] &quot;store&quot; &quot;_store&quot; ## [55] &quot;sales_by_store&quot; &quot;_sales_by_store&quot; ## [57] &quot;staff_list&quot; &quot;_staff_list&quot; The second row contains a list of the columns in the rental table, among other things: rental_table$ops$vars ## [1] &quot;rental_id&quot; &quot;rental_date&quot; &quot;inventory_id&quot; &quot;customer_id&quot; ## [5] &quot;return_date&quot; &quot;staff_id&quot; &quot;last_update&quot; rental_table holds information needed to get the data from the ‘rental’ table, but rental_table does not hold the data itself. In the following sections, we will examine more closely this relationship between the rental_table object and the data in the database’s ‘rental’ table. 10.4 When does a lazy query trigger data retrieval? 10.4.1 Create a black box query for experimentation To illustrate the different issues involved in data retrieval, we create more connection objects to link to two other tables. staff_table &lt;- dplyr::tbl(con, &quot;staff&quot;) The ‘staff’ table has 2 rows. customer_table &lt;- dplyr::tbl(con, &quot;customer&quot;) The ‘customer’ table has 599 rows. Here is a typical string of dplyr verbs strung together with the magrittr %&gt;% pipe command that will be used to tease out the several different behaviors that a lazy query has when passed to different R functions. This query joins three connection objects into a query we’ll call Q: Q &lt;- rental_table %&gt;% dplyr::left_join(staff_table, by = c(&quot;staff_id&quot; = &quot;staff_id&quot;)) %&gt;% dplyr::rename(staff_email = email) %&gt;% dplyr::left_join(customer_table, by = c(&quot;customer_id&quot; = &quot;customer_id&quot;)) %&gt;% dplyr::rename(customer_email = email) %&gt;% dplyr::select(rental_date, staff_email, customer_email) 10.4.2 Experiment overview Think of Q as a black box for the moment. The following examples will show how Q is interpreted differently by different functions. It’s important to remember in the following discussion that the “and then” operator (%&gt;%) actually wraps the subsequent code inside the preceding code so that Q %&gt;% print() is equivalent to print(Q). Notation A single green check indicates that some rows are returned. Two green checks indicate that all the rows are returned. The red X indicates that no rows are returned. R code Result Q %&gt;% print() Prints x rows; same as just entering Q Q %&gt;% dplyr::as_tibble() Forces Q to be a tibble Q %&gt;% head() Prints the first 6 rows Q %&gt;% tail() Error: tail() is not supported by sql sources Q %&gt;% length() Counts the rows in Q Q %&gt;% str() Shows the top 3 levels of the object Q Q %&gt;% nrow() Attempts to determine the number of rows Q %&gt;% dplyr::tally() Counts all the rows – on the dbms side Q %&gt;% dplyr::collect(n = 20) Prints 20 rows Q %&gt;% dplyr::collect(n = 20) %&gt;% head() Prints 6 rows Q %&gt;% dplyr::show_query() Translates the lazy query object into SQL Time-based, execution environment issues Qc &lt;- Q %&gt;% count(customer_email, sort = TRUE) Extends the lazy query object The next chapter will discuss how to build queries and how to explore intermediate steps. But first, the following subsections provide a more detailed discussion of each row in the preceding table. 10.4.3 Q %&gt;% print() Remember that Q %&gt;% print() is equivalent to print(Q) and the same as just entering Q on the command line. We use the magrittr pipe operator here, because chaining functions highlights how the same object behaves differently in each use. Q %&gt;% print() ## # Source: lazy query [?? x 3] ## # Database: postgres [postgres@localhost:5432/dvdrental] ## rental_date staff_email customer_email ## &lt;dttm&gt; &lt;chr&gt; &lt;chr&gt; ## 1 2005-05-24 22:54:33 Mike.Hillyer@sakilasta… tommy.collazo@sakilacustome… ## 2 2005-05-24 23:03:39 Mike.Hillyer@sakilasta… manuel.murrell@sakilacustom… ## 3 2005-05-24 23:04:41 Jon.Stephens@sakilasta… andrew.purdy@sakilacustomer… ## 4 2005-05-24 23:05:21 Mike.Hillyer@sakilasta… delores.hansen@sakilacustom… ## 5 2005-05-24 23:08:07 Mike.Hillyer@sakilasta… nelson.christenson@sakilacu… ## 6 2005-05-24 23:11:53 Jon.Stephens@sakilasta… cassandra.walters@sakilacus… ## 7 2005-05-24 23:31:46 Jon.Stephens@sakilasta… minnie.romero@sakilacustome… ## 8 2005-05-25 00:00:40 Mike.Hillyer@sakilasta… ellen.simpson@sakilacustome… ## 9 2005-05-25 00:02:21 Jon.Stephens@sakilasta… danny.isom@sakilacustomer.o… ## 10 2005-05-25 00:09:02 Jon.Stephens@sakilasta… april.burns@sakilacustomer.… ## # … with more rows R retrieves 10 observations and 3 columns. In its role as IDE, R has provided nicely formatted output that is similar to what it prints for a tibble, with descriptive information about the dataset and each column: # Source: lazy query [?? x 3] # Database: postgres [postgres@localhost:5432/dvdrental] rental_date staff_email customer_email &lt;dttm&gt; &lt;chr&gt; &lt;chr&gt; R has not determined how many rows are left to retrieve as it shows with [?? x 3] and ... with more rows in the data summary. 10.4.4 Q %&gt;% dplyr::as_tibble() In contrast to print(), the as_tibble() function causes R to download the whole table, using tibble’s default of displaying only the first 10 rows. Q %&gt;% dplyr::as_tibble() ## # A tibble: 16,044 x 3 ## rental_date staff_email customer_email ## &lt;dttm&gt; &lt;chr&gt; &lt;chr&gt; ## 1 2005-05-24 22:54:33 Mike.Hillyer@sakilasta… tommy.collazo@sakilacustome… ## 2 2005-05-24 23:03:39 Mike.Hillyer@sakilasta… manuel.murrell@sakilacustom… ## 3 2005-05-24 23:04:41 Jon.Stephens@sakilasta… andrew.purdy@sakilacustomer… ## 4 2005-05-24 23:05:21 Mike.Hillyer@sakilasta… delores.hansen@sakilacustom… ## 5 2005-05-24 23:08:07 Mike.Hillyer@sakilasta… nelson.christenson@sakilacu… ## 6 2005-05-24 23:11:53 Jon.Stephens@sakilasta… cassandra.walters@sakilacus… ## 7 2005-05-24 23:31:46 Jon.Stephens@sakilasta… minnie.romero@sakilacustome… ## 8 2005-05-25 00:00:40 Mike.Hillyer@sakilasta… ellen.simpson@sakilacustome… ## 9 2005-05-25 00:02:21 Jon.Stephens@sakilasta… danny.isom@sakilacustomer.o… ## 10 2005-05-25 00:09:02 Jon.Stephens@sakilasta… april.burns@sakilacustomer.… ## # … with 16,034 more rows 10.4.5 Q %&gt;% head() The head() function is very similar to print but has a different “max.print” value. Q %&gt;% head() ## # Source: lazy query [?? x 3] ## # Database: postgres [postgres@localhost:5432/dvdrental] ## rental_date staff_email customer_email ## &lt;dttm&gt; &lt;chr&gt; &lt;chr&gt; ## 1 2005-05-24 22:54:33 Mike.Hillyer@sakilasta… tommy.collazo@sakilacustomer… ## 2 2005-05-24 23:03:39 Mike.Hillyer@sakilasta… manuel.murrell@sakilacustome… ## 3 2005-05-24 23:04:41 Jon.Stephens@sakilasta… andrew.purdy@sakilacustomer.… ## 4 2005-05-24 23:05:21 Mike.Hillyer@sakilasta… delores.hansen@sakilacustome… ## 5 2005-05-24 23:08:07 Mike.Hillyer@sakilasta… nelson.christenson@sakilacus… ## 6 2005-05-24 23:11:53 Jon.Stephens@sakilasta… cassandra.walters@sakilacust… 10.4.6 Q %&gt;% tail() Produces an error, because Q does not hold all of the data, so it is not possible to list the last few items from the table: try( Q %&gt;% tail(), silent = FALSE, outFile = stdout() ) ## Error : tail() is not supported by sql sources 10.4.7 Q %&gt;% length() Because the Q object is relatively complex, using str() on it prints many lines. You can glimpse what’s going on with length(): Q %&gt;% length() ## [1] 2 10.4.8 Q %&gt;% str() Looking inside shows some of what’s going on (three levels deep): Q %&gt;% str(max.level = 3) ## List of 2 ## $ src:List of 2 ## ..$ con :Formal class &#39;PqConnection&#39; [package &quot;RPostgres&quot;] with 3 slots ## ..$ disco: NULL ## ..- attr(*, &quot;class&quot;)= chr [1:4] &quot;src_PqConnection&quot; &quot;src_dbi&quot; &quot;src_sql&quot; &quot;src&quot; ## $ ops:List of 4 ## ..$ name: chr &quot;select&quot; ## ..$ x :List of 4 ## .. ..$ name: chr &quot;rename&quot; ## .. ..$ x :List of 4 ## .. .. ..- attr(*, &quot;class&quot;)= chr [1:3] &quot;op_join&quot; &quot;op_double&quot; &quot;op&quot; ## .. ..$ dots:List of 1 ## .. ..$ args: list() ## .. ..- attr(*, &quot;class&quot;)= chr [1:3] &quot;op_rename&quot; &quot;op_single&quot; &quot;op&quot; ## ..$ dots:List of 3 ## .. ..$ : language ~rental_date ## .. .. ..- attr(*, &quot;.Environment&quot;)=&lt;environment: 0x7fb55e050820&gt; ## .. ..$ : language ~staff_email ## .. .. ..- attr(*, &quot;.Environment&quot;)=&lt;environment: 0x7fb55e050820&gt; ## .. ..$ : language ~customer_email ## .. .. ..- attr(*, &quot;.Environment&quot;)=&lt;environment: 0x7fb55e050820&gt; ## .. ..- attr(*, &quot;class&quot;)= chr &quot;quosures&quot; ## ..$ args: list() ## ..- attr(*, &quot;class&quot;)= chr [1:3] &quot;op_select&quot; &quot;op_single&quot; &quot;op&quot; ## - attr(*, &quot;class&quot;)= chr [1:5] &quot;tbl_PqConnection&quot; &quot;tbl_dbi&quot; &quot;tbl_sql&quot; &quot;tbl_lazy&quot; ... 10.4.9 Q %&gt;% nrow() Notice the difference between nrow() and tally(). The nrow functions returns NA and does not execute a query: Q %&gt;% nrow() ## [1] NA 10.4.10 Q %&gt;% dplyr::tally() The tally function actually counts all the rows. Q %&gt;% dplyr::tally() ## # Source: lazy query [?? x 1] ## # Database: postgres [postgres@localhost:5432/dvdrental] ## n ## &lt;S3: integer64&gt; ## 1 16044 The nrow() function knows that Q is a list. On the other hand, the tally() function tells SQL to go count all the rows. Notice that Q results in 16,044 rows – the same number of rows as rental. 10.4.11 Q %&gt;% dplyr::collect() The dplyr::collect function triggers a call to the DBI:dbFetch() function behind the scenes, which forces R to download a specified number of rows: Q %&gt;% dplyr::collect(n = 20) ## # A tibble: 20 x 3 ## rental_date staff_email customer_email ## &lt;dttm&gt; &lt;chr&gt; &lt;chr&gt; ## 1 2005-05-24 22:54:33 Mike.Hillyer@sakilasta… tommy.collazo@sakilacustome… ## 2 2005-05-24 23:03:39 Mike.Hillyer@sakilasta… manuel.murrell@sakilacustom… ## 3 2005-05-24 23:04:41 Jon.Stephens@sakilasta… andrew.purdy@sakilacustomer… ## 4 2005-05-24 23:05:21 Mike.Hillyer@sakilasta… delores.hansen@sakilacustom… ## 5 2005-05-24 23:08:07 Mike.Hillyer@sakilasta… nelson.christenson@sakilacu… ## 6 2005-05-24 23:11:53 Jon.Stephens@sakilasta… cassandra.walters@sakilacus… ## 7 2005-05-24 23:31:46 Jon.Stephens@sakilasta… minnie.romero@sakilacustome… ## 8 2005-05-25 00:00:40 Mike.Hillyer@sakilasta… ellen.simpson@sakilacustome… ## 9 2005-05-25 00:02:21 Jon.Stephens@sakilasta… danny.isom@sakilacustomer.o… ## 10 2005-05-25 00:09:02 Jon.Stephens@sakilasta… april.burns@sakilacustomer.… ## 11 2005-05-25 00:19:27 Jon.Stephens@sakilasta… deanna.byrd@sakilacustomer.… ## 12 2005-05-25 00:22:55 Mike.Hillyer@sakilasta… raymond.mcwhorter@sakilacus… ## 13 2005-05-25 00:31:15 Mike.Hillyer@sakilasta… theodore.culp@sakilacustome… ## 14 2005-05-25 00:39:22 Mike.Hillyer@sakilasta… ronald.weiner@sakilacustome… ## 15 2005-05-25 00:43:11 Jon.Stephens@sakilasta… steven.curley@sakilacustome… ## 16 2005-05-25 01:06:36 Mike.Hillyer@sakilasta… isaac.oglesby@sakilacustome… ## 17 2005-05-25 01:10:47 Jon.Stephens@sakilasta… ruth.martinez@sakilacustome… ## 18 2005-05-25 01:17:24 Mike.Hillyer@sakilasta… ronnie.ricketts@sakilacusto… ## 19 2005-05-25 01:48:41 Jon.Stephens@sakilasta… roberta.harper@sakilacustom… ## 20 2005-05-25 01:59:46 Jon.Stephens@sakilasta… craig.morrell@sakilacustome… Q %&gt;% dplyr::collect(n = 20) %&gt;% head() ## # A tibble: 6 x 3 ## rental_date staff_email customer_email ## &lt;dttm&gt; &lt;chr&gt; &lt;chr&gt; ## 1 2005-05-24 22:54:33 Mike.Hillyer@sakilasta… tommy.collazo@sakilacustomer… ## 2 2005-05-24 23:03:39 Mike.Hillyer@sakilasta… manuel.murrell@sakilacustome… ## 3 2005-05-24 23:04:41 Jon.Stephens@sakilasta… andrew.purdy@sakilacustomer.… ## 4 2005-05-24 23:05:21 Mike.Hillyer@sakilasta… delores.hansen@sakilacustome… ## 5 2005-05-24 23:08:07 Mike.Hillyer@sakilasta… nelson.christenson@sakilacus… ## 6 2005-05-24 23:11:53 Jon.Stephens@sakilasta… cassandra.walters@sakilacust… The dplyr::collect function triggers the creation of a tibble and controls the number of rows that the DBMS sends to R. Notice that head only prints 6 of the 20 rows that R has retrieved. If you do not provide a value for the n argument, all of the rows will be retrieved into your R workspace. 10.4.12 Q %&gt;% dplyr::show_query() Q %&gt;% dplyr::show_query() ## &lt;SQL&gt; ## SELECT &quot;rental_date&quot;, &quot;staff_email&quot;, &quot;customer_email&quot; ## FROM (SELECT &quot;rental_id&quot;, &quot;rental_date&quot;, &quot;inventory_id&quot;, &quot;customer_id&quot;, &quot;return_date&quot;, &quot;staff_id&quot;, &quot;last_update.x&quot;, &quot;first_name.x&quot;, &quot;last_name.x&quot;, &quot;address_id.x&quot;, &quot;staff_email&quot;, &quot;store_id.x&quot;, &quot;active.x&quot;, &quot;username&quot;, &quot;password&quot;, &quot;last_update.y&quot;, &quot;picture&quot;, &quot;store_id.y&quot;, &quot;first_name.y&quot;, &quot;last_name.y&quot;, &quot;email&quot; AS &quot;customer_email&quot;, &quot;address_id.y&quot;, &quot;activebool&quot;, &quot;create_date&quot;, &quot;last_update&quot;, &quot;active.y&quot; ## FROM (SELECT &quot;TBL_LEFT&quot;.&quot;rental_id&quot; AS &quot;rental_id&quot;, &quot;TBL_LEFT&quot;.&quot;rental_date&quot; AS &quot;rental_date&quot;, &quot;TBL_LEFT&quot;.&quot;inventory_id&quot; AS &quot;inventory_id&quot;, &quot;TBL_LEFT&quot;.&quot;customer_id&quot; AS &quot;customer_id&quot;, &quot;TBL_LEFT&quot;.&quot;return_date&quot; AS &quot;return_date&quot;, &quot;TBL_LEFT&quot;.&quot;staff_id&quot; AS &quot;staff_id&quot;, &quot;TBL_LEFT&quot;.&quot;last_update.x&quot; AS &quot;last_update.x&quot;, &quot;TBL_LEFT&quot;.&quot;first_name&quot; AS &quot;first_name.x&quot;, &quot;TBL_LEFT&quot;.&quot;last_name&quot; AS &quot;last_name.x&quot;, &quot;TBL_LEFT&quot;.&quot;address_id&quot; AS &quot;address_id.x&quot;, &quot;TBL_LEFT&quot;.&quot;staff_email&quot; AS &quot;staff_email&quot;, &quot;TBL_LEFT&quot;.&quot;store_id&quot; AS &quot;store_id.x&quot;, &quot;TBL_LEFT&quot;.&quot;active&quot; AS &quot;active.x&quot;, &quot;TBL_LEFT&quot;.&quot;username&quot; AS &quot;username&quot;, &quot;TBL_LEFT&quot;.&quot;password&quot; AS &quot;password&quot;, &quot;TBL_LEFT&quot;.&quot;last_update.y&quot; AS &quot;last_update.y&quot;, &quot;TBL_LEFT&quot;.&quot;picture&quot; AS &quot;picture&quot;, &quot;TBL_RIGHT&quot;.&quot;store_id&quot; AS &quot;store_id.y&quot;, &quot;TBL_RIGHT&quot;.&quot;first_name&quot; AS &quot;first_name.y&quot;, &quot;TBL_RIGHT&quot;.&quot;last_name&quot; AS &quot;last_name.y&quot;, &quot;TBL_RIGHT&quot;.&quot;email&quot; AS &quot;email&quot;, &quot;TBL_RIGHT&quot;.&quot;address_id&quot; AS &quot;address_id.y&quot;, &quot;TBL_RIGHT&quot;.&quot;activebool&quot; AS &quot;activebool&quot;, &quot;TBL_RIGHT&quot;.&quot;create_date&quot; AS &quot;create_date&quot;, &quot;TBL_RIGHT&quot;.&quot;last_update&quot; AS &quot;last_update&quot;, &quot;TBL_RIGHT&quot;.&quot;active&quot; AS &quot;active.y&quot; ## FROM (SELECT &quot;rental_id&quot;, &quot;rental_date&quot;, &quot;inventory_id&quot;, &quot;customer_id&quot;, &quot;return_date&quot;, &quot;staff_id&quot;, &quot;last_update.x&quot;, &quot;first_name&quot;, &quot;last_name&quot;, &quot;address_id&quot;, &quot;email&quot; AS &quot;staff_email&quot;, &quot;store_id&quot;, &quot;active&quot;, &quot;username&quot;, &quot;password&quot;, &quot;last_update.y&quot;, &quot;picture&quot; ## FROM (SELECT &quot;TBL_LEFT&quot;.&quot;rental_id&quot; AS &quot;rental_id&quot;, &quot;TBL_LEFT&quot;.&quot;rental_date&quot; AS &quot;rental_date&quot;, &quot;TBL_LEFT&quot;.&quot;inventory_id&quot; AS &quot;inventory_id&quot;, &quot;TBL_LEFT&quot;.&quot;customer_id&quot; AS &quot;customer_id&quot;, &quot;TBL_LEFT&quot;.&quot;return_date&quot; AS &quot;return_date&quot;, &quot;TBL_LEFT&quot;.&quot;staff_id&quot; AS &quot;staff_id&quot;, &quot;TBL_LEFT&quot;.&quot;last_update&quot; AS &quot;last_update.x&quot;, &quot;TBL_RIGHT&quot;.&quot;first_name&quot; AS &quot;first_name&quot;, &quot;TBL_RIGHT&quot;.&quot;last_name&quot; AS &quot;last_name&quot;, &quot;TBL_RIGHT&quot;.&quot;address_id&quot; AS &quot;address_id&quot;, &quot;TBL_RIGHT&quot;.&quot;email&quot; AS &quot;email&quot;, &quot;TBL_RIGHT&quot;.&quot;store_id&quot; AS &quot;store_id&quot;, &quot;TBL_RIGHT&quot;.&quot;active&quot; AS &quot;active&quot;, &quot;TBL_RIGHT&quot;.&quot;username&quot; AS &quot;username&quot;, &quot;TBL_RIGHT&quot;.&quot;password&quot; AS &quot;password&quot;, &quot;TBL_RIGHT&quot;.&quot;last_update&quot; AS &quot;last_update.y&quot;, &quot;TBL_RIGHT&quot;.&quot;picture&quot; AS &quot;picture&quot; ## FROM &quot;rental&quot; AS &quot;TBL_LEFT&quot; ## LEFT JOIN &quot;staff&quot; AS &quot;TBL_RIGHT&quot; ## ON (&quot;TBL_LEFT&quot;.&quot;staff_id&quot; = &quot;TBL_RIGHT&quot;.&quot;staff_id&quot;) ## ) &quot;qzdwvvvtzq&quot;) &quot;TBL_LEFT&quot; ## LEFT JOIN &quot;customer&quot; AS &quot;TBL_RIGHT&quot; ## ON (&quot;TBL_LEFT&quot;.&quot;customer_id&quot; = &quot;TBL_RIGHT&quot;.&quot;customer_id&quot;) ## ) &quot;rnitnthkfz&quot;) &quot;ohetoyqsmw&quot; Hand-written SQL code to do the same job will probably look a lot nicer and could be more efficient, but functionally dplyr does the job. 10.4.13 Time-based, execution environment issues Remember that if the expression is assigned to an object, it is not executed. If not, a print() function is implied. This behavior is the basis for a useful debugging and development process where queries are built up incrementally. These two are different: Q %&gt;% count(customer_email) Q_query &lt;- Q %&gt;% count(customer_email) 10.4.14 Q %&gt;% more dplyr Because the following statement implies a print() function at the end, we can run it repeatedly, adding dplyr expressions, and only get 10 rows back. Every time we add a dplyr expression to a chain, R will rewrite the SQL code. For example: Q %&gt;% count(customer_email) ## # Source: lazy query [?? x 2] ## # Database: postgres [postgres@localhost:5432/dvdrental] ## customer_email n ## &lt;chr&gt; &lt;S3: integer64&gt; ## 1 harold.martino@sakilacustomer.org 32 ## 2 sean.douglass@sakilacustomer.org 23 ## 3 bob.pfeiffer@sakilacustomer.org 24 ## 4 jo.fowler@sakilacustomer.org 20 ## 5 raul.fortier@sakilacustomer.org 20 ## 6 annette.olson@sakilacustomer.org 24 ## 7 jeanne.lawson@sakilacustomer.org 27 ## 8 diane.collins@sakilacustomer.org 35 ## 9 cindy.fisher@sakilacustomer.org 29 ## 10 shelly.watts@sakilacustomer.org 26 ## # … with more rows As we understand more about the data, we simply add dplyr expressions to pinpoint what we are looking for: Q %&gt;% count(customer_email) %&gt;% filter(n &gt; 40) %&gt;% arrange(customer_email) ## # Source: lazy query [?? x 2] ## # Database: postgres [postgres@localhost:5432/dvdrental] ## # Ordered by: customer_email ## customer_email n ## &lt;chr&gt; &lt;S3: integer64&gt; ## 1 clara.shaw@sakilacustomer.org 42 ## 2 eleanor.hunt@sakilacustomer.org 46 ## 3 karl.seal@sakilacustomer.org 45 ## 4 marcia.dean@sakilacustomer.org 42 ## 5 tammy.sanders@sakilacustomer.org 41 When all the accumulated dplyr verbs are executed, they are submitted to the dbms and the number of rows that are returned follow the same rules as discussed above. 10.4.15 Many handy R functions can’t be translated to SQL It just so happens that PostgreSQL has a date function that does the same thing as the date function in the lubridate package. In the following code the date function is executed by PostreSQL. rental_table %&gt;% mutate(rental_date = date(rental_date)) ## # Source: lazy query [?? x 7] ## # Database: postgres [postgres@localhost:5432/dvdrental] ## rental_id rental_date inventory_id customer_id return_date ## &lt;int&gt; &lt;date&gt; &lt;int&gt; &lt;int&gt; &lt;dttm&gt; ## 1 2 2005-05-24 1525 459 2005-05-28 19:40:33 ## 2 3 2005-05-24 1711 408 2005-06-01 22:12:39 ## 3 4 2005-05-24 2452 333 2005-06-03 01:43:41 ## 4 5 2005-05-24 2079 222 2005-06-02 04:33:21 ## 5 6 2005-05-24 2792 549 2005-05-27 01:32:07 ## 6 7 2005-05-24 3995 269 2005-05-29 20:34:53 ## 7 8 2005-05-24 2346 239 2005-05-27 23:33:46 ## 8 9 2005-05-25 2580 126 2005-05-28 00:22:40 ## 9 10 2005-05-25 1824 399 2005-05-31 22:44:21 ## 10 11 2005-05-25 4443 142 2005-06-02 20:56:02 ## # … with more rows, and 2 more variables: staff_id &lt;int&gt;, ## # last_update &lt;dttm&gt; If we specify that we want to use the lubridate version (or any number of other R functions) they are passed to the dbms unless we explicitly tell dplyr to stop translating and bring the results back to the R environment for local processing. rental_table %&gt;% collect() %&gt;% mutate(rental_date = lubridate::date(rental_date)) ## # A tibble: 16,044 x 7 ## rental_id rental_date inventory_id customer_id return_date ## &lt;int&gt; &lt;date&gt; &lt;int&gt; &lt;int&gt; &lt;dttm&gt; ## 1 2 2005-05-24 1525 459 2005-05-28 19:40:33 ## 2 3 2005-05-24 1711 408 2005-06-01 22:12:39 ## 3 4 2005-05-24 2452 333 2005-06-03 01:43:41 ## 4 5 2005-05-24 2079 222 2005-06-02 04:33:21 ## 5 6 2005-05-24 2792 549 2005-05-27 01:32:07 ## 6 7 2005-05-24 3995 269 2005-05-29 20:34:53 ## 7 8 2005-05-24 2346 239 2005-05-27 23:33:46 ## 8 9 2005-05-25 2580 126 2005-05-28 00:22:40 ## 9 10 2005-05-25 1824 399 2005-05-31 22:44:21 ## 10 11 2005-05-25 4443 142 2005-06-02 20:56:02 ## # … with 16,034 more rows, and 2 more variables: staff_id &lt;int&gt;, ## # last_update &lt;dttm&gt; 10.4.16 More lazy execution examples See more examples of lazy execution here. DBI::dbDisconnect(con) sqlpetr::sp_docker_stop(&quot;sql-pet&quot;) 10.5 Other resources Benjamin S. Baumer. 2017. A Grammar for Reproducible and Painless Extract-Transform-Load Operations on Medium Data. https://arxiv.org/abs/1708.07073 dplyr Reference documentation: Remote tables. https://dplyr.tidyverse.org/reference/index.html#section-remote-tables Data Carpentry. SQL Databases and R. https://datacarpentry.org/R-ecology-lesson/05-r-and-databases.html https://www.techopedia.com/definition/1245/structured-query-language-sql↩ https://cran.r-project.org/doc/manuals/r-release/R-ints.html#Lazy-loading↩ https://colinfay.me/lazyeval/↩ http://adv-r.had.co.nz/Functions.html#function-arguments↩ https://colinfay.me/tidyeval-1/↩ https://www.quora.com/What-is-a-lazy-query↩ "]
]
