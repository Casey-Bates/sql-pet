[
["index.html", "R, Databases and Docker Chapter 1 Introduction 1.1 Using R to query a DBMS in your organization 1.2 Docker’s role 1.3 Docker and R on your machine 1.4 Who are we? 1.5 Prerequisites 1.6 Install Docker 1.7 Download the repo", " R, Databases and Docker Dipti Muni, Ian Frantz, John David Smith, Mary Anne Thygesen, M. Edward (Ed) Borasky, Scott Case, and Sophie Yang 2018-09-26 Chapter 1 Introduction 1.1 Using R to query a DBMS in your organization Large data stores in organizations are stored in databases that have specific access constraints and structural characteristics. Data documentation may be incomplete, often emphsizes operational issues rather than analytical ones, and often needs to be confirmed on the fly. Data volumes and query performance are important design constraints. R users frequently need to make sense of complex data structures and coding schemes to address incompletely formed questions so that exploratory data analysis has to be fast. Exploratory techniques for the purpose should not be reinvented (and so would benefit from more public instruction or discussion). Learning to navigate the interfaces (passwords, packages, etc.) between R and a database is difficult to simulate outside corporate walls. Resources for interface problem diagnosis behind corporate walls may or may not address all the issues that R users face, so a simulated environment is needed. 1.2 Docker’s role Noam Ross’s “Docker for the UseR” suggests that there are four distinct Docker use-cases for useRs. Make a fixed working environment for reproducible analysis Access a service outside of R (e.g., Postgres) Create an R based service (e.g., with plumber) Send our compute jobs to the cloud with minimal reconfiguration or revision This book explores #2 because it allows us to work on the database access issues described above and to practice on an industrial-scale DBMS. Docker is a relatively easy way to simulate the relationship between an R/Rstudio session and a database – all on on a single machine, provided you have Docker installed and running. You may want to run PostgresSQL on a Docker container, avoiding any OS or system dependencies that might come up. 1.3 Docker and R on your machine Here is how R and Docker fit on your operating system in this tutorial: (This diagram needs to be updated as our directory structure evolves.) 1.4 Who are we? M. Edward (Ed) Borasky - @znmeb John David Smith - @smithjd Scott Came - @scottcame Ian Franz - @ianfrantz Sophie Yang - @SophieMYang Jim Tyhurst - @jimtyhurst Paul Refalo - @paulrefalo 1.5 Prerequisites You will need A computer running Windows, MacOS, or Linux (Any Linux distro that will run Docker Community Edition, R and RStudio will work), R, and Rstudio and Docker hosting. The database we use is PostgreSQL 10, but you do not need to install that - it’s installed via a Docker image. RStudio 1.2 is highly recommended but not required. In addition to the current version of R and Rstudio, you will need the following packages: tidyverse DBI RPostgres glue dbplyr 1.6 Install Docker Install Docker. Installation depends on your operating system: On a Mac On UNIX flavors For Windows, consider these issues and follow these instructions. 1.7 Download the repo First step: download this repo. It contains source code to build a Docker container that has the dvdrental database in Postgress and shows how to interact with the database from R. "],
["docker-hosting-for-windows.html", "Chapter 2 Docker Hosting for Windows 2.1 Hardware requirements 2.2 Software requirements 2.3 Docker for Windows settings 2.4 Git, GitHub and line endings", " Chapter 2 Docker Hosting for Windows Skip these instructions if your computer has either OSX or a Unix variant. 2.1 Hardware requirements You will need an Intel or AMD processor with 64-bit hardware and the hardware virtualization feature. Most machines you buy today will have that, but older ones may not. You will need to go into the BIOS / firmware and enable the virtualization feature. You will need at least 4 gigabytes of RAM! 2.2 Software requirements You will need Windows 7 64-bit or later. If you can afford it, I highly recommend upgrading to Windows 10 Pro. 2.2.1 Windows 7, 8, 8.1 and Windows 10 Home (64 bit) Install Docker Toolbox. The instructions are here: https://docs.docker.com/toolbox/toolbox_install_windows/. Make sure you try the test cases and they work! 2.2.2 Windows 10 Pro Install Docker for Windows stable. The instructions are here: https://docs.docker.com/docker-for-windows/install/#start-docker-for-windows. Again, make sure you try the test cases and they work. 2.3 Docker for Windows settings 2.3.1 Shared drives If you’re going to mount host files into container filesystems (as we do in the following chapters), you need to set up shared drives. Open the Docker settings dialog and select Shared Drives. Check the drives you want to share. In this screenshot, the D: drive is my 1 terabyte hard drive. 2.3.2 Kubernetes Kubernetes is a container orchestration / cloud management package that’s a major DevOps tool. It’s heavily supported by Red Hat and Google, and as a result is becoming a required skill for DevOps. However, it’s overkill for this project at the moment. So you should make sure it’s not enabled. Go to the Kubernetes dialog and make sure the Enable Kubernetes checkbox is cleared. 2.4 Git, GitHub and line endings Git was originally developed for Linux - in fact, it was created by Linus Torvalds to manage hundreds of different versions of the Linux kernel on different machines all around the world. As usage has grown, it’s achieved a huge following and is the version control system used by most large open source projects, including this one. If you’re on Windows, there are some things about Git and GitHub you need to watch. First of all, there are quite a few tools for running Git on Windows, but the RStudio default and recommended one is Git for Windows (https://git-scm.com/download/win). By default, text files on Linux end with a single linefeed (\\n) character. But on Windows, text files end with a carriage return and a line feed (\\r\\n). See https://en.wikipedia.org/wiki/Newline for the gory details. Git defaults to checking files out in the native mode. So if you’re on Linux, a text file will show up with the Linux convention, and if you’re on Windows, it will show up with the Windows convention. Most of the time this doesn’t cause any problems. But Docker containers usually run Linux, and if you have files from a repository on Windows that you’ve sent to the container, the container may malfunction or give weird results. This kind of situation has caused a lot of grief for contributors to this project, so beware. In particular, executable sh or bash scripts will fail in a Docker container if they have Windows line endings. You may see an error message with \\r in it, which means the shell saw the carriage return (\\r) and gave up. But often you’ll see no hint at all what the problem was. So you need a way to tell Git that some files need to be checked out with Linux line endings. See https://help.github.com/articles/dealing-with-line-endings/ for the details. Summary: You’ll need a .gitattributes file in the root of the repository. In that file, all text files (scripts, program source, data, etc.) that are destined for a Docker container will need to have the designator &lt;spec&gt; text eol=lf, where &lt;spec&gt; is the file name specifier, for example, *.sh. This repo includes a sample: .gitattributes "],
["learning-goals-and-use-cases.html", "Chapter 3 Learning Goals and Use Cases 3.1 Context: Why integrate R with databases using Docker? 3.2 Learning Goals 3.3 Use cases 3.4 Environment", " Chapter 3 Learning Goals and Use Cases 3.1 Context: Why integrate R with databases using Docker? Large data stores in organizations are stored in databases that have specific access constraints and structural characteristics. Learning to navigate the gap between R and the database is difficult to simulate outside corporate walls. R users frequently need to make sense of complex data structures using diagnostic techniques that shuld not be reinvented (and so would benefit from more public instruction and commentary). Docker is a relatively easy way to simulate the relationship between an R/Rstudio session and database – all on on a single machine. 3.2 Learning Goals After working through this tutorial, you can expect to be able to: Run queries against Postgres in an environment that simulates what you will find in a corporate setting. Understand some of the tradeoffs between queries aimed at exploration or informal investigation using dplyr and those where performance is important because of the size of the database or the frequency with which a query is run. You will be able to rewrite dplyr queries as SQL and submit them directly. You will have some understanding of techniques for assessing query structure and performance. Set up a Postgres database in a Docker enviornment and understand enough about Docker to swap databases, swap DBMS’ (e.g., MySQL for Postgres, etc.) 3.3 Use cases Imagine that you have one of several roles at DVDs R Us and that you need to: As a data scientist, I want to know the distribution of number of rentals per month per customer, so that the Marketing department can create incentives for customers in 3 segments: Frequent Renters, Average Renters, Infrequent Renters. As the Director of Sales, I want to see the total number of rentals per month for the past 6 months and I want to know how fast our customer base is growing/shrinking per month for the past 6 months. As the Director of Marketing, I want to know which categories of DVDs are the least popular, so that I can create a campaign to draw attention to rarely used inventory. As a shipping clerk, I want to add rental information when I fulfill a shipment order. As the Director of Analytics, you want to test as much of the production R code in my shop against a new release of the DBMS that the IT department is implementing next month. etc. 3.4 Environment This tutorial uses the Postgres version of “dvd rental” database, which can be downloaded here. Here’s a glimpse of it’s structure: Entity Relationship diagram for the dvdrental database "],
["docker-postgres-and-r.html", "Chapter 4 Docker, Postgres, and R 4.1 Verify that Docker running 4.2 Clean up if appropriate 4.3 Put the database password in an environment file 4.4 Connect, read and write to Postgres from R 4.5 Clean up", " Chapter 4 Docker, Postgres, and R We always load the tidyverse and some other packages, but don’t show it unless we are using packages other than tidyverse, DBI, RPostgres, and glue. 4.1 Verify that Docker running Docker commands can be run from a terminal (e.g., the Rstudio Terminal pane) or with a system() command. In this tutorial, we use system2() so that all the output that is created externally is shown. Note that system2 calls are divided into several parts: The program that you are sending a command to. The parameters or commands that are being sent stdout = TRUE, stderr = TRUE are two parameters that are standard in this book, so that the comand’s full output is shown in the book. The docker version command returns the details about the docker daemon that is running on your computer. system2(&quot;docker&quot;, &quot;version&quot;, stdout = TRUE, stderr = TRUE) ## [1] &quot;Client:&quot; ## [2] &quot; Version: 18.06.1-ce&quot; ## [3] &quot; API version: 1.38&quot; ## [4] &quot; Go version: go1.10.3&quot; ## [5] &quot; Git commit: e68fc7a&quot; ## [6] &quot; Built: Tue Aug 21 17:21:31 2018&quot; ## [7] &quot; OS/Arch: darwin/amd64&quot; ## [8] &quot; Experimental: false&quot; ## [9] &quot;&quot; ## [10] &quot;Server:&quot; ## [11] &quot; Engine:&quot; ## [12] &quot; Version: 18.06.1-ce&quot; ## [13] &quot; API version: 1.38 (minimum version 1.12)&quot; ## [14] &quot; Go version: go1.10.3&quot; ## [15] &quot; Git commit: e68fc7a&quot; ## [16] &quot; Built: Tue Aug 21 17:29:02 2018&quot; ## [17] &quot; OS/Arch: linux/amd64&quot; ## [18] &quot; Experimental: true&quot; 4.2 Clean up if appropriate Remove the cattle and sql-pet containers if they exists (e.g., from a prior experiments). if (system2(&quot;docker&quot;, &quot;ps -a&quot;, stdout = TRUE) %&gt;% grepl(x = ., pattern = &#39;cattle&#39;) %&gt;% any()) { system2(&quot;docker&quot;, &quot;rm -f cattle&quot;) } if (system2(&quot;docker&quot;, &quot;ps -a&quot;, stdout = TRUE) %&gt;% grepl(x = ., pattern = &#39;sql-pet&#39;) %&gt;% any()) { system2(&quot;docker&quot;, &quot;rm -f sql-pet&quot;) } The convention we use in this book is to assemble a command with glue so that the you can see all of its separate parts. The following chunk just constructs the command, but does not execute it. If you have problems executing a commnad, you can always copy the command and execute in your terminal session. docker_cmd &lt;- glue( &quot;run &quot;, # Run is the Docker command. Everything that follows are `docker run` parameters. &quot;--detach &quot;, # (or `-d`) tells Docker to disconnect from the terminal / program issuing the command &quot;--name cattle &quot;, # tells Docker to give the container a name: `cattle` &quot;--publish 5432:5432 &quot;, # tells Docker to expose the Postgres port 5432 to the local network with 5432 &quot; postgres:10 &quot; # tells Docker the image that is to be run (after downloading if necessary) ) # We name containers `cattle` for &quot;throw-aways&quot; and `pet` for ones we treasure and keep around. :-) Submit the command constructed above: # this is what you would submit from a terminal: cat(glue(&quot; docker &quot;, docker_cmd)) ## docker run --detach --name cattle --publish 5432:5432 postgres:10 # this is how R submits it to Docker: system2(&quot;docker&quot;, docker_cmd, stdout = TRUE, stderr = TRUE) ## [1] &quot;aa933dc8d1f98303ba80a8b7055f105907f5c369871b2a012aecfa01c5db4274&quot; Docker returns a long string of numbers. If you are running this command for the first time, Docker is downloading the Postgres image and it takes a bit of time. The following comand shows that postgres:10 is running. postgres is waiting for a connection: system2(&quot;docker&quot;, &quot;ps&quot;, stdout = TRUE, stderr = TRUE) ## [1] &quot;CONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES&quot; ## [2] &quot;aa933dc8d1f9 postgres:10 \\&quot;docker-entrypoint.s…\\&quot; Less than a second ago Up Less than a second 0.0.0.0:5432-&gt;5432/tcp cattle&quot; 4.3 Put the database password in an environment file The goal is to put the password in an untracked file that will not be committed in your source code repository. Your code can reference the name of the variable, but the value of that variable will not appear in open text in your source code. We have chosen to call the file dev_environment.csv in the current working directory where you are executing this script. That file name appears in the .gitignore file, so that you will not accidentally commit it. We are going to create that file now. You will be prompted for the database password. By default, a postgres database defines a database user named postgres, whose password is postgres. If you have changed the password or created a new user with a different password, then enter those new values when prompted. Otherwise, enter postgres and postgres at the two prompts. In an interactive environment, you could execute a snippet of code that prompts the user for their username and password with the followoing snippet (which isn’t run in the book): Your password is still in plain text in the file, dev_environment.csv, so you should protect that file from exposure. However, you do not need to worry about committing that file accidentally to your git repository, because the name of the file appears in the .gitignore file. 4.4 Connect, read and write to Postgres from R 4.4.1 Pause for some security considerations Create a connection to Postgres after waiting 3 seconds so that Docker has time to do its thing. For security, we use values from the environment_variables data.frame, rather than keeping the username and password in plain text in this source file. wait_for_postgres &lt;- function(user, password, dbname, seconds_to_test = 10) { for (i in 1:seconds_to_test) { db_ready &lt;- DBI::dbCanConnect(RPostgres::Postgres(), host = &quot;localhost&quot;, port = &quot;5432&quot;, user = user, password = password, dbname = dbname) if ( !db_ready ) {Sys.sleep(1)} else {con &lt;- DBI::dbConnect(RPostgres::Postgres(), host = &quot;localhost&quot;, port = &quot;5432&quot;, user = user, password = password, dbname = dbname) } if (i == seconds_to_test &amp; !db_ready) {con &lt;- &quot;There is no connection&quot;} } con } This wait_for_postgres function uses environment variables that R obtains from reading a file named .Rprofile which is found in your default directory. To see whether you have already created that file, execute: dir(path = &quot;~&quot;, pattern = &quot;.Rprofile&quot;, all.files = TRUE) ## [1] &quot;.Rprofile&quot; It should contain lines such as: DEFAULT_POSTGRES_PASSWORD=postgres DEFAULT_POSTGRES_USER_NAME=postgres con &lt;- wait_for_postgres(user = Sys.getenv(&quot;DEFAULT_POSTGRES_USER_NAME&quot;), password = Sys.getenv(&quot;DEFAULT_POSTGRES_PASSWORD&quot;), dbname = &quot;postgres&quot;, seconds_to_test = 10) Show that you can connect but that Postgres database doesn’t contain any tables: dbListTables(con) ## character(0) Write mtcars to Postgres dbWriteTable(con, &quot;mtcars&quot;, mtcars, overwrite = TRUE) List the tables in the Postgres database to show that mtcars is now there: dbListTables(con) ## [1] &quot;mtcars&quot; # list the fields in mtcars: dbListFields(con, &quot;mtcars&quot;) ## [1] &quot;mpg&quot; &quot;cyl&quot; &quot;disp&quot; &quot;hp&quot; &quot;drat&quot; &quot;wt&quot; &quot;qsec&quot; &quot;vs&quot; &quot;am&quot; &quot;gear&quot; ## [11] &quot;carb&quot; Download the table from the DBMS to a local data frame: mtcars_df &lt;- tbl(con, &quot;mtcars&quot;) # Show a few rows: knitr::kable(head(mtcars_df)) mpg cyl disp hp drat wt qsec vs am gear carb 21.0 6 160 110 3.90 2.620 16.46 0 1 4 4 21.0 6 160 110 3.90 2.875 17.02 0 1 4 4 22.8 4 108 93 3.85 2.320 18.61 1 1 4 1 21.4 6 258 110 3.08 3.215 19.44 1 0 3 1 18.7 8 360 175 3.15 3.440 17.02 0 0 3 2 18.1 6 225 105 2.76 3.460 20.22 1 0 3 1 4.5 Clean up Afterwards, always disconnect from the DBMS, stop the docker container and (optionally) remove it. dbDisconnect(con) # tell Docker to stop the container: system2(&quot;docker&quot;, &quot;stop cattle&quot;, stdout = TRUE, stderr = TRUE) ## [1] &quot;cattle&quot; # tell Docker to remove the container from it&#39;s library of active containers: system2(&quot;docker&quot;, &quot;rm cattle&quot;, stdout = TRUE, stderr = TRUE) ## [1] &quot;cattle&quot; If we stop the docker container but don’t remove it (with the rm cattle command), the container will persist and we can start it up again later with start cattle. In that case, mtcars would still be there and we could retrieve it from R again. Since we have now removed the cattle container, the whole database has been deleted. (There are enough copies of mtcars in the world, so no great loss.) "],
["a-persistent-database-in-postgres-in-docker-all-at-once.html", "Chapter 5 A persistent database in Postgres in Docker - all at once 5.1 Overview 5.2 First, verify that Docker is up and running: 5.3 Clean up if appropriate 5.4 Build the Docker Image 5.5 Run the Docker Image 5.6 Connect to Postgres with R 5.7 Stop and start to demonstrate persistence 5.8 Cleaning up 5.9 Using the sql-pet container in the rest of the book", " Chapter 5 A persistent database in Postgres in Docker - all at once 5.1 Overview You’ve already connected to Postgres with R, now you need a “realistic” (dvdrental) database. We’re going to demonstrate how to set one up, with two different approaches. This chapter and the next do the same job, illustrating the different approaches that you can take and helping you see the different points whwere you could swap what’s provided here with a different DBMS or a different backup file or something else. The code in this first version is recommended because it is an “all in one” approach. Details about how it works and how you might modify it are included below. There is another version in the the next chapter that you can use to investigate Docker commands and components. Note that this approach relies on two files that have quote that’s not shown here: dvdrental.Dockerfile and init-dvdrental.sh. They are discussed below. Note that tidyverse, DBI, RPostgres, and glue are loaded. 5.2 First, verify that Docker is up and running: system2(&quot;docker&quot;, &quot;version&quot;, stdout = TRUE, stderr = TRUE) ## [1] &quot;Client:&quot; ## [2] &quot; Version: 18.06.1-ce&quot; ## [3] &quot; API version: 1.38&quot; ## [4] &quot; Go version: go1.10.3&quot; ## [5] &quot; Git commit: e68fc7a&quot; ## [6] &quot; Built: Tue Aug 21 17:21:31 2018&quot; ## [7] &quot; OS/Arch: darwin/amd64&quot; ## [8] &quot; Experimental: false&quot; ## [9] &quot;&quot; ## [10] &quot;Server:&quot; ## [11] &quot; Engine:&quot; ## [12] &quot; Version: 18.06.1-ce&quot; ## [13] &quot; API version: 1.38 (minimum version 1.12)&quot; ## [14] &quot; Go version: go1.10.3&quot; ## [15] &quot; Git commit: e68fc7a&quot; ## [16] &quot; Built: Tue Aug 21 17:29:02 2018&quot; ## [17] &quot; OS/Arch: linux/amd64&quot; ## [18] &quot; Experimental: true&quot; 5.3 Clean up if appropriate Remove the sql-pet container if it exists (e.g., from a prior run) if (system2(&quot;docker&quot;, &quot;ps -a&quot;, stdout = TRUE) %&gt;% grepl(x = ., pattern = &#39;sql-pet&#39;) %&gt;% any()) { system2(&quot;docker&quot;, &quot;rm -f sql-pet&quot;) } 5.4 Build the Docker Image Build an image that derives from postgres:10, defined in dvdrental.Dockerfile, that is set up to restore and load the dvdrental db on startup. The dvdrental.Dockerfile is discussed below. system2(&quot;docker&quot;, glue(&quot;build &quot;, # tells Docker to build an image that can be loaded as a container &quot;--tag postgres-dvdrental &quot;, # (or -t) tells Docker to name the image &quot;--file dvdrental.Dockerfile &quot;, #(or -f) tells Docker to read `build` instructions from the dvdrental.Dockerfile &quot; . &quot;), # tells Docker to look for dvdrental.Dockerfile in the current directory stdout = TRUE, stderr = TRUE) ## [1] &quot;Sending build context to Docker daemon 3.092MB\\r\\r&quot; ## [2] &quot;Step 1/4 : FROM postgres:10&quot; ## [3] &quot; ---&gt; ac25c2bac3c4&quot; ## [4] &quot;Step 2/4 : WORKDIR /tmp&quot; ## [5] &quot; ---&gt; Using cache&quot; ## [6] &quot; ---&gt; 3f00a18e0bdf&quot; ## [7] &quot;Step 3/4 : COPY init-dvdrental.sh /docker-entrypoint-initdb.d/&quot; ## [8] &quot; ---&gt; Using cache&quot; ## [9] &quot; ---&gt; 3453d61d8e3e&quot; ## [10] &quot;Step 4/4 : RUN apt-get -qq update &amp;&amp; apt-get install -y -qq curl zip &gt; /dev/null 2&gt;&amp;1 &amp;&amp; curl -Os http://www.postgresqltutorial.com/wp-content/uploads/2017/10/dvdrental.zip &amp;&amp; unzip dvdrental.zip &amp;&amp; rm dvdrental.zip &amp;&amp; chmod ugo+w dvdrental.tar &amp;&amp; chown postgres dvdrental.tar &amp;&amp; chmod u+x /docker-entrypoint-initdb.d/init-dvdrental.sh &amp;&amp; apt-get remove -y curl zip&quot; ## [11] &quot; ---&gt; Using cache&quot; ## [12] &quot; ---&gt; f5e93aa64875&quot; ## [13] &quot;Successfully built f5e93aa64875&quot; ## [14] &quot;Successfully tagged postgres-dvdrental:latest&quot; 5.5 Run the Docker Image Run docker to bring up postgres. The first time it runs it will take a minute to create the Postgres environment. There are two important parts to this that may not be obvious: The source= paramter points to dvdrental.Dockerfile, which does most of the heavy lifting. It has detailed, line-by-line comments to explain what it is doing. Inside dvdrental.Dockerfile the comand COPY init-dvdrental.sh /docker-entrypoint-initdb.d/ copies init-dvdrental.sh from the local file system into the specified location in the Docker container. When the Postgres Docker container initializes, it looks for that file and executes it. Doing all of that work behind the scenes involves two layers of complexity. Depending on how you look at it, that may be more or less difficult to understand than the method shown in the next Chapter. wd &lt;- getwd() docker_cmd &lt;- glue( &quot;run &quot;, # Run is the Docker command. Everything that follows are `run` parameters. &quot;--detach &quot;, # (or `-d`) tells Docker to disconnect from the terminal / program issuing the command &quot; --name sql-pet &quot;, # tells Docker to give the container a name: `sql-pet` &quot;--publish 5432:5432 &quot;, # tells Docker to expose the Postgres port 5432 to the local network with 5432 &quot;--mount &quot;, # tells Docker to mount a volume -- mapping Docker&#39;s internal file structure to the host file structure &quot;type=bind,&quot;, # tells Docker that the mount command points to an actual file on the host system &#39;source=&quot;&#39;, # tells Docker where the local file will be found wd, &#39;/&quot;,&#39;, # the current working directory, as retrieved above &quot;target=/petdir&quot;, # tells Docker to refer to the current directory as &quot;/petdir&quot; in its file system &quot; postgres-dvdrental&quot; # tells Docker to run the image was built in the previous step ) # if you are curious you can paste this string into a terminal window after the command &#39;docker&#39;: docker_cmd ## run --detach --name sql-pet --publish 5432:5432 --mount type=bind,source=&quot;/Users/jds/Documents/Library/R/r-system/sql-pet/r-database-docker/&quot;,target=/petdir postgres-dvdrental system2(&quot;docker&quot;, docker_cmd, stdout = TRUE, stderr = TRUE) ## [1] &quot;ac15072cdf9ea480b6415cb13b1f70772b168f4b2df4804dc4b81c254f45e98e&quot; 5.6 Connect to Postgres with R Use the DBI package to connect to Postgres. But first, wait for Docker &amp; Postgres to come up before connecting. We have loaded the wait_for_postgres function behind the scenes. con &lt;- wait_for_postgres(user = Sys.getenv(&quot;DEFAULT_POSTGRES_USER_NAME&quot;), password = Sys.getenv(&quot;DEFAULT_POSTGRES_PASSWORD&quot;), dbname = &quot;dvdrental&quot;, seconds_to_test = 10) # if (con == &quot;it&#39;s not there&quot;) {stop()} dbListTables(con) ## [1] &quot;actor_info&quot; &quot;customer_list&quot; ## [3] &quot;film_list&quot; &quot;nicer_but_slower_film_list&quot; ## [5] &quot;sales_by_film_category&quot; &quot;staff&quot; ## [7] &quot;sales_by_store&quot; &quot;staff_list&quot; ## [9] &quot;category&quot; &quot;film_category&quot; ## [11] &quot;country&quot; &quot;actor&quot; ## [13] &quot;language&quot; &quot;inventory&quot; ## [15] &quot;payment&quot; &quot;rental&quot; ## [17] &quot;city&quot; &quot;store&quot; ## [19] &quot;film&quot; &quot;address&quot; ## [21] &quot;film_actor&quot; &quot;customer&quot; dbListFields(con, &quot;rental&quot;) ## [1] &quot;rental_id&quot; &quot;rental_date&quot; &quot;inventory_id&quot; &quot;customer_id&quot; ## [5] &quot;return_date&quot; &quot;staff_id&quot; &quot;last_update&quot; dbDisconnect(con) Sys.sleep(2) # Can take a moment to disconnect. 5.7 Stop and start to demonstrate persistence Stop the container system2(&#39;docker&#39;, &#39;stop sql-pet&#39;, stdout = TRUE, stderr = TRUE) ## [1] &quot;sql-pet&quot; Sys.sleep(3) # can take a moment for Docker to stop the container. Restart the container and verify that the dvdrental tables are still there system2(&quot;docker&quot;, &quot;start sql-pet&quot;, stdout = TRUE, stderr = TRUE) ## [1] &quot;sql-pet&quot; con &lt;- wait_for_postgres(user = Sys.getenv(&quot;DEFAULT_POSTGRES_USER_NAME&quot;), password = Sys.getenv(&quot;DEFAULT_POSTGRES_PASSWORD&quot;), dbname = &quot;dvdrental&quot;, seconds_to_test = 10) glimpse(dbReadTable(con, &quot;film&quot;)) ## Observations: 1,000 ## Variables: 13 ## $ film_id &lt;int&gt; 133, 384, 8, 98, 1, 2, 3, 4, 5, 6, 7, 9, 10, ... ## $ title &lt;chr&gt; &quot;Chamber Italian&quot;, &quot;Grosse Wonderful&quot;, &quot;Airpo... ## $ description &lt;chr&gt; &quot;A Fateful Reflection of a Moose And a Husban... ## $ release_year &lt;int&gt; 2006, 2006, 2006, 2006, 2006, 2006, 2006, 200... ## $ language_id &lt;int&gt; 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, ... ## $ rental_duration &lt;int&gt; 7, 5, 6, 4, 6, 3, 7, 5, 6, 3, 6, 3, 6, 6, 6, ... ## $ rental_rate &lt;dbl&gt; 4.99, 4.99, 4.99, 4.99, 0.99, 4.99, 2.99, 2.9... ## $ length &lt;int&gt; 117, 49, 54, 73, 86, 48, 50, 117, 130, 169, 6... ## $ replacement_cost &lt;dbl&gt; 14.99, 19.99, 15.99, 12.99, 20.99, 12.99, 18.... ## $ rating &lt;chr&gt; &quot;NC-17&quot;, &quot;R&quot;, &quot;R&quot;, &quot;PG-13&quot;, &quot;PG&quot;, &quot;G&quot;, &quot;NC-17... ## $ last_update &lt;dttm&gt; 2013-05-26 14:50:58, 2013-05-26 14:50:58, 20... ## $ special_features &lt;chr&gt; &quot;{Trailers}&quot;, &quot;{\\&quot;Behind the Scenes\\&quot;}&quot;, &quot;{Tr... ## $ fulltext &lt;chr&gt; &quot;&#39;chamber&#39;:1 &#39;fate&#39;:4 &#39;husband&#39;:11 &#39;italian&#39;:... It’s always good to have R disconnect from the database dbDisconnect(con) Stop the container &amp; show that the container is still there, so can be started again. system2(&#39;docker&#39;, &#39;stop sql-pet&#39;, stdout = TRUE, stderr = TRUE) ## [1] &quot;sql-pet&quot; # show that the container still exists even though it&#39;s not running psout &lt;- system2(&quot;docker&quot;, &quot;ps -a&quot;, stdout = TRUE) psout[grepl(x = psout, pattern = &#39;sql-pet&#39;)] ## [1] &quot;ac15072cdf9e postgres-dvdrental \\&quot;docker-entrypoint.s…\\&quot; 22 seconds ago Exited (0) Less than a second ago sql-pet&quot; 5.8 Cleaning up Next time, you can just use this command to start the container: system2(&quot;docker&quot;, &quot;start sql-pet&quot;, stdout = TRUE, stderr = TRUE) And once stopped, the container can be removed with: system2(&quot;docker&quot;, &quot;rm sql-pet&quot;, stdout = TRUE, stderr = TRUE) 5.9 Using the sql-pet container in the rest of the book After this point in the book, we assume that Docker is up and that we can always start up our sql-pet database with: system2(&quot;docker&quot;, &quot;start sql-pet&quot;, stdout = TRUE, stderr = TRUE) "],
["a-persistent-database-in-postgres-in-docker-piecemeal.html", "Chapter 6 A persistent database in Postgres in Docker - piecemeal 6.1 Overview 6.2 Retrieve the backup file 6.3 Now, verify that Docker is up and running: 6.4 Build the Docker Image 6.5 Stop and start to demonstrate persistence 6.6 Cleaning up 6.7 Using the sql-pet container in the rest of the book", " Chapter 6 A persistent database in Postgres in Docker - piecemeal 6.1 Overview This chapter essentially repeats what was presented in the previous one, but does it in a step-by-step way that might be useful to understand how each of the steps involved in setting up a persistent Postgres database works. If you are satisfied with the method shown in that chapter, skip this one for now. Note that tidyverse, DBI, RPostgres, and glue are loaded. 6.2 Retrieve the backup file The first step is to get a local copy of the dvdrental Postgres restore file. It comes in a zip format and needs to be un-zipped. Use the downloader and here packages to keep track of things. if (!require(downloader)) install.packages(&quot;downloader&quot;) ## Loading required package: downloader if (!require(here)) install.packages(&quot;here&quot;) ## Loading required package: here ## here() starts at /Users/jds/Documents/Library/R/r-system/sql-pet/r-database-docker library(downloader, here) download(&quot;http://www.postgresqltutorial.com/wp-content/uploads/2017/10/dvdrental.zip&quot;, destfile = here(&quot;dvdrental.zip&quot;)) unzip(here(&quot;dvdrental.zip&quot;), exdir = here()) # creates a tar archhive named &quot;dvdrental.tar&quot; file.remove(here(&quot;dvdrental.zip&quot;)) # the Zip file is no longer needed. ## [1] TRUE 6.3 Now, verify that Docker is up and running: system2(&quot;docker&quot;, &quot;version&quot;, stdout = TRUE, stderr = TRUE) ## [1] &quot;Client:&quot; ## [2] &quot; Version: 18.06.1-ce&quot; ## [3] &quot; API version: 1.38&quot; ## [4] &quot; Go version: go1.10.3&quot; ## [5] &quot; Git commit: e68fc7a&quot; ## [6] &quot; Built: Tue Aug 21 17:21:31 2018&quot; ## [7] &quot; OS/Arch: darwin/amd64&quot; ## [8] &quot; Experimental: false&quot; ## [9] &quot;&quot; ## [10] &quot;Server:&quot; ## [11] &quot; Engine:&quot; ## [12] &quot; Version: 18.06.1-ce&quot; ## [13] &quot; API version: 1.38 (minimum version 1.12)&quot; ## [14] &quot; Go version: go1.10.3&quot; ## [15] &quot; Git commit: e68fc7a&quot; ## [16] &quot; Built: Tue Aug 21 17:29:02 2018&quot; ## [17] &quot; OS/Arch: linux/amd64&quot; ## [18] &quot; Experimental: true&quot; Remove the sql-pet container if it exists (e.g., from a prior run) if (system2(&quot;docker&quot;, &quot;ps -a&quot;, stdout = TRUE) %&gt;% grepl(x = ., pattern = &#39;sql-pet&#39;) %&gt;% any()) { system2(&quot;docker&quot;, &quot;rm -f sql-pet&quot;) } 6.4 Build the Docker Image Build an image that derives from postgres:10. Connect the local and Docker directories that need to be shared. Expose the standard Postgres port 5432. &quot; postgres-dvdrental&quot; # tells Docker the image that is to be run (after downloading if necessary) wd &lt;- getwd() docker_cmd &lt;- glue( &quot;run &quot;, # Run is the Docker command. Everything that follows are `run` parameters. &quot;--detach &quot;, # (or `-d`) tells Docker to disconnect from the terminal / program issuing the command &quot; --name sql-pet &quot;, # tells Docker to give the container a name: `sql-pet` &quot;--publish 5432:5432 &quot;, # tells Docker to expose the Postgres port 5432 to the local network with 5432 &quot;--mount &quot;, # tells Docker to mount a volume -- mapping Docker&#39;s internal file structure to the host file structure &#39;type=bind,source=&quot;&#39;, wd, &#39;/&quot;,target=/petdir&#39;, &quot; postgres:10 &quot; # tells Docker the image that is to be run (after downloading if necessary) ) cat(&#39;docker &#39;,docker_cmd) ## docker run --detach --name sql-pet --publish 5432:5432 --mount type=bind,source=&quot;/Users/jds/Documents/Library/R/r-system/sql-pet/r-database-docker/&quot;,target=/petdir postgres:10 system2(&quot;docker&quot;, docker_cmd, stdout = TRUE, stderr = TRUE) ## [1] &quot;909fb5a40ccfad69071dd5fa3c1edc2c454ff32deca3f800b1135a6f3fc0f868&quot; Peek inside the docker container and list the files in the petdir directory. Notice that dvdrental.tar is in both. system2(&#39;docker&#39;, &#39;exec sql-pet ls petdir | grep &quot;dvdrental.tar&quot; &#39;, stdout = TRUE, stderr = TRUE) ## [1] &quot;dvdrental.tar&quot; dir(wd, pattern = &quot;dvdrental.tar&quot;) ## [1] &quot;dvdrental.tar&quot; We can execute programs inside the Docker container with the exec command. In this case we tell Docker to execute the psql program inside the sql-pet container and pass it some commands. Sys.sleep(2) # is this really needed? # inside Docker, execute the postgress SQL command-line program to create the dvdrental database: system2(&#39;docker&#39;, &#39;exec sql-pet psql -U postgres -c &quot;CREATE DATABASE dvdrental;&quot;&#39;, stdout = TRUE, stderr = TRUE) ## [1] &quot;CREATE DATABASE&quot; The psql program repeats back to us what it has done, e.g., to create a databse named dvdrental. Next we execute a different program in the Docker container, pg_restore, and tell it where the restore file is located. If successful, the pg_restore just responds with a very laconic character(0). # restore the database from the .tar file system2(&quot;docker&quot;, &quot;exec sql-pet pg_restore -U postgres -d dvdrental petdir/dvdrental.tar&quot;, stdout = TRUE, stderr = TRUE) ## character(0) file.remove(here(&quot;dvdrental.tar&quot;)) # the tar file is no longer needed. ## [1] TRUE Use the DBI package to connect to Postgres. But first, wait for Docker &amp; Postgres to come up before connecting. We have loaded the wait_for_postgres function behind the scenes. con &lt;- wait_for_postgres(user = Sys.getenv(&quot;DEFAULT_POSTGRES_USER_NAME&quot;), password = Sys.getenv(&quot;DEFAULT_POSTGRES_PASSWORD&quot;), dbname = &quot;dvdrental&quot;, seconds_to_test = 10) dbListTables(con) ## [1] &quot;actor_info&quot; &quot;customer_list&quot; ## [3] &quot;film_list&quot; &quot;nicer_but_slower_film_list&quot; ## [5] &quot;sales_by_film_category&quot; &quot;staff&quot; ## [7] &quot;sales_by_store&quot; &quot;staff_list&quot; ## [9] &quot;category&quot; &quot;film_category&quot; ## [11] &quot;country&quot; &quot;actor&quot; ## [13] &quot;language&quot; &quot;inventory&quot; ## [15] &quot;payment&quot; &quot;rental&quot; ## [17] &quot;city&quot; &quot;store&quot; ## [19] &quot;film&quot; &quot;address&quot; ## [21] &quot;film_actor&quot; &quot;customer&quot; dbListFields(con, &quot;film&quot;) ## [1] &quot;film_id&quot; &quot;title&quot; &quot;description&quot; ## [4] &quot;release_year&quot; &quot;language_id&quot; &quot;rental_duration&quot; ## [7] &quot;rental_rate&quot; &quot;length&quot; &quot;replacement_cost&quot; ## [10] &quot;rating&quot; &quot;last_update&quot; &quot;special_features&quot; ## [13] &quot;fulltext&quot; dbDisconnect(con) 6.5 Stop and start to demonstrate persistence Stop the container system2(&#39;docker&#39;, &#39;stop sql-pet&#39;, stdout = TRUE, stderr = TRUE) ## [1] &quot;sql-pet&quot; Restart the container and verify that the dvdrental tables are still there system2(&quot;docker&quot;, &quot;start sql-pet&quot;, stdout = TRUE, stderr = TRUE) ## [1] &quot;sql-pet&quot; con &lt;- wait_for_postgres(user = Sys.getenv(&quot;DEFAULT_POSTGRES_USER_NAME&quot;), password = Sys.getenv(&quot;DEFAULT_POSTGRES_PASSWORD&quot;), dbname = &quot;dvdrental&quot;, seconds_to_test = 10) glimpse(dbReadTable(con, &quot;film&quot;)) ## Observations: 1,000 ## Variables: 13 ## $ film_id &lt;int&gt; 133, 384, 8, 98, 1, 2, 3, 4, 5, 6, 7, 9, 10, ... ## $ title &lt;chr&gt; &quot;Chamber Italian&quot;, &quot;Grosse Wonderful&quot;, &quot;Airpo... ## $ description &lt;chr&gt; &quot;A Fateful Reflection of a Moose And a Husban... ## $ release_year &lt;int&gt; 2006, 2006, 2006, 2006, 2006, 2006, 2006, 200... ## $ language_id &lt;int&gt; 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, ... ## $ rental_duration &lt;int&gt; 7, 5, 6, 4, 6, 3, 7, 5, 6, 3, 6, 3, 6, 6, 6, ... ## $ rental_rate &lt;dbl&gt; 4.99, 4.99, 4.99, 4.99, 0.99, 4.99, 2.99, 2.9... ## $ length &lt;int&gt; 117, 49, 54, 73, 86, 48, 50, 117, 130, 169, 6... ## $ replacement_cost &lt;dbl&gt; 14.99, 19.99, 15.99, 12.99, 20.99, 12.99, 18.... ## $ rating &lt;chr&gt; &quot;NC-17&quot;, &quot;R&quot;, &quot;R&quot;, &quot;PG-13&quot;, &quot;PG&quot;, &quot;G&quot;, &quot;NC-17... ## $ last_update &lt;dttm&gt; 2013-05-26 14:50:58, 2013-05-26 14:50:58, 20... ## $ special_features &lt;chr&gt; &quot;{Trailers}&quot;, &quot;{\\&quot;Behind the Scenes\\&quot;}&quot;, &quot;{Tr... ## $ fulltext &lt;chr&gt; &quot;&#39;chamber&#39;:1 &#39;fate&#39;:4 &#39;husband&#39;:11 &#39;italian&#39;:... Stop the container &amp; show that the container is still there, so can be started again. system2(&#39;docker&#39;, &#39;stop sql-pet&#39;, stdout = TRUE, stderr = TRUE) ## [1] &quot;sql-pet&quot; # show that the container still exists even though it&#39;s not running psout &lt;- system2(&quot;docker&quot;, &quot;ps -a&quot;, stdout = TRUE) psout[grepl(x = psout, pattern = &#39;sql-pet&#39;)] ## [1] &quot;909fb5a40ccf postgres:10 \\&quot;docker-entrypoint.s…\\&quot; 18 seconds ago Exited (137) Less than a second ago sql-pet&quot; 6.6 Cleaning up Next time, you can just use this command to start the container: system2(&quot;docker&quot;, &quot;start sql-pet&quot;, stdout = TRUE, stderr = TRUE) And after disconnecting from it the container can be completely removed with: system2(&quot;docker&quot;, &quot;rm sql-pet -f&quot;, stdout = TRUE, stderr = TRUE) 6.7 Using the sql-pet container in the rest of the book After this point in the book, we assume that Docker is up and that we can always start up our sql-pet database with: system2(&quot;docker&quot;, &quot;start sql-pet&quot;, stdout = TRUE, stderr = TRUE) "],
["introduction-to-interacting-with-postgres-from-r.html", "Chapter 7 Introduction to interacting with Postgres from R 7.1 Basics 7.2 Ask yourself about what you are aiming for? 7.3 Get some basic information about your database", " Chapter 7 Introduction to interacting with Postgres from R Note that tidyverse, DBI, RPostgres, and glue are loaded. 7.1 Basics keeping passwords secure Coverage in this book. There are many SQL tutorials that are available. For example, we are drawing some materials from a tutorial we recommend. In particular, we will not replicate the lessons there, which you might want to complete. Instead, we are showing strategies that are recommended for R users. That will include some translations of queries that are discussed there. 7.2 Ask yourself about what you are aiming for? differences between production and data warehouse environments learning to keep your DBAs happy You are your own DBA in this simulation, so you can wreak havoc and learn from it, but you can learn to be DBA-friendly here. in the end it’s the subject-matter experts that understand your data, but you have to work with your DBAs first 7.3 Get some basic information about your database Assume that the Docker container with Postgres and the dvdrental database are ready to go. system2(&quot;docker&quot;, &quot;start sql-pet&quot;, stdout = TRUE, stderr = TRUE) ## [1] &quot;sql-pet&quot; con &lt;- wait_for_postgres(user = Sys.getenv(&quot;DEFAULT_POSTGRES_USER_NAME&quot;), password = Sys.getenv(&quot;DEFAULT_POSTGRES_PASSWORD&quot;), dbname = &quot;dvdrental&quot;, seconds_to_test = 10) You usually need to use both the available documentation for your database and to be somewhat skeptical (e.g., empirical). It’s worth learning to interpret the symbols in an Entity Relationship Diagram: Depending on how skeptical you are about the documenttion, you might want to get an overview of a database by pulling data from the database information_schema. Here’s a selection of useful information although you may want more (or less). There is a lot to choose from a vast list of metadata. Note that information schemas are somewhat consistent across different DBMS’ that you may encounter. have we hidden “in_schema()” as in: con %&gt;% tbl(in_schema(&quot;aux&quot;, &quot;df&quot;)) table_schema_query &lt;- glue(&quot;SELECT &quot;, &quot;table_name, column_name, data_type, ordinal_position, column_default, character_maximum_length&quot;, &quot; FROM information_schema.columns &quot;, &quot;WHERE table_schema = &#39;public&#39;&quot;) rental_meta_data &lt;- dbGetQuery(con, table_schema_query) glimpse(rental_meta_data) ## Observations: 128 ## Variables: 6 ## $ table_name &lt;chr&gt; &quot;actor_info&quot;, &quot;actor_info&quot;, &quot;actor_in... ## $ column_name &lt;chr&gt; &quot;actor_id&quot;, &quot;first_name&quot;, &quot;last_name&quot;... ## $ data_type &lt;chr&gt; &quot;integer&quot;, &quot;character varying&quot;, &quot;char... ## $ ordinal_position &lt;int&gt; 1, 2, 3, 4, 1, 2, 3, 4, 5, 6, 7, 8, 9... ## $ column_default &lt;chr&gt; NA, NA, NA, NA, NA, NA, NA, NA, NA, N... ## $ character_maximum_length &lt;int&gt; NA, 45, 45, NA, NA, NA, 50, 10, 20, 5... Pull out some rough-and-ready but useful statistics about your database. Since we are in SQL-land we talk about variables as columns. Start with a list of tables names and a count of the number of columns that each one contains. rental_meta_data %&gt;% count(table_name) %&gt;% rename(number_of_columns = n) %&gt;% as.data.frame() ## table_name number_of_columns ## 1 actor 4 ## 2 actor_info 4 ## 3 address 8 ## 4 category 3 ## 5 city 4 ## 6 country 3 ## 7 customer 10 ## 8 customer_list 9 ## 9 film 13 ## 10 film_actor 3 ## 11 film_category 3 ## 12 film_list 8 ## 13 inventory 4 ## 14 language 3 ## 15 nicer_but_slower_film_list 8 ## 16 payment 6 ## 17 rental 7 ## 18 sales_by_film_category 2 ## 19 sales_by_store 3 ## 20 staff 11 ## 21 staff_list 8 ## 22 store 4 How many column names are shared across tables (or duplicated)? rental_meta_data %&gt;% count(column_name, sort = TRUE) %&gt;% filter(n &gt; 1) ## # A tibble: 34 x 2 ## column_name n ## &lt;chr&gt; &lt;int&gt; ## 1 last_update 14 ## 2 address_id 4 ## 3 film_id 4 ## 4 first_name 4 ## 5 last_name 4 ## 6 name 4 ## 7 store_id 4 ## 8 actor_id 3 ## 9 address 3 ## 10 category 3 ## # ... with 24 more rows How many column names are unique? rental_meta_data %&gt;% count(column_name) %&gt;% filter(n &gt; 1) ## # A tibble: 34 x 2 ## column_name n ## &lt;chr&gt; &lt;int&gt; ## 1 active 2 ## 2 actor_id 3 ## 3 actors 2 ## 4 address 3 ## 5 address_id 4 ## 6 category 3 ## 7 category_id 2 ## 8 city 3 ## 9 city_id 2 ## 10 country 3 ## # ... with 24 more rows What data types are found in the database? rental_meta_data %&gt;% count(data_type) ## # A tibble: 13 x 2 ## data_type n ## &lt;chr&gt; &lt;int&gt; ## 1 ARRAY 1 ## 2 boolean 2 ## 3 bytea 1 ## 4 character 1 ## 5 character varying 36 ## 6 date 1 ## 7 integer 22 ## 8 numeric 7 ## 9 smallint 25 ## 10 text 11 ## 11 timestamp without time zone 17 ## 12 tsvector 1 ## 13 USER-DEFINED 3 "],
["real-work-with-real-data.html", "Chapter 8 Real work with real data 8.1 Some extra handy libraries 8.2 Basic investigation 8.3 Using Dplyr 8.4 What is dplyr sending to the server? 8.5 Writing your on SQL directly to the DBMS 8.6 Chosing between dplyr and native SQL", " Chapter 8 Real work with real data 8.1 Some extra handy libraries Here are some packages that we find handy in the preliminary investigation of a database (or a problem that involves data from a databse). library(glue) library(skimr) 8.2 Basic investigation R tools for data investigation glimpse str View and kable overview investigation: do you understand your data documentation and its limits what’s missing from the database: (columns, records, cells) find out how the data is used by those who enter it and others who’ve used it before why is there missing data? 8.3 Using Dplyr We already started, but that’s OK. 8.3.1 finding out what’s in the database DBI / RPostgres packaages R tools like glimpse, skimr, kable. examining dplyr queries (show_query on the R side v EXPLAIN on the Postges side) Tutorials like: https://suzan.rbind.io/tags/dplyr/ Benjamin S. Baumer, A Grammar for Reproducible and Painless Extract-Transform-Load Operations on Medium Data: https://arxiv.org/pdf/1708.07073 8.3.2 sample query rental date subset left join staff left join customer 8.3.3 Subset: only retrieve what you need Columns Rows number of row specific rows dplyr joins in the R 8.3.4 Make the server do as much work as you can discuss this simple example? http://www.postgresqltutorial.com/postgresql-left-join/ dplyr joins on the server side Where you put (collect(n = Inf)) really matters 8.4 What is dplyr sending to the server? show_query as a first draft 8.5 Writing your on SQL directly to the DBMS dbquery Glue for constructing SQL statements parameterizing SQL queries 8.6 Chosing between dplyr and native SQL performance considerations: first get the right data, then worory about performance Tradeoffs between leaving the data in Postgres vs what’s kept in R: browsing the data larger samples and complete tables using what you know to write efficient queries that do most of the work on the server "],
["real-work-with-real-data-1.html", "Chapter 9 Real work with real data 9.1 Some extra handy libraries 9.2 More topics 9.3 Standards for production jobs", " Chapter 9 Real work with real data 9.1 Some extra handy libraries Here are some packages that we find handy in the preliminary investigation of a database (or a problem that involves data from a databse). library(glue) ## ## Attaching package: &#39;glue&#39; ## The following object is masked from &#39;package:dplyr&#39;: ## ## collapse library(skimr) 9.2 More topics Check this against Aaron Makubuya’s workshop at the Cascadia R Conf. 9.3 Standards for production jobs writing tests for you rqueries "],
["postgres-examples-part-a.html", "Chapter 10 Postgres Examples, part A 10.1 Verify Docker is up and running:", " Chapter 10 Postgres Examples, part A Libraries loaded and functions are loaded 10.1 Verify Docker is up and running: result &lt;- system2(&quot;docker&quot;, &quot;version&quot;, stdout = TRUE, stderr = TRUE) result ## [1] &quot;Client:&quot; ## [2] &quot; Version: 18.06.1-ce&quot; ## [3] &quot; API version: 1.38&quot; ## [4] &quot; Go version: go1.10.3&quot; ## [5] &quot; Git commit: e68fc7a&quot; ## [6] &quot; Built: Tue Aug 21 17:21:31 2018&quot; ## [7] &quot; OS/Arch: darwin/amd64&quot; ## [8] &quot; Experimental: false&quot; ## [9] &quot;&quot; ## [10] &quot;Server:&quot; ## [11] &quot; Engine:&quot; ## [12] &quot; Version: 18.06.1-ce&quot; ## [13] &quot; API version: 1.38 (minimum version 1.12)&quot; ## [14] &quot; Go version: go1.10.3&quot; ## [15] &quot; Git commit: e68fc7a&quot; ## [16] &quot; Built: Tue Aug 21 17:29:02 2018&quot; ## [17] &quot; OS/Arch: linux/amd64&quot; ## [18] &quot; Experimental: true&quot; verify pet DB is available, it may be stopped. result &lt;- system2(&quot;docker&quot;, &quot;ps -a&quot;, stdout = TRUE, stderr = TRUE) result ## [1] &quot;CONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES&quot; ## [2] &quot;909fb5a40ccf postgres:10 \\&quot;docker-entrypoint.s…\\&quot; 26 seconds ago Up 5 seconds 0.0.0.0:5432-&gt;5432/tcp sql-pet&quot; any(grepl(&#39;Up .+pet$&#39;,result)) ## [1] TRUE Start up the docker-pet container result &lt;- system2(&quot;docker&quot;, &quot;start sql-pet&quot;, stdout = TRUE, stderr = TRUE) result ## [1] &quot;sql-pet&quot; now connect to the database with R # need to wait for Docker &amp; Postgres to come up before connecting. con &lt;- wait_for_postgres(user = Sys.getenv(&quot;DEFAULT_POSTGRES_USER_NAME&quot;), password = Sys.getenv(&quot;DEFAULT_POSTGRES_PASSWORD&quot;), dbname = &quot;dvdrental&quot;, seconds_to_test = 10) ## Get list of database objects rs &lt;- dbGetQuery(con ,&quot;select table_catalog,table_schema,table_name,table_type from information_schema.tables where table_schema not in (&#39;pg_catalog&#39;,&#39;information_schema&#39;) order by table_name ;&quot; ) # Get list of tables kable(dbListTables(con)) x actor_info customer_list film_list nicer_but_slower_film_list sales_by_film_category staff sales_by_store staff_list category film_category country actor language inventory payment rental city store film address film_actor customer rs &lt;- dbGetQuery(con ,&quot;select table_catalog||&#39;.&#39;||table_schema||&#39;.&#39;||table_name table_name ,column_name,ordinal_position seq --,data_type ,case when data_type = &#39;character varying&#39; then data_type || &#39;(&#39;|| character_maximum_length||&#39;)&#39; when data_type = &#39;real&#39; then data_type || &#39;(&#39; || numeric_precision ||&#39;,&#39;||numeric_precision_radix||&#39;)&#39; else data_type end data_type -- ,character_maximum_length,numeric_precision,numeric_precision_radix from information_schema.columns where table_name in (select table_name from information_schema.tables where table_schema not in (&#39;pg_catalog&#39;,&#39;information_schema&#39;) ) order by table_name,ordinal_position; ;&quot; ) kable(head(rs, n = 20)) table_name column_name seq data_type dvdrental.public.actor actor_id 1 integer dvdrental.public.actor first_name 2 character varying(45) dvdrental.public.actor last_name 3 character varying(45) dvdrental.public.actor last_update 4 timestamp without time zone dvdrental.public.actor_info actor_id 1 integer dvdrental.public.actor_info first_name 2 character varying(45) dvdrental.public.actor_info last_name 3 character varying(45) dvdrental.public.actor_info film_info 4 text dvdrental.public.address address_id 1 integer dvdrental.public.address address 2 character varying(50) dvdrental.public.address address2 3 character varying(50) dvdrental.public.address district 4 character varying(20) dvdrental.public.address city_id 5 smallint dvdrental.public.address postal_code 6 character varying(10) dvdrental.public.address phone 7 character varying(20) dvdrental.public.address last_update 8 timestamp without time zone dvdrental.public.category category_id 1 integer dvdrental.public.category name 2 character varying(25) dvdrental.public.category last_update 3 timestamp without time zone dvdrental.public.city city_id 1 integer There are {r dim(rs)[1]} rows in the catalog . rs &lt;- dbGetQuery(con, &quot; --SELECT conrelid::regclass as table_from select table_catalog||&#39;.&#39;||table_schema||&#39;.&#39;||table_name table_name ,conname,pg_catalog.pg_get_constraintdef(r.oid, true) as condef FROM information_schema.columns c,pg_catalog.pg_constraint r WHERE 1 = 1 --r.conrelid = &#39;16485&#39; AND r.contype in (&#39;f&#39;,&#39;p&#39;) ORDER BY 1 ;&quot; ) kable(head(rs)) table_name conname condef dvdrental.information_schema.administrable_role_authorizations actor_pkey PRIMARY KEY (actor_id) dvdrental.information_schema.administrable_role_authorizations actor_pkey PRIMARY KEY (actor_id) dvdrental.information_schema.administrable_role_authorizations actor_pkey PRIMARY KEY (actor_id) dvdrental.information_schema.administrable_role_authorizations country_pkey PRIMARY KEY (country_id) dvdrental.information_schema.administrable_role_authorizations country_pkey PRIMARY KEY (country_id) dvdrental.information_schema.administrable_role_authorizations country_pkey PRIMARY KEY (country_id) rs &lt;- dbGetQuery(con, &quot;select conrelid::regclass as table_from ,c.conname ,pg_get_constraintdef(c.oid) from pg_constraint c join pg_namespace n on n.oid = c.connamespace where c.contype in (&#39;f&#39;,&#39;p&#39;) and n.nspname = &#39;public&#39; order by conrelid::regclass::text, contype DESC; &quot;) kable(head(rs)) table_from conname pg_get_constraintdef actor actor_pkey PRIMARY KEY (actor_id) address address_pkey PRIMARY KEY (address_id) address fk_address_city FOREIGN KEY (city_id) REFERENCES city(city_id) category category_pkey PRIMARY KEY (category_id) city city_pkey PRIMARY KEY (city_id) city fk_city FOREIGN KEY (country_id) REFERENCES country(country_id) dim(rs)[1] ## [1] 33 rs &lt;- dbGetQuery(con, &quot;SELECT r.*, pg_catalog.pg_get_constraintdef(r.oid, true) as condef FROM pg_catalog.pg_constraint r WHERE 1=1 --r.conrelid = &#39;16485&#39; AND r.contype = &#39;f&#39; ORDER BY 1; &quot;) head(rs) ## conname connamespace contype condeferrable ## 1 cardinal_number_domain_check 12703 c FALSE ## 2 yes_or_no_check 12703 c FALSE ## 3 year_check 2200 c FALSE ## 4 actor_pkey 2200 p FALSE ## 5 address_pkey 2200 p FALSE ## 6 category_pkey 2200 p FALSE ## condeferred convalidated conrelid contypid conindid confrelid ## 1 FALSE TRUE 0 12716 0 0 ## 2 FALSE TRUE 0 12724 0 0 ## 3 FALSE TRUE 0 16397 0 0 ## 4 FALSE TRUE 16420 0 16555 0 ## 5 FALSE TRUE 16461 0 16557 0 ## 6 FALSE TRUE 16427 0 16559 0 ## confupdtype confdeltype confmatchtype conislocal coninhcount ## 1 TRUE 0 ## 2 TRUE 0 ## 3 TRUE 0 ## 4 TRUE 0 ## 5 TRUE 0 ## 6 TRUE 0 ## connoinherit conkey confkey conpfeqop conppeqop conffeqop conexclop ## 1 FALSE &lt;NA&gt; &lt;NA&gt; &lt;NA&gt; &lt;NA&gt; &lt;NA&gt; &lt;NA&gt; ## 2 FALSE &lt;NA&gt; &lt;NA&gt; &lt;NA&gt; &lt;NA&gt; &lt;NA&gt; &lt;NA&gt; ## 3 FALSE &lt;NA&gt; &lt;NA&gt; &lt;NA&gt; &lt;NA&gt; &lt;NA&gt; &lt;NA&gt; ## 4 TRUE {1} &lt;NA&gt; &lt;NA&gt; &lt;NA&gt; &lt;NA&gt; &lt;NA&gt; ## 5 TRUE {1} &lt;NA&gt; &lt;NA&gt; &lt;NA&gt; &lt;NA&gt; &lt;NA&gt; ## 6 TRUE {1} &lt;NA&gt; &lt;NA&gt; &lt;NA&gt; &lt;NA&gt; &lt;NA&gt; ## conbin ## 1 {OPEXPR :opno 525 :opfuncid 150 :opresulttype 16 :opretset false :opcollid 0 :inputcollid 0 :args ({COERCETODOMAINVALUE :typeId 23 :typeMod -1 :collation 0 :location 195} {CONST :consttype 23 :consttypmod -1 :constcollid 0 :constlen 4 :constbyval true :constisnull false :location 204 :constvalue 4 [ 0 0 0 0 0 0 0 0 ]}) :location 201} ## 2 {SCALARARRAYOPEXPR :opno 98 :opfuncid 67 :useOr true :inputcollid 100 :args ({RELABELTYPE :arg {COERCETODOMAINVALUE :typeId 1043 :typeMod 7 :collation 100 :location 121} :resulttype 25 :resulttypmod -1 :resultcollid 100 :relabelformat 2 :location -1} {ARRAYCOERCEEXPR :arg {ARRAY :array_typeid 1015 :array_collid 100 :element_typeid 1043 :elements ({CONST :consttype 1043 :consttypmod -1 :constcollid 100 :constlen -1 :constbyval false :constisnull false :location 131 :constvalue 7 [ 28 0 0 0 89 69 83 ]} {CONST :consttype 1043 :consttypmod -1 :constcollid 100 :constlen -1 :constbyval false :constisnull false :location 138 :constvalue 6 [ 24 0 0 0 78 79 ]}) :multidims false :location -1} :elemfuncid 0 :resulttype 1009 :resulttypmod -1 :resultcollid 100 :isExplicit false :coerceformat 2 :location -1}) :location 127} ## 3 {BOOLEXPR :boolop and :args ({OPEXPR :opno 525 :opfuncid 150 :opresulttype 16 :opretset false :opcollid 0 :inputcollid 0 :args ({COERCETODOMAINVALUE :typeId 23 :typeMod -1 :collation 0 :location 62} {CONST :consttype 23 :consttypmod -1 :constcollid 0 :constlen 4 :constbyval true :constisnull false :location 71 :constvalue 4 [ 109 7 0 0 0 0 0 0 ]}) :location 68} {OPEXPR :opno 523 :opfuncid 149 :opresulttype 16 :opretset false :opcollid 0 :inputcollid 0 :args ({COERCETODOMAINVALUE :typeId 23 :typeMod -1 :collation 0 :location 82} {CONST :consttype 23 :consttypmod -1 :constcollid 0 :constlen 4 :constbyval true :constisnull false :location 91 :constvalue 4 [ 107 8 0 0 0 0 0 0 ]}) :location 88}) :location 77} ## 4 &lt;NA&gt; ## 5 &lt;NA&gt; ## 6 &lt;NA&gt; ## consrc ## 1 (VALUE &gt;= 0) ## 2 ((VALUE)::text = ANY ((ARRAY[&#39;YES&#39;::character varying, &#39;NO&#39;::character varying])::text[])) ## 3 ((VALUE &gt;= 1901) AND (VALUE &lt;= 2155)) ## 4 &lt;NA&gt; ## 5 &lt;NA&gt; ## 6 &lt;NA&gt; ## condef ## 1 CHECK (VALUE &gt;= 0) ## 2 CHECK (VALUE::text = ANY (ARRAY[&#39;YES&#39;::character varying, &#39;NO&#39;::character varying]::text[])) ## 3 CHECK (VALUE &gt;= 1901 AND VALUE &lt;= 2155) ## 4 PRIMARY KEY (actor_id) ## 5 PRIMARY KEY (address_id) ## 6 PRIMARY KEY (category_id) ## select examples ## dbGetQuery returns the entire result set as a data frame. ## For large returned datasets, complex or inefficient SQL statements, this may take a ## long time. ## dbSendQuery: parses, compiles, creates the optimized execution plan. ## dbFetch: Execute optimzed execution plan and return the dataset. ## dbClearResult:remove pending query results from the database to your R environment How many customers are there in the DVD Rental System rs1 &lt;- dbGetQuery(con,&#39;select * from customer;&#39;) kable(head(rs1)) customer_id store_id first_name last_name email address_id activebool create_date last_update active 524 1 Jared Ely jared.ely@sakilacustomer.org 530 TRUE 2006-02-14 2013-05-26 14:49:45 1 1 1 Mary Smith mary.smith@sakilacustomer.org 5 TRUE 2006-02-14 2013-05-26 14:49:45 1 2 1 Patricia Johnson patricia.johnson@sakilacustomer.org 6 TRUE 2006-02-14 2013-05-26 14:49:45 1 3 1 Linda Williams linda.williams@sakilacustomer.org 7 TRUE 2006-02-14 2013-05-26 14:49:45 1 4 2 Barbara Jones barbara.jones@sakilacustomer.org 8 TRUE 2006-02-14 2013-05-26 14:49:45 1 5 1 Elizabeth Brown elizabeth.brown@sakilacustomer.org 9 TRUE 2006-02-14 2013-05-26 14:49:45 1 pco &lt;- dbSendQuery(con,&#39;select * from customer;&#39;) rs2 &lt;- dbFetch(pco) dbClearResult(pco) kable(head(rs2)) customer_id store_id first_name last_name email address_id activebool create_date last_update active 524 1 Jared Ely jared.ely@sakilacustomer.org 530 TRUE 2006-02-14 2013-05-26 14:49:45 1 1 1 Mary Smith mary.smith@sakilacustomer.org 5 TRUE 2006-02-14 2013-05-26 14:49:45 1 2 1 Patricia Johnson patricia.johnson@sakilacustomer.org 6 TRUE 2006-02-14 2013-05-26 14:49:45 1 3 1 Linda Williams linda.williams@sakilacustomer.org 7 TRUE 2006-02-14 2013-05-26 14:49:45 1 4 2 Barbara Jones barbara.jones@sakilacustomer.org 8 TRUE 2006-02-14 2013-05-26 14:49:45 1 5 1 Elizabeth Brown elizabeth.brown@sakilacustomer.org 9 TRUE 2006-02-14 2013-05-26 14:49:45 1 # insert yourself as a new customer dbExecute(con ,&quot;insert into customer (store_id,first_name,last_name,email,address_id ,activebool,create_date,last_update,active) values(2,&#39;Sophie&#39;,&#39;Yang&#39;,&#39;dodreamdo@yahoo.com&#39;,1,TRUE,&#39;2018-09-13&#39;,&#39;2018-09-13&#39;,1) returning customer_id; &quot; ) ## [1] 0 ## anti join -- Find customers who have never rented a movie. rs &lt;- dbGetQuery(con, &quot;select c.first_name ,c.last_name ,c.email from customer c left outer join rental r on c.customer_id = r.customer_id where r.rental_id is null; &quot; ) head(rs) ## first_name last_name email ## 1 Sophie Yang dodreamdo@yahoo.com ## how many films and languages exist in the DVD rental application rs &lt;- dbGetQuery(con, &quot; select &#39;film&#39; table_name,count(*) count from film union select &#39;language&#39; table_name,count(*) count from language ; &quot; ) head(rs) ## table_name count ## 1 film 1000 ## 2 language 6 ## what is the film distribution based on language rs &lt;- dbGetQuery(con, &quot;select l.language_id id ,l.name ,sum(case when f.language_id is not null then 1 else 0 end) total from language l full outer join film f on l.language_id = f.language_id group by l.language_id,l.name order by l.name; ; &quot; ) head(rs) ## id name total ## 1 1 English 1000 ## 2 5 French 0 ## 3 6 German 0 ## 4 2 Italian 0 ## 5 3 Japanese 0 ## 6 4 Mandarin 0 ## Store analysis ### which store has had more rentals and income rs &lt;- dbGetQuery(con, &quot;select * from ( select &#39;actor&#39; tbl_name,count(*) from actor union select &#39;category&#39; tbl_name,count(*) from category union select &#39;film&#39; tbl_name,count(*) from film union select &#39;film_actor&#39; tbl_name,count(*) from film_actor union select &#39;film_category&#39; tbl_name,count(*) from film_category union select &#39;language&#39; tbl_name,count(*) from language union select &#39;inventory&#39; tbl_name,count(*) from inventory union select &#39;rental&#39; tbl_name,count(*) from rental union select &#39;payment&#39; tbl_name,count(*) from payment union select &#39;staff&#39; tbl_name,count(*) from staff union select &#39;customer&#39; tbl_name,count(*) from customer union select &#39;address&#39; tbl_name,count(*) from address union select &#39;city&#39; tbl_name,count(*) from city union select &#39;country&#39; tbl_name,count(*) from country union select &#39;store&#39; tbl_name,count(*) from store ) counts order by tbl_name ; &quot; ) head(rs) ## tbl_name count ## 1 actor 200 ## 2 address 603 ## 3 category 16 ## 4 city 600 ## 5 country 109 ## 6 customer 600 ## Store analysis ### which store has the largest income stream rs &lt;- dbGetQuery(con, &quot;select store_id,sum(amount) amt,count(*) cnt from payment p join staff s on p.staff_id = s.staff_id group by store_id order by 2 desc ; &quot; ) head(rs) ## store_id amt cnt ## 1 2 31059.92 7304 ## 2 1 30252.12 7292 ## Store analysis ### How many rentals have not been paid ### How many rentals have been paid ### How much has been paid ### What is the average price/movie ### Estimate the outstanding balance rs &lt;- dbGetQuery(con, &quot;select sum(case when payment_id is null then 1 else 0 end) missing ,sum(case when payment_id is not null then 1 else 0 end) found ,sum(p.amount) amt ,count(*) cnt ,round(sum(p.amount)/sum(case when payment_id is not null then 1 else 0 end),2) avg_price ,round(round(sum(p.amount)/sum(case when payment_id is not null then 1 else 0 end),2) * sum(case when payment_id is null then 1 else 0 end),2) est_balance from rental r left outer join payment p on r.rental_id = p.rental_id ; &quot; ) head(rs) ## missing found amt cnt avg_price est_balance ## 1 1452 14596 61312.04 16048 4.2 6098.4 ### what is the actual outstanding balance rs &lt;- dbGetQuery(con, &quot;select sum(f.rental_rate) open_amt,count(*) count from rental r left outer join payment p on r.rental_id = p.rental_id join inventory i on r.inventory_id = i.inventory_id join film f on i.film_id = f.film_id where p.rental_id is null ;&quot; ) head(rs) ## open_amt count ## 1 4297.48 1452 ### Rank customers with highest open amounts rs &lt;- dbGetQuery(con, &quot;select c.customer_id,c.first_name,c.last_name,sum(f.rental_rate) open_amt,count(*) count from rental r left outer join payment p on r.rental_id = p.rental_id join inventory i on r.inventory_id = i.inventory_id join film f on i.film_id = f.film_id join customer c on r.customer_id = c.customer_id where p.rental_id is null group by c.customer_id,c.first_name,c.last_name order by open_amt desc limit 25 ;&quot; ) head(rs) ## customer_id first_name last_name open_amt count ## 1 293 Mae Fletcher 35.90 10 ## 2 307 Joseph Joy 31.90 10 ## 3 316 Steven Curley 31.90 10 ## 4 299 James Gannon 30.91 9 ## 5 274 Naomi Jennings 29.92 8 ## 6 326 Jose Andrew 28.93 7 ### what film has been rented the most rs &lt;- dbGetQuery(con, &quot;select i.film_id,f.title,rental_rate,sum(rental_rate) revenue,count(*) count --16044 from rental r join inventory i on r.inventory_id = i.inventory_id join film f on i.film_id = f.film_id group by i.film_id,f.title,rental_rate order by count desc ;&quot; ) head(rs) ## film_id title rental_rate revenue count ## 1 103 Bucket Brotherhood 4.99 169.66 34 ## 2 738 Rocketeer Mother 0.99 32.67 33 ## 3 382 Grit Clockwork 0.99 31.68 32 ## 4 767 Scalawag Duck 4.99 159.68 32 ## 5 489 Juggler Hardly 0.99 31.68 32 ## 6 730 Ridgemont Submarine 0.99 31.68 32 ### what film has been generated the most revenue assuming all amounts are collected rs &lt;- dbGetQuery(con, &quot;select i.film_id,f.title,rental_rate ,sum(rental_rate) revenue,count(*) count --16044 from rental r join inventory i on r.inventory_id = i.inventory_id join film f on i.film_id = f.film_id group by i.film_id,f.title,rental_rate order by revenue desc ;&quot; ) head(rs) ## film_id title rental_rate revenue count ## 1 103 Bucket Brotherhood 4.99 169.66 34 ## 2 767 Scalawag Duck 4.99 159.68 32 ## 3 973 Wife Turn 4.99 154.69 31 ## 4 31 Apache Divine 4.99 154.69 31 ## 5 369 Goodfellas Salute 4.99 154.69 31 ## 6 1000 Zorro Ark 4.99 154.69 31 ### which films are in one store but not the other. rs &lt;- dbGetQuery(con, &quot;select coalesce(i1.film_id,i2.film_id) film_id ,f.title,f.rental_rate,i1.store_id,i1.count,i2.store_id,i2.count from (select film_id,store_id,count(*) count from inventory where store_id = 1 group by film_id,store_id) as i1 full outer join (select film_id,store_id,count(*) count from inventory where store_id = 2 group by film_id,store_id ) as i2 on i1.film_id = i2.film_id join film f on coalesce(i1.film_id,i2.film_id) = f.film_id where i1.film_id is null or i2.film_id is null order by f.title ; &quot; ) head(rs) ## film_id title rental_rate store_id count store_id..6 ## 1 2 Ace Goldfinger 4.99 NA &lt;NA&gt; 2 ## 2 3 Adaptation Holes 2.99 NA &lt;NA&gt; 2 ## 3 5 African Egg 2.99 NA &lt;NA&gt; 2 ## 4 8 Airport Pollock 4.99 NA &lt;NA&gt; 2 ## 5 13 Ali Forever 4.99 NA &lt;NA&gt; 2 ## 6 20 Amelie Hellfighters 4.99 1 3 NA ## count..7 ## 1 3 ## 2 4 ## 3 3 ## 4 4 ## 5 4 ## 6 &lt;NA&gt; # Compute the outstanding balance. rs &lt;- dbGetQuery(con, &quot;select sum(f.rental_rate) open_amt,count(*) count from rental r left outer join payment p on r.rental_id = p.rental_id join inventory i on r.inventory_id = i.inventory_id join film f on i.film_id = f.film_id where p.rental_id is null ;&quot; ) head(rs) ## open_amt count ## 1 4297.48 1452 list what’s there dbListTables(con) ## [1] &quot;actor_info&quot; &quot;customer_list&quot; ## [3] &quot;film_list&quot; &quot;nicer_but_slower_film_list&quot; ## [5] &quot;sales_by_film_category&quot; &quot;staff&quot; ## [7] &quot;sales_by_store&quot; &quot;staff_list&quot; ## [9] &quot;category&quot; &quot;film_category&quot; ## [11] &quot;country&quot; &quot;actor&quot; ## [13] &quot;language&quot; &quot;inventory&quot; ## [15] &quot;payment&quot; &quot;rental&quot; ## [17] &quot;city&quot; &quot;store&quot; ## [19] &quot;film&quot; &quot;address&quot; ## [21] &quot;film_actor&quot; &quot;customer&quot; Clean up # dbRemoveTable(con, &quot;cars&quot;) # dbRemoveTable(con, &quot;mtcars&quot;) # dbRemoveTable(con, &quot;cust_movies&quot;) # diconnect from the db dbDisconnect(con) result &lt;- system2(&quot;docker&quot;, &quot;stop sql-pet&quot;, stdout = TRUE, stderr = TRUE) result ## [1] &quot;sql-pet&quot; "],
["postgres-examples-part-b.html", "Chapter 11 Postgres Examples, part B 11.1 Verify Docker is up and running: 11.2 SQL Execution Steps", " Chapter 11 Postgres Examples, part B 11.1 Verify Docker is up and running: result &lt;- system2(&quot;docker&quot;, &quot;version&quot;, stdout = TRUE, stderr = TRUE) result ## [1] &quot;Client:&quot; ## [2] &quot; Version: 18.06.1-ce&quot; ## [3] &quot; API version: 1.38&quot; ## [4] &quot; Go version: go1.10.3&quot; ## [5] &quot; Git commit: e68fc7a&quot; ## [6] &quot; Built: Tue Aug 21 17:21:31 2018&quot; ## [7] &quot; OS/Arch: darwin/amd64&quot; ## [8] &quot; Experimental: false&quot; ## [9] &quot;&quot; ## [10] &quot;Server:&quot; ## [11] &quot; Engine:&quot; ## [12] &quot; Version: 18.06.1-ce&quot; ## [13] &quot; API version: 1.38 (minimum version 1.12)&quot; ## [14] &quot; Go version: go1.10.3&quot; ## [15] &quot; Git commit: e68fc7a&quot; ## [16] &quot; Built: Tue Aug 21 17:29:02 2018&quot; ## [17] &quot; OS/Arch: linux/amd64&quot; ## [18] &quot; Experimental: true&quot; verify pet DB is available, it may be stopped. result &lt;- system2(&quot;docker&quot;, &quot;ps -a&quot;, stdout = TRUE, stderr = TRUE) result ## [1] &quot;CONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES&quot; ## [2] &quot;909fb5a40ccf postgres:10 \\&quot;docker-entrypoint.s…\\&quot; 30 seconds ago Exited (0) 2 seconds ago sql-pet&quot; any(grepl(&#39;Up .+pet$&#39;,result)) ## [1] FALSE Start up the docker-pet container result &lt;- system2(&quot;docker&quot;, &quot;start sql-pet&quot;, stdout = TRUE, stderr = TRUE) result ## [1] &quot;sql-pet&quot; now connect to the database with R con &lt;- wait_for_postgres(user = Sys.getenv(&quot;DEFAULT_POSTGRES_USER_NAME&quot;), password = Sys.getenv(&quot;DEFAULT_POSTGRES_PASSWORD&quot;), dbname = &quot;dvdrental&quot;, seconds_to_test = 10) ## meta data: check existence of a table rs1 &lt;- dbGetQuery(con ,&quot;SELECT c.* FROM pg_catalog.pg_class c JOIN pg_catalog.pg_namespace n ON n.oid = c.relnamespace WHERE n.nspname = &#39;public&#39; AND c.relname = &#39;cust_movies&#39; AND c.relkind = &#39;r&#39; ; &quot; ) head(rs1) ## [1] relname relnamespace reltype ## [4] reloftype relowner relam ## [7] relfilenode reltablespace relpages ## [10] reltuples relallvisible reltoastrelid ## [13] relhasindex relisshared relpersistence ## [16] relkind relnatts relchecks ## [19] relhasoids relhaspkey relhasrules ## [22] relhastriggers relhassubclass relrowsecurity ## [25] relforcerowsecurity relispopulated relreplident ## [28] relispartition relfrozenxid relminmxid ## [31] relacl reloptions relpartbound ## &lt;0 rows&gt; (or 0-length row.names) ## create table via SQL statement rs &lt;- dbGetQuery(con ,&#39;CREATE TABLE cust_movies AS select c.customer_id ,first_name ,last_name,title ,description from customer c join rental r on c.customer_id = r.customer_id join inventory i on r.inventory_id = i.inventory_id join film f on i.film_id = f.film_id order by last_name,first_name; &#39; ) ## Warning in result_fetch(res@ptr, n = n): Don&#39;t need to call dbFetch() for ## statements, only for queries head(rs) ## data frame with 0 columns and 0 rows Moved the following lines from #13 ## how many customers are there in the DVD Rental System rs1 &lt;- dbGetQuery(con,&#39;select * from customer;&#39;) kable(head(rs1)) customer_id store_id first_name last_name email address_id activebool create_date last_update active 524 1 Jared Ely jared.ely@sakilacustomer.org 530 TRUE 2006-02-14 2013-05-26 14:49:45 1 1 1 Mary Smith mary.smith@sakilacustomer.org 5 TRUE 2006-02-14 2013-05-26 14:49:45 1 2 1 Patricia Johnson patricia.johnson@sakilacustomer.org 6 TRUE 2006-02-14 2013-05-26 14:49:45 1 3 1 Linda Williams linda.williams@sakilacustomer.org 7 TRUE 2006-02-14 2013-05-26 14:49:45 1 4 2 Barbara Jones barbara.jones@sakilacustomer.org 8 TRUE 2006-02-14 2013-05-26 14:49:45 1 5 1 Elizabeth Brown elizabeth.brown@sakilacustomer.org 9 TRUE 2006-02-14 2013-05-26 14:49:45 1 pco &lt;- dbSendQuery(con,&#39;select * from customer;&#39;) rs2 &lt;- dbFetch(pco) dbClearResult(pco) kable(head(rs2)) customer_id store_id first_name last_name email address_id activebool create_date last_update active 524 1 Jared Ely jared.ely@sakilacustomer.org 530 TRUE 2006-02-14 2013-05-26 14:49:45 1 1 1 Mary Smith mary.smith@sakilacustomer.org 5 TRUE 2006-02-14 2013-05-26 14:49:45 1 2 1 Patricia Johnson patricia.johnson@sakilacustomer.org 6 TRUE 2006-02-14 2013-05-26 14:49:45 1 3 1 Linda Williams linda.williams@sakilacustomer.org 7 TRUE 2006-02-14 2013-05-26 14:49:45 1 4 2 Barbara Jones barbara.jones@sakilacustomer.org 8 TRUE 2006-02-14 2013-05-26 14:49:45 1 5 1 Elizabeth Brown elizabeth.brown@sakilacustomer.org 9 TRUE 2006-02-14 2013-05-26 14:49:45 1 pco &lt;- dbSendQuery(con,&quot;select * from customer where customer_id between $1 and $2&quot;) dbBind(pco,list(501,525)) rs2 &lt;- dbFetch(pco) dbClearResult(pco) kable(head(rs2)) customer_id store_id first_name last_name email address_id activebool create_date last_update active 524 1 Jared Ely jared.ely@sakilacustomer.org 530 TRUE 2006-02-14 2013-05-26 14:49:45 1 501 1 Ruben Geary ruben.geary@sakilacustomer.org 506 TRUE 2006-02-14 2013-05-26 14:49:45 1 502 1 Brett Cornwell brett.cornwell@sakilacustomer.org 507 TRUE 2006-02-14 2013-05-26 14:49:45 1 503 1 Angel Barclay angel.barclay@sakilacustomer.org 508 TRUE 2006-02-14 2013-05-26 14:49:45 1 504 1 Nathaniel Adam nathaniel.adam@sakilacustomer.org 509 TRUE 2006-02-14 2013-05-26 14:49:45 1 505 1 Rafael Abney rafael.abney@sakilacustomer.org 510 TRUE 2006-02-14 2013-05-26 14:49:45 1 rs1 &lt;- dbGetQuery(con, &quot;explain select r.* from rental r ;&quot; ) head(rs1) ## QUERY PLAN ## 1 Seq Scan on rental r (cost=0.00..310.44 rows=16044 width=36) rs2 &lt;- dbGetQuery(con, &quot;explain select count(*) count from rental r left outer join payment p on r.rental_id = p.rental_id where p.rental_id is null ;&quot;) head(rs2) ## QUERY PLAN ## 1 Aggregate (cost=2086.78..2086.80 rows=1 width=8) ## 2 -&gt; Merge Anti Join (cost=0.57..2066.73 rows=8022 width=0) ## 3 Merge Cond: (r.rental_id = p.rental_id) ## 4 -&gt; Index Only Scan using rental_pkey on rental r (cost=0.29..1024.95 rows=16044 width=4) ## 5 -&gt; Index Only Scan using idx_fk_rental_id on payment p (cost=0.29..819.23 rows=14596 width=4) rs3 &lt;- dbGetQuery(con, &quot;explain select sum(f.rental_rate) open_amt,count(*) count from rental r left outer join payment p on r.rental_id = p.rental_id join inventory i on r.inventory_id = i.inventory_id join film f on i.film_id = f.film_id where p.rental_id is null ;&quot;) head(rs3) ## QUERY PLAN ## 1 Aggregate (cost=2353.64..2353.65 rows=1 width=40) ## 2 -&gt; Hash Join (cost=205.14..2313.53 rows=8022 width=12) ## 3 Hash Cond: (i.film_id = f.film_id) ## 4 -&gt; Hash Join (cost=128.64..2215.88 rows=8022 width=2) ## 5 Hash Cond: (r.inventory_id = i.inventory_id) ## 6 -&gt; Merge Anti Join (cost=0.57..2066.73 rows=8022 width=4) rs4 &lt;- dbGetQuery(con, &quot;explain select c.customer_id,c.first_name,c.last_name,sum(f.rental_rate) open_amt,count(*) count from rental r left outer join payment p on r.rental_id = p.rental_id join inventory i on r.inventory_id = i.inventory_id join film f on i.film_id = f.film_id join customer c on r.customer_id = c.customer_id where p.rental_id is null group by c.customer_id,c.first_name,c.last_name order by open_amt desc ;&quot; ) head(rs4) ## QUERY PLAN ## 1 Sort (cost=2452.49..2453.99 rows=599 width=260) ## 2 Sort Key: (sum(f.rental_rate)) DESC ## 3 -&gt; HashAggregate (cost=2417.37..2424.86 rows=599 width=260) ## 4 Group Key: c.customer_id ## 5 -&gt; Hash Join (cost=227.62..2357.21 rows=8022 width=232) ## 6 Hash Cond: (r.customer_id = c.customer_id) 11.2 SQL Execution Steps Parse the incoming SQL query Compile the SQL query Plan/optimize the data acquisition path Execute the optimized query / acquire and return data dbWriteTable(con, &quot;mtcars&quot;, mtcars, overwrite = TRUE) rs &lt;- dbSendQuery(con, &quot;SELECT * FROM mtcars WHERE cyl = 4&quot;) dbFetch(rs) ## mpg cyl disp hp drat wt qsec vs am gear carb ## 1 22.8 4 108.0 93 3.85 2.320 18.61 1 1 4 1 ## 2 24.4 4 146.7 62 3.69 3.190 20.00 1 0 4 2 ## 3 22.8 4 140.8 95 3.92 3.150 22.90 1 0 4 2 ## 4 32.4 4 78.7 66 4.08 2.200 19.47 1 1 4 1 ## 5 30.4 4 75.7 52 4.93 1.615 18.52 1 1 4 2 ## 6 33.9 4 71.1 65 4.22 1.835 19.90 1 1 4 1 ## 7 21.5 4 120.1 97 3.70 2.465 20.01 1 0 3 1 ## 8 27.3 4 79.0 66 4.08 1.935 18.90 1 1 4 1 ## 9 26.0 4 120.3 91 4.43 2.140 16.70 0 1 5 2 ## 10 30.4 4 95.1 113 3.77 1.513 16.90 1 1 5 2 ## 11 21.4 4 121.0 109 4.11 2.780 18.60 1 1 4 2 dbClearResult(rs) #Pass one set of values with the param argument: rs &lt;- dbSendQuery(con,&quot;SELECT * FROM mtcars WHERE cyl = 4&quot;) dbFetch(rs) ## mpg cyl disp hp drat wt qsec vs am gear carb ## 1 22.8 4 108.0 93 3.85 2.320 18.61 1 1 4 1 ## 2 24.4 4 146.7 62 3.69 3.190 20.00 1 0 4 2 ## 3 22.8 4 140.8 95 3.92 3.150 22.90 1 0 4 2 ## 4 32.4 4 78.7 66 4.08 2.200 19.47 1 1 4 1 ## 5 30.4 4 75.7 52 4.93 1.615 18.52 1 1 4 2 ## 6 33.9 4 71.1 65 4.22 1.835 19.90 1 1 4 1 ## 7 21.5 4 120.1 97 3.70 2.465 20.01 1 0 3 1 ## 8 27.3 4 79.0 66 4.08 1.935 18.90 1 1 4 1 ## 9 26.0 4 120.3 91 4.43 2.140 16.70 0 1 5 2 ## 10 30.4 4 95.1 113 3.77 1.513 16.90 1 1 5 2 ## 11 21.4 4 121.0 109 4.11 2.780 18.60 1 1 4 2 dbClearResult(rs) # Pass multiple sets of values with dbBind(): rs &lt;- dbSendQuery(con, &quot;SELECT * FROM mtcars WHERE cyl = $1&quot;) dbBind(rs, list(6L)) # cyl = 6 dbFetch(rs) ## mpg cyl disp hp drat wt qsec vs am gear carb ## 1 21.0 6 160.0 110 3.90 2.620 16.46 0 1 4 4 ## 2 21.0 6 160.0 110 3.90 2.875 17.02 0 1 4 4 ## 3 21.4 6 258.0 110 3.08 3.215 19.44 1 0 3 1 ## 4 18.1 6 225.0 105 2.76 3.460 20.22 1 0 3 1 ## 5 19.2 6 167.6 123 3.92 3.440 18.30 1 0 4 4 ## 6 17.8 6 167.6 123 3.92 3.440 18.90 1 0 4 4 ## 7 19.7 6 145.0 175 3.62 2.770 15.50 0 1 5 6 dbBind(rs, list(8L)) # cyl = 8 dbFetch(rs) ## mpg cyl disp hp drat wt qsec vs am gear carb ## 1 18.7 8 360.0 175 3.15 3.440 17.02 0 0 3 2 ## 2 14.3 8 360.0 245 3.21 3.570 15.84 0 0 3 4 ## 3 16.4 8 275.8 180 3.07 4.070 17.40 0 0 3 3 ## 4 17.3 8 275.8 180 3.07 3.730 17.60 0 0 3 3 ## 5 15.2 8 275.8 180 3.07 3.780 18.00 0 0 3 3 ## 6 10.4 8 472.0 205 2.93 5.250 17.98 0 0 3 4 ## 7 10.4 8 460.0 215 3.00 5.424 17.82 0 0 3 4 ## 8 14.7 8 440.0 230 3.23 5.345 17.42 0 0 3 4 ## 9 15.5 8 318.0 150 2.76 3.520 16.87 0 0 3 2 ## 10 15.2 8 304.0 150 3.15 3.435 17.30 0 0 3 2 ## 11 13.3 8 350.0 245 3.73 3.840 15.41 0 0 3 4 ## 12 19.2 8 400.0 175 3.08 3.845 17.05 0 0 3 2 ## 13 15.8 8 351.0 264 4.22 3.170 14.50 0 1 5 4 ## 14 15.0 8 301.0 335 3.54 3.570 14.60 0 1 5 8 dbClearResult(rs) This is an example from the DBI help file dbWriteTable(con, &quot;cars&quot;, head(cars, 3)) # not to be confused with mtcars dbReadTable(con, &quot;cars&quot;) # there are 3 rows ## speed dist ## 1 4 2 ## 2 4 10 ## 3 7 4 dbExecute( con, &quot;INSERT INTO cars (speed, dist) VALUES (1, 1), (2, 2), (3, 3)&quot; ) ## [1] 3 dbReadTable(con, &quot;cars&quot;) # there are now 6 rows ## speed dist ## 1 4 2 ## 2 4 10 ## 3 7 4 ## 4 1 1 ## 5 2 2 ## 6 3 3 # Pass values using the param argument: dbExecute( con, &quot;INSERT INTO cars (speed, dist) VALUES ($1, $2)&quot;, param = list(4:7, 5:8) ) ## [1] 4 dbReadTable(con, &quot;cars&quot;) # there are now 10 rows ## speed dist ## 1 4 2 ## 2 4 10 ## 3 7 4 ## 4 1 1 ## 5 2 2 ## 6 3 3 ## 7 4 5 ## 8 5 6 ## 9 6 7 ## 10 7 8 Clean up dbRemoveTable(con, &quot;cars&quot;) dbRemoveTable(con, &quot;mtcars&quot;) dbRemoveTable(con, &quot;cust_movies&quot;) # diconnect from the db dbDisconnect(con) result &lt;- system2(&quot;docker&quot;, &quot;stop sql-pet&quot;, stdout = TRUE, stderr = TRUE) result ## [1] &quot;sql-pet&quot; "],
["other-resources.html", "Chapter 12 Other resources 12.1 Editing this book 12.2 Docker alternatives 12.3 Docker and R 12.4 Documentation Docker and Postgres 12.5 More Resources", " Chapter 12 Other resources 12.1 Editing this book Here are instructions for editing this tutorial 12.2 Docker alternatives Chosing between Docker and Vagrant 12.3 Docker and R Noam Ross’ talk on Docker for the UseR and his Slides give a lot of context and tips. Good Docker tutorials An introductory Docker tutorial A Docker curriculum Scott Came’s materials about Docker and R on his website and at the 2018 UseR Conference focus on R inside Docker. It’s worth studying the ROpensci Docker tutorial 12.4 Documentation Docker and Postgres The Postgres image documentation Dockerize PostgreSQL Postgres &amp; Docker documentation Usage examples of Postgres with Docker 12.5 More Resources David Severski describes some key elements of connecting to databases with R for MacOS users This tutorial picks up ideas and tips from Ed Borasky’s Data Science pet containers, which creates a framework based on that Hack Oregon example and explains why this repo is named pet-sql. "],
["references.html", "References", " References "]
]
