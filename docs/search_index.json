[
["chapter-connect-docker-postgresql-r.html", "Chapter 5 Connecting Docker, PostgreSQL, and R 5.1 Verify that Docker is running 5.2 Remove previous containers if they exist 5.3 Connecting, reading and writing to PostgreSQL from R 5.4 Clean up", " Chapter 5 Connecting Docker, PostgreSQL, and R This chapter demonstrates how to: Run, clean-up and close PostgreSQL in Docker containers. Keep necessary credentials secret while being available to R when it executes. Interact with PostgreSQL when it’s running inside a Docker container. Read and write to PostgreSQL from R. Please install the sqlpetr package if not already installed: library(devtools) if (!require(sqlpetr)) devtools::install_github(&quot;smithjd/sqlpetr&quot;, build_opts = &quot;&quot;) Note that when you install the package the first time, it will ask you to update the packages it uses and that can take some time. The following packages are used in this chapter: library(tidyverse) library(DBI) library(RPostgres) require(knitr) library(sqlpetr) 5.1 Verify that Docker is running Docker commands can be run from a terminal (e.g., the Rstudio Terminal pane) or with a system2() command. (We discuss the diffeent ways of interacting with Docker and other elements in your environment in a separate chapter.) The necessary functions to start, stop Docker containers and do other busy work are provided in the sqlpetr package. As time permits and curiosity dictates, feel free to look at those functions to see how they work. 5.1.1 Check that Docker is up and running Note: The sqlpetr package is written to accompany this book. The functions in the package are designed to help you focus on interacting with a dbms from R. You can ignore how they work until you are ready to delve into the details. They are all named to begin with sp_. The first time a function is called in the book, we provide a note explaining its use. The sp_check_that_docker_is_up function from the sqlpetr package checks whether Docker is up and running. If it’s not, then you need to install, launch or re-install Docker. sp_check_that_docker_is_up() ## [1] &quot;Docker is up but running no containers&quot; 5.2 Remove previous containers if they exist Force remove the cattle and sql-pet containers if they exist (e.g., from prior experiments). The sp_docker_remove_container function from the sqlpetr package forcibly removes a Docker container. If it is running it will be forcibly terminated and removed. If it doesn’t exist you won’t get an error message. Note that the images out of which a container is built will still exist on your system. sp_docker_remove_container(&quot;cattle&quot;) ## [1] 0 sp_docker_remove_container(&quot;sql-pet&quot;) ## [1] 0 We name containers cattle for “throw-aways” and pet for ones we treasure and keep around. :-) The sp_docker_remove_container function from the sqlpetr package creates a container and runs the PostgreSQL 10 image (docker.io/postgres:10) in it. The image will be downloaded if it doesn’t exist locally. sp_make_simple_pg(&quot;cattle&quot;) The first time you run this, Docker downloads the PostgreSQL image, which takes a bit of time. Did it work? The following command should show that a container named cattle is running postgres:10. sp_check_that_docker_is_up() ## [1] &quot;Docker is up, running these containers:&quot; ## [2] &quot;CONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES&quot; ## [3] &quot;419d5a8cefa9 postgres:10 \\&quot;docker-entrypoint.s…\\&quot; 1 second ago Up Less than a second 0.0.0.0:5432-&gt;5432/tcp cattle&quot; The sp_docker_containers_tibble function from the sqlpetr package provides more on the containers that Docker is running. Basically this function creates a tibble of containers using docker ps. sp_docker_containers_tibble() ## # A tibble: 1 x 12 ## container_id image command created_at created ports status size names ## &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; ## 1 419d5a8cefa9 post… docker… 2019-02-2… 1 seco… 0.0.… Up Le… 0B (… catt… ## # … with 3 more variables: labels &lt;chr&gt;, mounts &lt;chr&gt;, networks &lt;chr&gt; 5.3 Connecting, reading and writing to PostgreSQL from R 5.3.1 Connecting to PostgreSQL The sp_make_simple_pg function we called above created a container from the postgres:10 library image downloaded from Docker Hub. As part of the process, it set the password for the PostgreSQL database superuser postgres to the value “postgres”. For simplicity, we are using a weak password at this point and it’s shown here and in the code in plain text. That is bad practice because user credentials should not be shared in open code like that. A subsequent chapter demonstrates how to store and use credentials to access the DBMS so that they are kept private. The sp_get_postgres_connection function from the sqlpetr package gets a DBI connection string to a PostgreSQL database, waiting if it is not ready. This function connects to an instance of PostgreSQL and we assign it to a symbol, con, for subsequent use. con &lt;- sp_get_postgres_connection( host = &quot;localhost&quot;, port = 5432, user = &quot;postgres&quot;, password = &quot;postgres&quot;, dbname = &quot;postgres&quot;, seconds_to_test = 30 ) Make sure that you can connect to the PostgreSQL database that you have just started. If you have been executing the code from this tutorial, the database will not contain any tables yet: DBI::dbListTables(con) ## character(0) 5.3.2 Interact with PostgreSQL Write mtcars to PostgreSQL DBI::dbWriteTable(con, &quot;mtcars&quot;, mtcars, overwrite = TRUE) List the tables in the PostgreSQL database to show that mtcars is now there: DBI::dbListTables(con) ## [1] &quot;mtcars&quot; List the fields in mtcars: DBI::dbListFields(con, &quot;mtcars&quot;) ## [1] &quot;mpg&quot; &quot;cyl&quot; &quot;disp&quot; &quot;hp&quot; &quot;drat&quot; &quot;wt&quot; &quot;qsec&quot; &quot;vs&quot; &quot;am&quot; &quot;gear&quot; ## [11] &quot;carb&quot; Download the table from the DBMS to a local data frame: mtcars_df &lt;- DBI::dbReadTable(con, &quot;mtcars&quot;) The sp_print_df function from the sqlpetr package shows (or print) a data frame depending on appropriate output type. That is when running interactively or generating HTML it prints a DT::datatable() while it prints a knitr::kable() otherwise. Tell Docker to remove the cattle container from it’s library of active containers: sp_print_df(head(mtcars_df)) 5.4 Clean up Afterwards, always disconnect from the dbms: DBI::dbDisconnect(con) The sp_docker_stop function from the sqlpetr package stops the container given by the container_name parameter. Tell Docker to stop the cattle container: sp_docker_stop(&quot;cattle&quot;) The sp_docker_remove_container function from the sqlpetr package removes the container given by the container_name parameter. Tell Docker to remove the cattle container from it’s library of active containers: sp_docker_remove_container(&quot;cattle&quot;) ## [1] 0 Verify that cattle is gone: sp_docker_containers_tibble() ## # A tibble: 0 x 0 If we just stop the Docker container but don’t remove it (as we did with the sp_docker_remove_container(&quot;cattle&quot;) command), the cattle container will persist and we can start it up again later with sp_docker_start(&quot;cattle&quot;). In that case, mtcars would still be there and we could retrieve it from PostgreSQL again. Since sp_docker_remove_container(&quot;cattle&quot;) has removed it, the updated database has been deleted. (There are enough copies of mtcars in the world, so no great loss.) "]
]
