[
["chapter-sql-dplyr-data.html", "Chapter 13 SQL &amp; dplyr joins additional data 13.1 Making up data for Join Examples 13.2 SQL Multi-Row Insert Data Syntax 13.3 SQL Multi-Row Insert Data Example 13.4 DPLYR Multi-Row Insert Data Example 13.5 Create a film record", " Chapter 13 SQL &amp; dplyr joins additional data This chapter demonstrates how to: Use primary and foreign keys to retrieve specific rows of a table do different kinds of join queries Exercises Query the database to get basic information about each dvdrental story How to interact with the database using different strategies These packages are called in almost every chapter of the book: Verify Docker is up and running: sp_check_that_docker_is_up() ## [1] &quot;Docker is up, running these containers:&quot; ## [2] &quot;CONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES&quot; ## [3] &quot;803d45bddbf9 postgres-dvdrental \\&quot;docker-entrypoint.s…\\&quot; 37 seconds ago Up 10 seconds 0.0.0.0:5432-&gt;5432/tcp sql-pet&quot; Verify pet DB is available, it may be stopped. sp_show_all_docker_containers() ## CONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES ## 803d45bddbf9 postgres-dvdrental &quot;docker-entrypoint.s…&quot; 37 seconds ago Up 10 seconds 0.0.0.0:5432-&gt;5432/tcp sql-pet Start up the docker-pet container sp_docker_start(&quot;sql-pet&quot;) Now connect to the database with R. Need to wait for Docker &amp; Postgres to come up before connecting. con &lt;- sp_get_postgres_connection( user = Sys.getenv(&quot;DEFAULT_POSTGRES_USER_NAME&quot;), password = Sys.getenv(&quot;DEFAULT_POSTGRES_PASSWORD&quot;), dbname = &quot;dvdrental&quot;, seconds_to_test = 30 ) 13.1 Making up data for Join Examples Each chapter in the book stands on its own. If you have worked through the code blocks in this chapter in a previous session, you created some new customer records in order to work through material in the rest of the chapter. The DVD rental database data is too clean to demonstrate some join concepts. To dirty the data, this chapter performs a number of database operations on data tables that a data analyst is typically restricted from doing in the real world. Deleting records from tables. Inserting records from tables. Enabling and disabling table constraints. In our Docker environment, you have no restrictions on the database operations you can perform. In the next couple of code blocks, we delete the new data and then recreate the data for the join examples in this next chapter. 13.1.1 SQL Delete Data Syntax DELETE FROM &lt;source&gt; WHERE &lt;where_clause&gt;; 13.1.2 Delete New Practice Store from the Store Table. In the next code block we delete out the new stores that were added when the book was compliled or added working through the exercises. Out of the box, the DVD rental database’s highest store_id = 2. dbExecute(con, &quot;delete from store where store_id &gt; 2;&quot;) ## [1] 0 13.1.3 Delete film 1001, Sophie’s Choice, records in film_category, rental, inventory, and film The records need to be deleted in a specific order to not violate constraints. dbExecute(con, &quot;delete from film_category where film_id &gt;= 1001;&quot;) ## [1] 0 dbExecute(con, &quot;delete from rental where rental_id &gt;= 16050;&quot;) ## [1] 0 dbExecute(con, &quot;delete from inventory where film_id &gt;= 1001;&quot;) ## [1] 0 dbExecute(con, &quot;delete from film where film_id &gt;= 1001;&quot;) ## [1] 0 13.1.4 Delete New Practice Customers from the Customer table. In the next code block we delete out the new customers that were added when the book was compliled or added while working through the chapter. Out of the box, the DVD rental database’s highest customer_id = 599. 13.1.5 Delete New Practice Customers from the Customer table. In the next code block we delete out the new customers that were added when the book was compliled or added while working through the chapter. Out of the box, the DVD rental database’s highest customer_id = 599. dbExecute() always returns a scalar numeric that specifies the number of rows affected by the statement. dbExecute( con, &quot;delete from customer where customer_id &gt;= 600; &quot; ) ## [1] 0 The number above tells us how many rows were actually deleted from the customer table. 13.1.6 SQL Single Row Insert Data Syntax INSERT INTO &lt;target&gt; &lt;column_list&gt; VALUES &lt;values list&gt;; &lt;target&gt; : target table/view &lt;column list&gt; : csv list of columns &lt;values list&gt; : values assoicated with the column list. The column list is the list of column names on the table and the corresponding list of values must have the correct data type. The following code block returns the CUSTOMER column names and data types. customer_cols &lt;- dbGetQuery( con, &quot;select table_name, column_name, ordinal_position, data_type from information_schema.columns where table_catalog = &#39;dvdrental&#39; and table_name = &#39;customer&#39; ;&quot; ) sp_print_df(customer_cols) In the next code block, we insert Sophie as a new customer into the customer table via a SQL insert statement. The columns list clause has three id columns, customer_id, store_id, and address_id. The customer_id is a primary key column and the other two ‘look like’ foreign key columns. For now, we are interested in getting some new customers into the customer table. We look at the relations between the customer and the store tables later in this chapter. dbExecute( con, &quot; insert into customer (customer_id,store_id,first_name,last_name,email,address_id,activebool ,create_date,last_update,active) values(600,3,&#39;Sophie&#39;,&#39;Yang&#39;,&#39;sophie.yang@sakilacustomer.org&#39;,1,TRUE,now(),now()::date,1) &quot; ) ## [1] 1 The number above should be 1 indicating that one record was inserted. new_customers &lt;- dbGetQuery(con ,&quot;select customer_id,store_id,first_name,last_name from customer where customer_id &gt;= 600;&quot;) sp_print_df(new_customers) 13.1.7 Primary Key Constraint Error Message For the new customers, we are concerned with not violating the PK and FK constraints. In the next SQL code block, we try and reinsert the newly created customer record inserted above. Instead of having the code block fail, it throws a duplicate key exception error message. If you knit the document, the exception error message is thrown to the R Markdown tab. dbExecute(con, &quot; do $$ DECLARE v_customer_id INTEGER; begin v_customer_id = 600; insert into customer (customer_id,store_id,first_name,last_name,email,address_id,activebool ,create_date,last_update,active) values(v_customer_id,3,&#39;Sophie&#39;,&#39;Yang&#39;,&#39;sophie.yang@sakilacustomer.org&#39;,1,TRUE ,now(),now()::date,1); exception when unique_violation then raise notice &#39;SQLERRM = %, customer_id = %&#39;, SQLERRM, v_customer_id; when others then raise &#39;SQLERRM = % SQLSTATE =%&#39;, SQLERRM, SQLSTATE; end; $$ language &#39;plpgsql&#39;;&quot;) ## [1] 0 The number above shows how many rows were inserted. To ensure that the thrown error message is part of the book, the error message is shown below. NOTICE: SQLERRM = duplicate key value violates unique constraint &quot;customer_pkey&quot;, customer_id = 600 CONTEXT: PL/pgSQL function inline_code_block line 12 at RAISE 13.1.8 R Exercise: Inserting a Single Row via a Dataframe In the following code block replace Sophie Yang with your name where appropriate. Note: The last data frame parameter sets the stringsAsFactors is FALSE. Databases do not have a native FACTOR type. The dataframe column names must match the table column names. The dbWriteTable function needs append = true to actually insert the new row. The dbWriteTable function has an option ‘overwrite’. It is set to FALSE by default. If it is set to TRUE, the table is first truncated before the row is inserted. No write occurs if both overwrite and append = FALSE. df &lt;- data.frame( customer_id = 601 , store_id = 2 , first_name = &quot;Sophie&quot; , last_name = &quot;Yang&quot; , email = &quot;sophie.yang@sakilacustomer.org&quot; , address_id = 1 , activebool = TRUE , create_date = Sys.Date() , last_update = Sys.time() , active = 1 , stringsAsFactors = FALSE ) dbWriteTable(con, &quot;customer&quot;, value = df, append = TRUE, row.names = FALSE) new_customers &lt;- dbGetQuery(con , &quot;select customer_id,store_id,first_name,last_name from customer where customer_id &gt;= 600;&quot;) sp_print_df(new_customers) 13.2 SQL Multi-Row Insert Data Syntax INSERT INTO &lt;target&gt; &lt;column_list&gt; VALUES &lt;values list1&gt;, ... &lt;values listn&gt;; &lt;target&gt; : target table/view &lt;column list&gt; : csv list of columns (&lt;values list&gt;) : values assoicated with the column list. Postgres and some other flavors of SQL allow multiple rows to be inserted at a time. The syntax is identical to the Single Row syntax, but includes multiple (&lt;values list&gt;) clauses separated by commas. Note that each value list is enclosed it a set of parenthesis. The following code block illustrates the SQL multi-row insert. Note that the customer_id column takes on sequential values to satisfy the PK constraint. 13.3 SQL Multi-Row Insert Data Example # dbExecute( con, &quot;insert into customer (customer_id,store_id,first_name,last_name,email,address_id,activebool ,create_date,last_update,active) values(602,4,&#39;John&#39;,&#39;Smith&#39;,&#39;john.smith@sakilacustomer.org&#39;,2,TRUE ,now()::date,now()::date,1) ,(603,5,&#39;Ian&#39;,&#39;Frantz&#39;,&#39;ian.frantz@sakilacustomer.org&#39;,3,TRUE ,now()::date,now()::date,1) ,(604,6,&#39;Ed&#39;,&#39;Borasky&#39;,&#39;ed.borasky@sakilacustomer.org&#39;,4,TRUE ,now()::date,now()::date,1) ;&quot; ) ## [1] 3 13.4 DPLYR Multi-Row Insert Data Example The Postgres R multi-row insert is similar to the single row insert. The single column values are converted to a vector of values. 13.4.1 R Exercise: Inserting Multiple Rows via a Dataframe Replace the two first_name, last_name, and email column values with your own made up values in the following code block. The output should be all of our new customers, customer_id = {600 - 606}. customer_id &lt;- c(605, 606) store_id &lt;- c(3, 4) first_name &lt;- c(&quot;John&quot;, &quot;Ian&quot;) last_name &lt;- c(&quot;Smith&quot;, &quot;Frantz&quot;) email &lt;- c(&quot;john.smith@sakilacustomer.org&quot;, &quot;ian.frantz@sakilacustomer.org&quot;) address_id &lt;- c(3, 4) activebool &lt;- c(TRUE, TRUE) create_date &lt;- c(Sys.Date(), Sys.Date()) last_update &lt;- c(Sys.time(), Sys.time()) active &lt;- c(1, 1) df2 &lt;- data.frame(customer_id, store_id, first_name, last_name, email, address_id, activebool, create_date, last_update, active, stringsAsFactors = FALSE ) dbWriteTable(con, &quot;customer&quot;, value = df2, append = TRUE, row.names = FALSE ) new_customers &lt;- dbGetQuery(con , &quot;select customer_id,store_id,first_name,last_name from customer where customer_id &gt;= 600;&quot;) sp_print_df(new_customers) Confirm that the two new rows, customer_id = { 605, 606} are in the output. The next two code block show all the rows in the store and staff tables. Notice that neither table has a staff_id or a manager_staff_id = 10. We will attempt to insert such a row in the upcoming code blocks. stores &lt;- dbGetQuery(con,&quot;select * from store;&quot;) sp_print_df(stores) staff &lt;- dbGetQuery(con ,&quot;select staff_id, first_name, last_name, address_id, email, store_id from staff;&quot;) sp_print_df(staff) 13.4.2 Creating a Messy Store Row A new store row is needed to illustrate a right outer join in a future code block. However, one cannot insert/update a row into the store table with a manager_staff_id = 10 because of a foreign key constraint on the manager_staff_id column. The manager_staff_id value must satisfy two conditions before the database will allow the new store row to be inserted into the table when the table constraints are enabled.: The manager_staff_id must be unique when inserted into the store table. The manager_staff_id must match a staff table staff_id value. Next we show both error messages: The next code block attempts to insert a new store, store_id = 10, with manager_staff_id = 1, but fails with a unique constraint error message. The manager_staff_id = 1 already exists in the store table. dbExecute(con, &quot; do $$ DECLARE v_manager_staff_id INTEGER; begin v_manager_staff_id = 1; insert into store (store_id,manager_staff_id,address_id,last_update) values (10,v_manager_staff_id,10,now()::date); exception when foreign_key_violation then raise notice &#39;SQLERRM = %, manager_staff_id = %&#39;, SQLERRM, v_manager_staff_id; when others then raise notice &#39;SQLERRM = % SQLSTATE =%&#39;, SQLERRM, SQLSTATE; end; $$ language &#39;plpgsql&#39;;&quot;) ## [1] 0 Error in result_create(conn@ptr, statement) : Failed to prepare query: server closed the connection unexpectedly This probably means the server terminated abnormally before or while processing the request. The number above should be 0 and indicates no row was inserted. The next code block attempts to insert a new store, store_id = 10, with manager_staff_id = 10, but fails with a foreign key constraint error message because there does not exist a staff table row with staff_id = 10. dbExecute(con, &quot; do $$ DECLARE v_manager_staff_id INTEGER; begin v_manager_staff_id = 10; insert into store (store_id,manager_staff_id,address_id,last_update) values (10,v_manager_staff_id,10,now()::date); exception when foreign_key_violation then raise notice &#39;SQLERRM = %, manager_staff_id = %&#39;, SQLERRM, v_manager_staff_id; when others then raise notice &#39;SQLERRM = % SQLSTATE =%&#39;, SQLERRM, SQLSTATE; end; $$ language &#39;plpgsql&#39;;&quot;) ## [1] 0 NOTICE: SQLERRM = insert or update on table &quot;store&quot; violates foreign key constraint &quot;store_manager_staff_id_fkey&quot;, manager_staff_id = 10 CONTEXT: PL/pgSQL function inline_code_block line 9 at RAISE Again, the number above should be 0 and indicates no row was inserted. The following three code blocks disables all the database constraints on the store table Inserts the store row with store_id = 10 via a dataframe. Re-enabes the database constraints on the store table # dbExecute(con, &quot;ALTER TABLE store DISABLE TRIGGER ALL;&quot;) ## [1] 0 df &lt;- data.frame( store_id = 10 , manager_staff_id = 10 , address_id = 10 , last_update = Sys.time() ) dbWriteTable(con, &quot;store&quot;, value = df, append = TRUE, row.names = FALSE) dbExecute(con, &quot;ALTER TABLE store ENABLE TRIGGER ALL;&quot;) ## [1] 0 The zeros after the dbExecute code blocks indicate that the dbExecute calls did not alter any rows on the table. In the next code block we confirm our new row, store_id = 10, was actually inserted. stores &lt;- dbGetQuery(con,&quot;select * from store;&quot;) sp_print_df(stores) 13.5 Create a film record dbExecute( con, &quot;insert into film (film_id,title,description,release_year,language_id ,rental_duration,rental_rate,length,replacement_cost,rating ,last_update,special_features,fulltext) values(1001,&#39;Sophie&#39;&#39;s Choice&#39;,&#39;orphaned language_id=10&#39;,2018,1 ,7,4.99,120,14.99,&#39;PG&#39; ,now()::date,&#39;{Trailers}&#39;,&#39;&#39;) ,(1002,&#39;Sophie&#39;&#39;s Choice&#39;,&#39;orphaned language_id=10&#39;,2018,1 ,7,4.99,120,14.99,&#39;PG&#39; ,now()::date,&#39;{Trailers}&#39;,&#39;&#39;) ; &quot;) ## [1] 2 dbExecute( con, &quot;insert into film_category (film_id,category_id,last_update) values(1001,6,now()::date) ,(1001,7,now()::date) ,(1002,6,now()::date) ,(1002,7,now()::date) ;&quot;) ## [1] 4 dbExecute( con, &quot;insert into inventory (inventory_id,film_id,store_id,last_update) values(4582,1001,1,now()::date) ,(4583,1001,2,now()::date) ;&quot;) ## [1] 2 dbExecute( con, &quot;insert into rental (rental_id,rental_date,inventory_id,customer_id,return_date,staff_id,last_update) values(16050,now()::date - interval &#39;1 week&#39;,4582,600,now()::date,1,now()::date) ;&quot;) ## [1] 1 Diconnect from the db: dbDisconnect(con) sp_docker_stop(&quot;sql-pet&quot;) knitr::knit_exit() "]
]
