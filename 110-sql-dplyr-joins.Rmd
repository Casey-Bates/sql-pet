Introduction to SQL Joins {#chapter_sql-joins}

> This chapter demonstrates how to:
> 
> * Use primary and foreign keys to retrieve specific rows of a table
> * do different kinds of join queries
> * Exercises
> * Query the database to get basic information about each dvdrental story
> * How to interact with the database using different strategies

```{r setup, echo=FALSE, message=FALSE, warning=FALSE}
# These packages are called in almost every chapter of the book:
library(tidyverse)
library(DBI)
library(DiagrammeR)
library(RPostgres)
library(glue)
library(here)
require(knitr)
library(dbplyr)
library(sqlpetr)
```

Verify Docker is up and running:
```{r Verify Docker is up}
sp_check_that_docker_is_up()
```

Verify pet DB is available, it may be stopped.

```{r Verify pet DB is available}
sp_show_all_docker_containers()
```

Start up the `docker-pet` container

```{r Start up the docker-pet container}
sp_docker_start("sql-pet")
```

Now connect to the database with R

```{r connect to the database}
# need to wait for Docker & Postgres to come up before connecting.

con <- sp_get_postgres_connection(
  user = Sys.getenv("DEFAULT_POSTGRES_USER_NAME"),
  password = Sys.getenv("DEFAULT_POSTGRES_PASSWORD"),
  dbname = "dvdrental",
  seconds_to_test = 30
)
```


## Making up data for Join Examples

Each chapter in the book stands on its own.  If you have worked through the code blocks in this chapter in a previous session, you created some new customer records in order to work through material in the rest of the chapter. 

The DVD rental database data is too clean to demonstrate some join concepts.  To dirty the data, this chapter performs a number of database operations on data tables that a data analyst is typically restricted from doing in the real world.  

1.  Deleting records from tables.
2.  Inserting records from tables.
3.  Enabling and disabling table constraints.

In our Docker environment, you have no restrictions on the database operations you can perform.

In the next couple of code blocks, we delete the new data and then recreate the data for the join examples in this next chapter.

### SQL Delete Data Syntax

```
    DELETE FROM <source> WHERE <where_clause>;
```

### Delete New Practice Customers from the Customer table.

In the next code block we delete out the new customers that were added when the book was compliled or added while working through the chapter.  Out of the box, the DVD rental database's highest customer_id = 599.

```
dbExecute() always returns a scalar numeric that specifies the number of rows affected by the statement. 
```

```{r Delete new customers}
dbExecute(
  con,
  "delete from customer 
   where customer_id >= 600;
  "
)
```

The number above tells us how many rows were actually deleted from the customer table.

### Delete New Practice Store from the Store Table.

In the next code block we delete out the new stores that were added when the book was compliled or added working through the exercises.  Out of the box, the DVD rental database's highest store_id = 2.

```{r Delete new stores}
dbExecute(con, "delete from store where store_id > 2;")
```

### SQL Single Row Insert Data Syntax

```
    INSERT INTO <target> <column_list> VALUES <values list>;
    <target> : target table/view
    <column list> : csv list of columns
    <values list> : values assoicated with the column list.
```

The `column list` is the list of column names on the table and the corresponding list of values must have the correct data type.  The following code block returns the `CUSTOMER` column names and data types.

```{r SQL Customer Columns}
customer_cols <- dbGetQuery(
  con,
  "select table_name, column_name, ordinal_position, data_type 
          from information_schema.columns 
         where table_catalog = 'dvdrental' 
           and table_name = 'customer'
       ;"
)

sp_print_df(customer_cols)
```

In the next code block, we insert Sophie as a new customer into the customer table via a SQL insert statement.  The columns list clause has three id columns, customer_id, store_id, and address_id.  The customer_id is a primary key column and the other two 'look like' foreign key columns.

For now, we are interested in getting some new customers into the customer table.  We look at the relations between the customer and the store tables later in this chapter.


```{r SQL Single Row Insert}
dbExecute(
  con,
  "
insert into customer 
  (customer_id,store_id,first_name,last_name,email,address_id,activebool
  ,create_date,last_update,active)
  values(600,3,'Sophie','Yang','sophie.yang@sakilacustomer.org',1,TRUE,now(),now()::date,1)
  "
)
```

The number above should be 1 indicating that one record was inserted.

```{r display new customers}
new_customers <- dbGetQuery(con
                ,"select customer_id,store_id,first_name,last_name
                     from customer where customer_id >= 600;")
sp_print_df(new_customers)
```

### Primary Key Constraint Error Message

For the new customers, we are concerned with not violating the PK and FK constraints.
In the next SQL code block, we try and reinsert the newly created customer record inserted above.  Instead of having the code block fail, it throws a duplicate key exception error message.  If you `knit` the document, the exception error message is thrown to the `R Markdown` tab.   

```{r Proess Duplicate Customer Key Error}
dbExecute(con, "
do $$
DECLARE v_customer_id INTEGER;
begin
    v_customer_id = 600;
    insert into customer 
    (customer_id,store_id,first_name,last_name,email,address_id,activebool
    ,create_date,last_update,active)
     values(v_customer_id,3,'Sophie','Yang','sophie.yang@sakilacustomer.org',1,TRUE
           ,now(),now()::date,1);
exception
when unique_violation then
    raise notice 'SQLERRM = %, customer_id = %', SQLERRM, v_customer_id;
when others then 
    raise 'SQLERRM = % SQLSTATE =%', SQLERRM, SQLSTATE;
end;
$$ language 'plpgsql';")
```

The number above shows how many rows were inserted.  To ensure that the thrown error message is part of the book, the error message is shown below.

```
NOTICE:  SQLERRM = duplicate key value violates unique constraint "customer_pkey", customer_id = 600
CONTEXT:  PL/pgSQL function inline_code_block line 12 at RAISE
```

### R Exercise: Inserting a Single Row via a Dataframe

In the following code block replace Sophie Yang with your name where appropriate.  
Note:

1.  The last data frame parameter sets the stringsAsFactors is `FALSE`.  Databases do not have a native `FACTOR` type.
2.  The dataframe column names must match the table column names. 
3.  The dbWriteTable function needs `append` = true to actually insert the new row.
4.  The dbWriteTable function has an option 'overwrite'.  It is set to FALSE  by default.  If it is set to TRUE, the table is first truncated before the row is inserted.  
5.  No write occurs if both overwrite and append = FALSE.

```{r R Dataframe Insert}
df <- data.frame(
  customer_id = 601
  , store_id = 2
  , first_name = "Sophie"
  , last_name = "Yang"
  , email = "sophie.yang@sakilacustomer.org"
  , address_id = 1
  , activebool = TRUE
  , create_date = Sys.Date()
  , last_update = Sys.time()
  , active = 1
  , stringsAsFactors = FALSE
)
dbWriteTable(con, "customer", value = df, append = TRUE, row.names = FALSE)

new_customers <- dbGetQuery(con
                , "select customer_id,store_id,first_name,last_name
                     from customer where customer_id >= 600;")
sp_print_df(new_customers)
```

## SQL Multi-Row Insert Data Syntax

```
    INSERT INTO <target> <column_list> VALUES <values list1>, ... <values listn>;
    <target>       : target table/view
    <column list>  : csv list of columns
   (<values list>) : values assoicated with the column list.
```

Postgres and some other flavors of SQL allow multiple rows to be inserted at a time.  The syntax is identical to the Single Row syntax, but includes multiple `(<values list>)` clauses separated by commas.  Note that each value list is enclosed it a set of parenthesis.  The following code block illustrates the SQL multi-row insert.  Note that the customer_id column takes on sequential values to satisfy the PK constraint.


## SQL Multi-Row Insert Data Example

```{r SQL Multi-Row Insert Data}
#
dbExecute(
  con,
  "insert into customer 
  (customer_id,store_id,first_name,last_name,email,address_id,activebool
  ,create_date,last_update,active)
   values(602,4,'John','Smith','john.smith@sakilacustomer.org',2,TRUE
         ,now()::date,now()::date,1)
         ,(603,5,'Ian','Frantz','ian.frantz@sakilacustomer.org',3,TRUE
         ,now()::date,now()::date,1)
         ,(604,6,'Ed','Borasky','ed.borasky@sakilacustomer.org',4,TRUE
         ,now()::date,now()::date,1)
         ;"
)
```

## DPLYR Multi-Row Insert Data Example

The Postgres R multi-row insert is similar to the single row insert.  The single column values are converted to a vector of values.

### R Exercise: Inserting Multiple Rows via a Dataframe

Replace the two first_name, last_name, and email column values with your own made up values in the following code block.  The output should be all of our new customers, customer_id = {600 - 606}.

```{r DPLYR Multi-Row Insert Data}

customer_id <- c(605, 606)
store_id <- c(3, 4)
first_name <- c("John", "Ian")
last_name <- c("Smith", "Frantz")
email <- c("john.smith@sakilacustomer.org", "ian.frantz@sakilacustomer.org")
address_id <- c(3, 4)
activebool <- c(TRUE, TRUE)
create_date <- c(Sys.Date(), Sys.Date())
last_update <- c(Sys.time(), Sys.time())
active <- c(1, 1)

df2 <- data.frame(customer_id, store_id, first_name, last_name, email,
  address_id, activebool, create_date, last_update, active,
  stringsAsFactors = FALSE
)


dbWriteTable(con, "customer",
  value = df2, append = TRUE, row.names = FALSE
)

new_customers <- dbGetQuery(con
                , "select customer_id,store_id,first_name,last_name
                     from customer where customer_id >= 600;")
sp_print_df(new_customers)
```

Confirm that the two new rows, customer_id = { 605, 606} are in the output.

The next two code block show all the rows in the  store and staff tables.  Notice that neither table has a staff_id or a manager_staff_id = 10.  We will attempt to insert such a row in the upcoming code blocks.

```{r new store data}
stores <- dbGetQuery(con,"select * from store;")
sp_print_df(stores)
```

```{r staff table}
staff  <- dbGetQuery(con
            ,"select staff_id, first_name, last_name, address_id, email, store_id
                from staff;")
sp_print_df(staff)
```

### Creating a Messy Store Row

A new store row is needed to illustrate a right outer join in a future code block.  However, one cannot insert/update a row into the `store` table with a manager_staff_id = 10 because of a foreign key constraint on the manager_staff_id column.  

The manager_staff_id value must satisfy two conditions before the database will allow the new store row to be inserted into the table when the table constraints are enabled.:

1.  The manager_staff_id must be unique when inserted into the store table.
2.  The manager_staff_id must match a `staff` table staff_id value.

Next we show both error messages:

1.  The next code block attempts to insert a new store, `store_id = 10`, with manager_staff_id = 1, but fails with a unique constraint error message.  The manager_staff_id = 1 already exists in the store table.

```{r Proess Updating of Store manager_staff_id Duplicate Key Error}
dbExecute(con, "
do $$
DECLARE v_manager_staff_id INTEGER;
begin
    v_manager_staff_id = 1;
    insert into store (store_id,manager_staff_id,address_id,last_update)
         values (10,v_manager_staff_id,10,now()::date);
exception
when foreign_key_violation then
    raise notice 'SQLERRM = %, manager_staff_id = %', SQLERRM, v_manager_staff_id;
when others then
    raise notice 'SQLERRM = % SQLSTATE =%', SQLERRM, SQLSTATE;
end;
$$ language 'plpgsql';")

```

```
Error in result_create(conn@ptr, statement) : Failed to prepare query: server closed the connection unexpectedly This probably means the server terminated abnormally before or while processing the request.
```

The number above should be 0 and indicates no row was inserted.

2.  The next code block attempts to insert a new store, `store_id = 10`, with manager_staff_id = 10, but fails with a foreign key constraint error message because there does not exist a staff table row with staff_id = 10.

```{r Proess Updating of Store manager_staff_id Foreign Key Error}
dbExecute(con, "
do $$
DECLARE v_manager_staff_id INTEGER;
begin
    v_manager_staff_id = 10;
    insert into store (store_id,manager_staff_id,address_id,last_update)
         values (10,v_manager_staff_id,10,now()::date);
exception
when foreign_key_violation then
    raise notice 'SQLERRM = %, manager_staff_id = %', SQLERRM, v_manager_staff_id;
when others then
    raise notice 'SQLERRM = % SQLSTATE =%', SQLERRM, SQLSTATE;
end;
$$ language 'plpgsql';")
```

```
NOTICE:  SQLERRM = insert or update on table "store" violates foreign key constraint "store_manager_staff_id_fkey", manager_staff_id = 10
CONTEXT:  PL/pgSQL function inline_code_block line 9 at RAISE
```

Again, the number above should be 0 and indicates no row was inserted.

The following three code blocks

1.  disables all the database constraints on the `store` table
2.  Inserts the store row with store_id = 10 via a dataframe.
3.  Re-enabes the database constraints on the store table

```{r Disable store trigger}
#
dbExecute(con, "ALTER TABLE store DISABLE TRIGGER ALL;")
```

```{r "insert store id = 10 row"}
df <- data.frame(
    store_id = 10
  , manager_staff_id = 10
  , address_id = 10
  , last_update = Sys.time()
)
dbWriteTable(con, "store", value = df, append = TRUE, row.names = FALSE)
```

```{r enable store trigger}
dbExecute(con, "ALTER TABLE store ENABLE TRIGGER ALL;")
```

The zeros after the dbExecute code blocks indicate that the dbExecute calls did not alter any rows on the table.

In the next code block we confirm our new row, store_id = 10, was actually inserted.

```{r }
stores <- dbGetQuery(con,"select * from store;")
sp_print_df(stores)
```

<!--

## Creating Duplicate Customer Rows 

In the next section we create a new table, `smy_customer`.  We will load all customers with customer_id > 594 twice.  The `smy_customer` table will be used in the dplyr semi-join section. 

```{r}
dbExecute(con,"drop table if exists smy_customer;")
dbExecute(con,"create table smy_customer 
    as select * 
         from customer  
        where customer_id > 594;")
dbExecute(con,"insert into smy_customer 
               select * 
                 from customer  
                where customer_id > 594;")

smy_cust_dupes <- dbGetQuery(con,'select * 
                                    from smy_customer 
                                  order by customer_id')

sp_print_df(smy_cust_dupes)
```
-->

## Joins

In section 'SQL Quick Start Simple Retrieval', there is a brief discussion of databases and 3NF.  One of the goals of normalization is to eliminate redundant data being kept in multiple tables and having each table contain a very granular level of detail.  If a record then needs to be updated, it is updated in one table instead of multiple tables improving overall system performance.  This also helps simplify and maintain referential integrity between tables.
 
Normalization breaks data down and JOINs denormalizes the data and builds it back up.  The tables are typically related via a primary key - foreign key relationship. The Postgres database enforces the primary and foreign key constraints in the DVD rental database.  

### Join Types

```{r SQL TYPES,echo = FALSE}
grViz("
digraph SQL_TYPES {

  # a 'graph' statement
  graph [overlap = true, fontsize = 10]

  node [shape = box,
        fixedsize = false,
        hegith = 1.5
        width = 1.50]
  0[label='0.  SQL Joins']
  1[label='1.  Inner Join\nL.col1 {<,=,>} R.col2']
  2[label='2.  Outer Join\nL.col1=tbl1.col2']
  3[label='3.  Self Join\nL.col1=tbl1.col2']
  4[label='4.  Cross Join\nL.col1=R.col2']
  5[label='5.  Equi Join\nL.col1=R.col2'] 
  6[label='6.  Natural Join\nL.col1=R.col1']
  7[label='7.  Left Join\nL.col1=R.col1']
  8[label='8.  Right Join\nL.col1=R.col1']
  9[label='9.  Full Join\nL.col1=tbl2.col1']
  # several 'edge' statements
  0 -> {1,2,3,4} [arrowhead=none]
  1 -> 5 [arrowhead=none]
  5 -> 6 [arrowhead=none]
  2 -> {7,8,9} [arrowhead=none]
  #3 -> {7,8,9}
}
")
```  

The diagram above shows the hierarchy of the different types of joins.  In the boxes above:

*  The joins are based on a single column from the two tables, the left and right tables.  Joins can be based on multiple columns from both tables.
*  The `L.` and `R.` are aliases for the left and right table names.  
*  Often the joining columns have the same name as in the Natural Join, L.col1 = R.col1 
*  However, the joining column names can be different L.col1 = R.col2.  
*  All joins are based on equality between the table columns, L.col1 = R.col2, except the inner join which can use non-equality column conditions.  Non-equality column conditions are rare.  Equa Joins are subset of the Inner Join.


For this tutorial, we can think of joins as either an Inner/eqau Join or an Outer Join.

Instead of showing standard Venn diagrams showing the different JOINS, we use an analogy. For those interested though, the typical Venn diagrams can be found [here](http://www.sql-join.com/sql-join-types/).

### Valentines Party

Imagine you are at a large costume Valentine's Day dance party.  The hostess of the party, a data scientist, would like to learn more about the people attending her party.  When the band takes a break, she lets everyone know it is time for the judges to evaluate the winners for best costumes and associated prizes.

![ValentinesDay](screenshots/ValentinesDay.PNG)

She requests the following:

1.  All the couples at the party line up in front of her in a single line with the men on her left and the women on her right, (inner join)

2.  All the remaining men to form a second line two feet behind the married men, (left outer join, all couples + unattached men)

3.  All the remaining women to form a third line two feet in front of the married women, (right outer join, all couples + unattached women)

As our data scientist looks out, she can clearly see the three distinct lines, the single men, the man woman couples, and the single women, a full outer join.  

As the three judges start walking down the lines, she makes one more announcement.

4.  There is a special prize for the man and woman who can guess the average age of the members of the opposite sex. To give everyone a chance to come up with an average age, she asks the men to stay in line and the women to move down the men's line in order circling back around until they get back to their starting point in line, (Cartesian join, every man seen by every woman and vice versa).  

It is hard enough to tell someone's age when they don't have a mask, how do you get the average age when people have masks?

The hostess knows that there is usually some data anomalies.  As she looks out she sees a small cluster of people who did not line up.  Being the hostess with the mostest, she wants to get to know that small cluster better.  Since they are far off and in costume, she cannot tell if they are men or women.  More importantly, she does not know if they identify as a man or a woman, both -- (kind of a stretch for a self join), neither, or something else.  Ah, the inquisitive mind wants to know.

### Join Syntax

The table below shows the two R join function call formats, standalone function call and pipe function call and the corresponding SQL join format.

|Join|dplyr                                                                            |sql
|-----|--------------------------------------------------------------------------------|------------------------------------------------------
|inner|inner_join(customer_tbl, rental_tbl, by = 'customer_id', suffix = c(".c", ".r"))|from customer c join rental r on c.customer_id = r.customer_id
|     |customer_tbl %>% inner_join(rental_tbl, by = 'customer_id', suffix = c(".c", ".r"))|
|left |left_join(customer_tbl, rental_tbl, by = 'customer_id', suffix = c(".c", ".r")) |from customer c left outer join rental r on c.customer_id = r.customer_id
|     |customer_tbl %>% left_join(rental_tbl, by = 'customer_id', suffix = c(".c", ".r"))|
|right|right_join(customer_tbl, rental_tbl, by = 'customer_id', suffix = c(".c", ".r"))|from customer c right outer join rental r on c.customer_id = r.customer_id
|     |customer_tbl %>% right_join(rental_tbl, by = 'customer_id', suffix = c(".c", ".r"))|
|full |full_join(customer_tbl, rental_tbl, by = 'customer_id', suffix = c(".c", ".r")) |from customer c full outer join rental r on c.customer_id = r.customer_id
|     |customer_tbl %>% full_join(rental_tbl, by = 'customer_id', suffix = c(".c", ".r"))|
|semi |semi_join(customer_tbl, rental_tbl, by = 'customer_id')    |
|     |customer_tbl %>% semi_join(rental_tbl, by = 'customer_id') |
|anti |anti_join(customer_tbl, rental_tbl, by = 'customer_id')    |     |     |customer_tbl %>% semi_join(rental_tbl, by = 'customer_id') |

### Join Tables

The dplyr join documentation describes two different types of joins, `mutating` and `filtering` joins.  For those coming to R with a SQL background, the mutating documentation is misleading in one respect.  Here is the inner_join documentation.

```
    inner_join()
    
    return all rows from x where there are matching values in y, and all columns from x and y. 
    If there are multiple matches between x and y, all combination of the matches are returned.
```

The misleading part is 'and all the columns from *x* and *y*.'  If the join column is `KEY`, SQL will return x.KEY and y.KEY.  Dplyr returns just KEY.  It appears that the KEY value comes from the driving table.  This is important if you are translating SQL to R because SQL developers will reference both columns x.KEY and y.KEY.  One needs to mutate the the y.KEY column.  This difference should become clear in the outer join examples.  

In the next couple of examples, we will use a small sample of the `customer` and `store` table data from the database to illustrate the diffent joins.  In the *_join verbs, the `by` and `suffix` parameters are included because it helps document the actual join and the source of join columns.

## Natural Join Delayed Time Bomb

The dplyr default join is a natural join, joining tables on common column names.  One of many links why one should not use natural joins can be found [here](http://gplivna.blogspot.com/2007/10/natural-joins-are-evil-motto-if-you.html).  If two tables are joined via a natural join on column `C1` the join continues to work as long as no additional common columns are added to either table.  If a new new column `C2` is added to one of the tables and `C2` already exists in the other table, BOOM, the delayed time bomb goes off.  The natural join still executes, doesn't throw any errors, but the returned result set may be smaller, much smaller, than before the new `C2` column was added.

### SQL Customer store_id Distribution

The next code block calculates the `store_id` distribution in the `customer` and `store` tables across all their rows.  The results will be used in following sections to validate different join result sets.

```{r SQL Customer store_id Distribution}
store_distribution_sql <- dbGetQuery(con
          ,"select 'customer' tbl, store_id,count(*) count 
              from customer group by store_id
            union
            select 'store' tbl,store_id,count(*) count 
              from store group by store_id
            order by tbl,store_id;"
          )
sp_print_df(store_distribution_sql)
```

### Sample Customer and Store Join Data

The following code block extracts sample customer and the store data.  The customer data is restricted to 10 rows to illustrate the different joins.  The 10 rows are used in the detail examples in order to perform a sanity check that the join is actually working.  Each detail example is followed by an aggregated summary across all rows of `customer` and `store` table.

```{r Sample Customer and Store Join Data}
sample_customers <- dbGetQuery(con,"select customer_id,first_name,last_name,store_id
                                      from customer 
                                     where customer_id between 595 and 604")
stores <- dbGetQuery(con,"select * from store;")
sp_print_df(sample_customers)
sp_print_df(stores)
```
 

### dplyr store_id distribution Exercise

Execute and Review the output from the code block below.  Union and arrange the output to match the SQL output in the previous code block.  

```{r dplyr store_id distribution}
customer_table <- DBI::dbReadTable(con, "customer")
store_table <- DBI::dbReadTable(con, "store")

customer_summary <- customer_table %>% 
  group_by(store_id) %>% 
  summarize(count=n()) %>% 
  mutate(table='customer') %>% 
  select(table,store_id,count)

store_summary <- store_table %>% 
  group_by(store_id) %>% 
  summarize(count=n()) %>% 
  mutate(table='store') %>% 
  select(table,store_id,count)

sp_print_df(customer_summary)
sp_print_df(store_summary)

## UNION the two summary tables and ARRANGE the output to match the SQL output from the previouse code block


```

## Join Templates

In this section we perform various joins using dplyr and SQL.  Each dplyr code block has three purposes.  

1.  Show working detail/summary data join examples.  
2.  The code blocks can be used as templates for beginning more complex dplyr pipes.
3.  The code blocks show the number of joins performed.

In these examples the 'customer' is always the left table and 'store' is always the right table. The join condition shown in the `by` parameter

    by = c('store_id'='store_id')

is on the common foreign - primary key column store_id. This is technically an equi-join condition which makes our joins 1-to-1 and keeps the result set small.  

```
In multi-column joins, each language_id would be replaced with a vector of column names used in the join by position.  Note the column names do not need to be identical by position.
```

The suffix parameter is a way to distinguish the same column name in the joined tables.  The suffixes are usually an single letter to represent the name of the table.  

## Inner Joins

### SQL Inner Join Details {example_inner-join-details-sql}

For an inner join between two tables, it doesn't matter which table is on the left, the first table, and which is on the right, the second table, because join conditions on both tables must be satisfied.  Reviewing the table below shows the inner join on our 10 sample customers and 3 store records returned only 6 rows.  The inner join detail shows only rows with matching store_id's.  


```{r SQL inner join details}
customer_store_details_sij <- dbGetQuery(con,
"select 'ij' join_type,customer_id,first_name,last_name,c.store_id c_store_id
       ,s.store_id s_store_id,s.manager_staff_id, s.address_id
   from customer c join store s on c.store_id = s.store_id 
  where customer_id between 595 and 604;")
sp_print_df(customer_store_details_sij)
```

### Dplyr Inner Join Details {example_inner-join-details-dplyr}

```{r dplyr inner join Details}
customer_ij <- customer_table %>%
  inner_join(store_table, by = c("store_id" = "store_id"), suffix(c(".c", ".s"))) %>%
    filter(customer_id >= 595 & customer_id <= 604 ) %>%
    select(customer_id,first_name,last_name,store_id 
       ,store_id,manager_staff_id, address_id) 
sp_print_df(customer_ij)
```

Compare the output from the SQL and Dplyr version.  The SQL output has a `c_store_id` and a `s_store_id` column and the Dplyr output only has `store_id`.  In this case, because it is an inner join, it doesn't matter because they will always the same.

### SQL Inner Join Summary {example_inner-join-summary-sql}

Note that both the store_id is available from both the customer and store tables, c.store_id,s.store_id, in the select clause.

```{r SQL Inner Join Summary}
customer_store_summay_sij <- dbGetQuery(
  con,
  "select c.store_id c_store_id,s.store_id s_store_id,count(*) n
   from customer c join store s on c.store_id = s.store_id
  group by c.store_id,s.store_id;"
)

sp_print_df(customer_store_summay_sij)
```

### Dplyr Inner Join Summary {example_inner-join-summary_dplyr}

In the previous SQL code block, `c.` and `s.` were used in the `inner join` as table aliases.  The `dplyr` suffix is similar to the SQL table alias. The role of the dplyr suffix and the SQL alias is to disambiguate duplicate table and column names referenced.    

```{r dplyr inner join summary}
customer_store_summary_dij <- customer_table %>%
  inner_join(store_table, by = c("store_id" = "store_id"), suffix(c(".c", ".s"))) %>%
     mutate( join_type = "ij"
        ,c_store_id = if_else(is.na(customer_id),customer_id, store_id)         
        ,s_store_id = if_else(is.na(manager_staff_id), manager_staff_id, store_id)) %>%
  group_by(join_type,c_store_id,s_store_id) %>%
  summarize(n = n())

sp_print_df(customer_store_summary_dij)
```

## Left Joins

### SQL Left Join Details {example_left-join-details-sql}

The SQL block below shows all 10 sample customer rows, the customer table is on the left and is the driving table, in the detail output which join to 2 of the 3 rows in the store table.  All the rows with customer store_id greater than 2 have null/blank store column values.  

```{r SQL left join details}
customer_store_details_sloj <- dbGetQuery(con,
"select 'loj' join_type,customer_id,first_name,last_name,c.store_id c_store_id
       ,s.store_id s_store_id,s.manager_staff_id, s.address_id
   from customer c left join store s on c.store_id = s.store_id 
  where customer_id between 595 and 604;")
sp_print_df(customer_store_details_sloj)
```

### Dplyr Left Join Details {example_left-join-details-dplyr}

The next code block shows the left join details.  Note that the s_store_id column is derived via the mutate function, but not shown in the output below.  Without the s_store_id column, it might accidentally be assumed that the store.store_id = customer.store_id when the store.store_id values are actually NULL/NA based on the output without the s_store_id column.

```{r Dplyr left outer join Details}

customer_store_detail_dloj <- customer_table %>%
  left_join(store_table, by = c("store_id" = "store_id"), suffix(c(".c", ".s"))) %>%
    filter(customer_id >= 595 & customer_id <= 604 ) %>%
      mutate(join_type = "loj"
             ,s_store_id = if_else(is.na(manager_staff_id), manager_staff_id, store_id)
            ) %>%
    select(customer_id,first_name,last_name,store_id 
       ,manager_staff_id, address_id) 

sp_print_df(customer_store_detail_dloj)
```

The following code block includes the derived s_store_id value.  The output makes it explicit that the s_store_id value is missing.  The sp_print_df function is replaced with the print function to show the actual NA values.  



```{r Dplyr left outer join Details with c/s store_id}

customer_store_detail_dloj <- customer_table %>%
  left_join(store_table, by = c("store_id" = "store_id"), suffix(c(".c", ".s"))) %>%
    filter(customer_id >= 595 & customer_id <= 604 ) %>%
      mutate(join_type = "loj"
             ,s_store_id = if_else(is.na(manager_staff_id), manager_staff_id, store_id)
            ) %>%
    rename(c_store_id = store_id) %>%
    select(customer_id,first_name,last_name,c_store_id 
       ,s_store_id,manager_staff_id, address_id) 

print(customer_store_detail_dloj)
```

In the remaining examples, the `dplyr` code blocks will show both the customer and store store_id values with the either `c_` or `s_` store_id prefix .  The sp_print_df function returns the SQL NULL and R NA values as blanks.

### SQL Left Join Summary {example_left-join-summary-sql}

For a left outer join between two tables, it does matter which table is on the left and which is on the right, because every row in the left table is returned when there is no `where/filter` condition.  The second table returns row column values if the join condition exists or null collumn values if the join condition does not exist.  The left join is the most frequently used join type.

Note that SQL returns the store_id from both the customer and store tables, c.store_id,s.store_id, in the select clause.

```{r SQL Left Join Summary}
customer_store_summary_sloj <- dbGetQuery(
  con,
  "select c.store_id c_store_id,s.store_id s_store_id,count(*) loj
   from customer c left join store s on c.store_id = s.store_id
  group by c.store_id,s.store_id
  order by c.store_id;"
)

sp_print_df(customer_store_summary_sloj)
```

The lojs column returns the number of rows found on the store_id, from the customer table and the store table if on both tables, rows 1 - 2.  The right table, the store table returned blank/NA, when the key only exists in the customer table, rows 3 - 6.

1.  The left outer join always returns all rows from the left table, the driving/key table, if not reduced via a filter()/where clause.  
2.  All inner join rows can reference all columns/derived columns specified in the select clause from both the left and right tables.  
3.  All rows from the left table, the outer table, without a matching row on the right returns all the columns/derived column values specified in the select clause from the left, but the values from right table have all values of NA. 

### Dplyr Left Join Summary {example_left-join-summary-dplyr}

The dplyr outer join verbs do not return the non-driving table join values.  Compare the mutate verb s_store_id in the code block below with s.store_id in the equivalent SQL code block above.

```{r Dplyr left outer join}

customer_store_summary_dloj <- customer_table %>%
  left_join(store_table, by = c("store_id", "store_id"), suffix(c(".c", ".s"))) %>%
  mutate(
    join_type = "loj"
   ,s_store_id = if_else(is.na(manager_staff_id), manager_staff_id, store_id)
  ) %>%
  group_by(join_type, store_id, s_store_id) %>%
  summarize(n = n()) %>%
  rename(c_store_id = store_id) %>%
  select(join_type, c_store_id, s_store_id, n)

sp_print_df(customer_store_summary_dloj)
```



```{r}
print(customer_store_summary_dloj)
```

## Why Include one of the Inner Join Key columns?

It is not uncommon to have many many tables joined together as a series of left outer joins.  If the inner join key column is included in the output, one knows that the inner join condition was met or not.  If the key column is not shown and non-key columns are shown from the inner table, they may actually be null.  It is often the case that a long series of left outer joins just join on the key column to get one value out of the table to join to the next table in the series.  

One can think of the two components of an inner join as a transaction is either in an open state, no matching rows in the inner table or a closed state with one or more matching rows in the inner table.  Assume that we have a four DVD rental step process represented via table A, B, C, and D left outer joined together.  Summing the null and non-null keys together across all four tables gives a quick snap shot of the business in the four different steps.  We will review this concept in some detail in one of the future exercises.

## Right Joins

### SQL Right Join Details {example_right-join-details-sql}

The SQL block below shows only our sample customer rows, (customer_id between 595 and 604). The driving table is on the right, the `store` table.  Only six of the 10 sample customer rows appear which have store_id = {1, 2}.  All three `store` rows appear, row_id = {1,2,10}.  The right join is least frequently used join type.

```{r SQL right join details}
customer_store_detail_sroj <- dbGetQuery(con,
"select 'roj' join_type,customer_id,first_name,last_name,c.store_id c_store_id
       ,s.store_id s_store_id,s.manager_staff_id, s.address_id
   from customer c right join store s on c.store_id = s.store_id 
where coalesce(customer_id,595) between 595 and 604;")
sp_print_df(customer_store_detail_sroj)
```

Compare the SQL left join where clause

    where customer_id between 595 and 604;")
    
with the SQL right join where clause 

    where coalesce(customer_id,595) between 595 and 604;")
    
The `customer` table is the driving table in the left join and always returns all rows from the `customer` table on the left that match the join and satisfy the where clause.  The `store` table is the driving table in the right join and always returns all rows from the `store` table on the right that match the join and satisfy the where clause.  The right outer join condition shown always returns the `store.store_id=10` row.  Since the customer table does not have the corresponding row to join to, the right outer join return a customer row with all null column values.  The `coalesce` is a NULL if-then-else test.  If the customer_id is null, it returns 595 to prevent the store_id = 10 row from being dropped from the result set.

The right outer join clause can be rewritten as
```
     where customer_id between 595 and 604 or customer_id is null;
```

See the next dplyr code block to see the alternative where clause shown above.

### Dplyr Right Join Details {example_right-join-details-dplyr}

```{r Dplyr Right outer join Details}

customer_store_detail_droj <- customer_table %>%
  right_join(store_table, by = c("store_id" = "store_id"), suffix(c(".c", ".s"))) %>%
    filter((customer_id >= 595 & customer_id <= 604) | is.na(customer_id)) %>%
      mutate(join_type = "roj"
             ,c_store_id = if_else(is.na(customer_id), customer_id, store_id)
            ) %>%
    rename(s_store_id = store_id) %>%
    select(customer_id,first_name,last_name,s_store_id 
       ,c_store_id,manager_staff_id, address_id) 

sp_print_df(customer_store_detail_droj)
```

### SQL Right Outer Join Summary {example_right-join-summary-sql}

```{r SQL Right Outer Join Summary}
customer_store_summary_sroj <- dbGetQuery(
  con,
  "select 'roj' join_type,c.store_id c_store_id,s.store_id s_store_id,count(*) rojs
   from customer c right outer join store s on c.store_id = s.store_id
  group by c.store_id,s.store_id
order by s.store_id;"
)
sp_print_df(customer_store_summary_sroj)
```

The rojs column returns the number of rows found on the keys from the right table, `store`, and the left table, the `customer` table.    

1.  The right outer join always returns all rows from the right table, the driving/key table, if not reduced via a filter()/where clause.  
2.  All rows that inner join returns all the columns/derived columns specified in the select clause from both the left and right tables.  
3.  All rows from the right table, the outer table, without a matching row on the left returns all the columns/derived column values specified in the select clause from the right, but the values from left table have all values of NA.  This line 3, store.store_id = 10. 

### dplyr Right Join Summary {example_right-join-summary-dplyr}

```{r right outer join summary}
customer_store_summary_droj <- customer_table %>%
  right_join(store_table, by = c("store_id", "store_id"), suffix(c(".c", ".s")), all = store_table) %>%
  mutate(
    c_store_id = if_else(is.na(customer_id),customer_id, store_id)
    , join_type = "rojs"
  ) %>%
    group_by(join_type, store_id,c_store_id) %>%
    summarize(n = n()) %>% 
    rename(s_store_id = store_id) %>%
    select(join_type, s_store_id,c_store_id, n)

sp_print_df(customer_store_summary_droj)
```

## Full Join

### SQL Full Join Details {example_full-join-details-sql}

The full outer join is a conbination of the left and right outer joins and returns all matched and unmatched rows from the `ON` clause.  The matched rows return their table column values and the unmatched rows return NULL column values.  This can result in a very large result set.

The next SQL block implements a full outer join and returns 12 rows.  Change the `Show entries` from 10 to 25 to see all the entries.  

```{r SQL full outer join details}
customer_store_details_sfoj <- dbGetQuery(con,
  "select 'foj' join_type, c.customer_id,c.first_name,c.last_name,c.store_id c_store_id
          ,s.store_id s_store_id,s.manager_staff_id,s.address_id
     from customer c full outer join store s on c.store_id = s.store_id 
    where coalesce(c.customer_id,595) between 595 and 604;")
sp_print_df(customer_store_details_sfoj)
```

### Dplyr Full Join Details {example_full-join-details-sql}

```{r Dplyr Full Join Details}

customer_store_detail_dfoj <- customer_table %>%
  full_join(store_table, by = c("store_id" = "store_id"), suffix(c(".c", ".s"))) %>%
    filter((customer_id >= 595 & customer_id <= 604) | is.na(customer_id)) %>%
      mutate(join_type = "roj"
             ,c_store_id = if_else(is.na(customer_id), customer_id, store_id)
            ) %>%
    rename(s_store_id = store_id) %>%
    select(customer_id,first_name,last_name,s_store_id 
       ,c_store_id,manager_staff_id, address_id) 

sp_print_df(customer_store_detail_dfoj)
```

### SQL Full Join Summary {example_full-join-summary-sql}

The result set below is ordered by the store.store_id.  

```{r SQL Full  Join Summary}
customer_store_summary_sfoj <- dbGetQuery(
  con,
  "select 'foj' join_type,c.store_id c_store_id,s.store_id s_store_id,count(*) fojs
   from customer c full outer join store s on c.store_id = s.store_id
  group by c.store_id,s.store_id
order by s.store_id,c.store_id;"
)
sp_print_df(customer_store_summary_sfoj)
```

### Dplyr Full Join Summary {example_full-join-summary-dplyr}

The full outer join summary seven rows.  Store_id = {1,2} appear in both table tables.  Store_id = {3 - 6} appear only in the customer table which is on the left.  Store_id = 10 appears only in the `store` table which is on the right.

```{r Dplyr full outer join}

customer_store_summary_dfoj <- customer_table %>%
  full_join(store_table, by = c("store_id", "store_id"), suffix(c(".c", ".s"))) %>%
  mutate(join_type = "fojs"
        ,c_store_id = if_else(is.na(customer_id),customer_id, store_id)         
        ,s_store_id = if_else(is.na(manager_staff_id), manager_staff_id, store_id)) %>%
  group_by(join_type,c_store_id, s_store_id) %>%
  summarize(n = n()) %>%
    arrange(s_store_id)

sp_print_df(customer_store_summary_dfoj)
```

## Semi Join 

Below is the `dplyr` semi_join documentation.

```
semi_join()
return all rows from x where there are matching values in y, keeping just columns from x.

A semi join differs from an inner join because an inner join will return one row of x for each matching row of y, where a semi join will never duplicate rows of x.
```

The semi join always returns one and only one row from the x table that satisfies the inner join condition.  If we look at one key value on both x and y where the x table has 1 x.key row and y and n y.key rows, then the inner join returns n x.key rows, (1-to-n), and the semi-join returns just one x.key row, (1-to-1).

### SQL Semi Join Customer to Store {example_semi-join-sql-1}

SQL does not have an explicity 'semi join' key word.  The `semi join` reduces relationships from 1-to-n to 1-to-1.  SQL uses an EXISTS - subquery syntax to implement the `semi join`.

#### SQL EXISTS and Correlated SubQuery Syntax 

```
select * 
  FROM table1 l
 WHERE EXISTS(SELECT 1 FROM table2 r where l.c = r.c)
 
The EXISTS keyword checks if one or more rows satsify the SELECT clause enclosed in parenthesis, the correlated subquery.  The r.c column from table2, the inner/right table, is correlated to the l.c column from table1, the outer/left table. 
```

For all the table1 rows where the  EXISTS clause returns TRUE, the table1 rows are returned.   There is no way to reference table2 columns in the outer select, hence the semi join. 

All the previous joins were mutating joins, the joins resulted in a blending of columns from both tables.  A semi join only returns rows from a single table and is a filtering join. The mutating examples included a count column to show the 1-to-n relationships.  Filtering joins are 1-to-1 and the count column  is dropped in the following examples.

```{r SQL Semi Join 1}
customer_store_ssj <- dbGetQuery(con,
"select 'sj' join_type,customer_id,first_name,last_name,c.store_id c_store_id
   from customer c 
  where customer_id > 594 
    and exists( select 1 from store s where c.store_id = s.store_id);
;")
sp_print_df(customer_store_ssj)
```

Note that this returned the six rows from the customer table that satisfied the c.store_id = s.store_id join condition.  It is the same as the SQL Inner Join example earlier, but without the store columns.  All the relationships are 1-to-1.

### Dplyr Semi Join Customer to Store {example_semi-join-dplyr-1}

The corresponding Dplyr version is shown in the next code block.

```{r Dplyer semi join Customer to Store}
customer_store_dsj <- customer_table %>% 
  semi_join(store_table, by = c("store_id" = "store_id"), suffix(c(".c", ".s"))) %>%
    filter(customer_id >= 595 & customer_id <= 604 ) %>%
    mutate(join_type = 'sj') %>%
    select(join_type,customer_id,first_name,last_name,store_id 
       ,store_id) 
sp_print_df(customer_store_dsj)
```

### SQL Semi Join Store to Customer {example_semi-join-sql-2}

In the following Semi Join, the driving table is switched to the `store` table and our 10 sample customers as the right table.  

```{r SQL Semi Join Store-Customer}
store_customer_detail_ssj <- dbGetQuery(con,
"select 'sj' join_type,s.store_id s_store_id,s.manager_staff_id, s.address_id
   from store s
  where  EXISTS(select 1 
                 from customer c 
                where c.store_id = s.store_id 
                  and c.customer_id between 595 and 604
                )
;")
sp_print_df(store_customer_detail_ssj)
```

Here we see that we get the two rows from the store table that satisfy the s.store_id = c.store_id, store_id = {1,2}.  In this example the relationship between store and customer is 1-to-n, but we do not know that from the output.

### Dplyr Semi Join Store to Customer {example_semi-join-dplyr-2}

The corresponding Dplyr version is shown in the next code block.  Note that the filter condition on the customer table has been removed because the semi_join does not return any customer columns.

```{r Dplyer semi join Store to Customer}
store_customer_dsj <-  store_table %>%
  semi_join(customer_table, by = c("store_id" = "store_id"), suffix(c(".c", ".s"))) %>%
    mutate(join_type = 'sj') %>%
    select(join_type,store_id,manager_staff_id, address_id) 
sp_print_df(store_customer_dsj)
```

### SQL Semi Join Store to Customer Take 2 {example_semi-join-sql-3}

In the `Semi Join Customer to Store` examples, we saw four rows with store_id = 1 and two rows with store_id = 2.  The EXISTS key word is replaced with a count of the matching rows.  

```{r SQL Semi Join Store-Customer Take 2}
store_customer_detail_ssj2 <- dbGetQuery(con,
"select 'sj' join_type,s.store_id s_store_id,s.manager_staff_id, s.address_id
   from store s
  where (select count(*)
           from customer c 
          where c.store_id = s.store_id 
            and c.customer_id between 595 and 604
         ) in (2,4)
;")
sp_print_df(store_customer_detail_ssj2)
```

To generalize the test above, replace `in {2,4}` with `> 0`.  

## Anti Joins

A `semi join` returns rows from one table that has one or more matching rows in the other table.  The `anti join` returns rows from one table that has no matching rows in the other table.    

#### dplyr anti Join {example_anti-join-dplyr}

The anti join is an outer join without the inner joined rows.  It only returns the rows from the driving table that do not have a matching row from the other table.  

```{r dplyr anti Join}

customer_store_aj <- customer_table %>% 
    filter(customer_id > 594) %>%
    anti_join(store_table, by = c("store_id", "store_id"), suffix(c(".c", ".s"))) %>%
    mutate(join_type = "anti_join")  

sp_print_df(customer_store_aj)
```

All of the rows returned from the customer table have store_id = {3 - 6} which do not exist in the store_id.

#### SQL anti Join 1, NOT EXISTS and Correlated subquery {example_anti-join-sql-1}

SQL doesn't have an anti join key word.  Here are three different ways to achieve the same result.

This is the negation of the same construct used in the semi join discusion.  The anit-join tests for 0 matches instead of 1 or more matches for the semi-join.

```{r SQL anti Join 1}
rs <- dbGetQuery(
  con,
  "select 'aj' join_type, customer_id, first_name, last_name, c.store_id
   from customer c 
  where not exists (select 1 from store s where s.store_id = c.store_id)
order by c.customer_id
"
)
sp_print_df(rs)
```

#### SQL anti Join 2, Left Outer Join where NULL on Right {example_anti-join-sql-1}

```{r SQL anti Join 2}
rs <- dbGetQuery(
  con,
  "select 'aj' join_type, customer_id, first_name, last_name, c.store_id ajs
   from customer c left outer join store s on c.store_id = s.store_id
  where s.store_id is null
order by c.customer_id;"
)
sp_print_df(rs)
```

#### SQL anti Join 3, ID in driving table and NOT IN lookup table {example_anti-join-sql-3}

```{r SQL anti Join 3}
rs <- dbGetQuery(
  con,
  "select 'aj' join_type, customer_id, first_name, last_name, c.store_id
   from customer c 
  where c.store_id NOT IN (select store_id from store)
order by c.customer_id;"
)
sp_print_df(rs)

```


<!-- Show all different joins together with filter to allow comparison between different mutating joins

```{r testit, results='hide'}
customer_store_summary_dfoj %>%
    union(customer_store_summary_droj) %>%
    union(customer_store_summary_dloj) %>%
    union(customer_store_summary_dij) %>%
    arrange(join_type,s_store_id,c_store_id)
```

```{r}
sp_print_df(customer_store_summary_dfoj)
```

```{r  results='hide'}
customer_store_details_sij %>%
union(customer_store_details_sloj) %>%
union(customer_store_detail_sroj) %>%
union(customer_store_details_sfoj) %>%
arrange(join_type,s_store_id)
```
```{r}
sp_print_df(customer_store_details_sij)
```

--->

## Non-Equa-Join Example

All the previous examples are equa-joins and is the most common type of join.  The next example is made up and shows a '<=' join.  The `store` table is usd.  Assume that the store_id actually represents some distance.  The example shows all distances <= to all other distances.   

```{r}
store_store_slej <- dbGetQuery(
  con,
  "select 'lej' join_type,s1.store_id starts,s2.store_id stops, s2.store_id - s1.store_id delta
   from store s1 join store s2 on s1.store_id <= s2.store_id
order by s1.store_id;"
)
sp_print_df(store_store_slej)
```

### Dplyr Non-equa Join {example_inner-join-dplyr}

Dplyr doesn't currently support a non-equa join.  In the by parameter, one can not change the '=' to '<=' as shown below.


``` 
{r}

store_store_slej <- store_table %>%
  inner_join(store_table, by =  c("store_id" <= "store_id"), suffix(c(".c", ".s"))) 
    
```

The above code block throws the following error message.

```
Error: `by` must be a (named) character vector, list, or NULL for natural joins (not 
recommended in production code), not logical Call `rlang::last_error()` to see a backtrace
```

The explaination below is from [here](https://stackoverflow.com/questions/47485779/dplyr-joins-how-do-you-do-a-non-standard-join-col1-col2-when-working-with) and it was posted Nov 25 '17.


In by = c("col1" = "col2"),  = is not and equality operator, but an assignment operator (the equality operator in R is ==). The expression inside c(...) creates a named character vector (name: col1 value: col2) that dplyr uses for the join. Nowhere do you define the kind of comparison that is made during the join, the comparison is hard-coded in dplyr. I don't think dplyr supports non-equi joins (yet).

```{r}
# diconnect from the db
 dbDisconnect(con)

 sp_docker_stop("sql-pet")
```

```{r}
knitr::knit_exit()
```




