SQL Joins exercises {#chapter_sql-joins-exercises}

<!-- 

-->

> This chapter demonstrates how to:
> 
> * Use primary and foreign keys to retrieve specific rows of a table
> * do different kinds of join queries
> * Exercises
> * Query the database to get basic information about each dvdrental story
> * How to interact with the database using different strategies

The DVD rental database data is too clean to demonstrate some join concepts.  To dirty the data, this chapter performs a number of database operations on data tables that a data analyst is typically restricted from doing.  

1.  Deleting records from tables.
2.  Inserting records from tables.
3.  Enabling and disabling table constraints.





```{r setup, echo=FALSE, message=FALSE, warning=FALSE}
# These packages are called in almost every chapter of the book:
library(tidyverse)
library(DBI)
library(RPostgres)
library(glue)
library(here)
require(knitr)
library(dbplyr)
library(sqlpetr)
```

Verify Docker is up and running:
```{r}
sp_check_that_docker_is_up()
```

Verify pet DB is available, it may be stopped.

```{r}
sp_show_all_docker_containers()
```

Start up the `docker-pet` container

```{r}
sp_docker_start("sql-pet")
```

Now connect to the database with R

```{r}
# need to wait for Docker & Postgres to come up before connecting.

con <- sp_get_postgres_connection(
  user = Sys.getenv("DEFAULT_POSTGRES_USER_NAME"),
  password = Sys.getenv("DEFAULT_POSTGRES_PASSWORD"),
  dbname = "dvdrental",
  seconds_to_test = 30
)
```

## Table Structures

### Customer Columns

In an earlier chapter we used functions dbListTable and dbListFields from the DBI package to get a list of tables and the fields in a table.  Below we list out the columns from the customer table.

```{r}
dbListFields(con, "customer")

```

A couple of things immediately jump out based on the column names:

1.  There are three *_id columns, customer_id, store_id, and address_id.  ID columns are typically an integer type.  It is common convention to have the table primary key column(s) at the beginning of the table or a set of columns at the beginning of the table that make the row unique.

  *  Just looking at the column names, one cannot tell if the customer is uniquely identified by just the customer_id or the customer_id + store_id.  Are there customers who visit both stores?
  
2.  Based on the column names, it looks like there are three string/character columns, first_name, last_name, and email.  
*  What are the sizes of these colums?

3.  Two dates, create_date and last_update.
4.  Two active columns, `activebool` and `active`.  The activebool looks like it is a boolean column.  What type of column is active, integer or text?

Databases maintains a data dictionary of metadata on all the database objects.  SQL databases have two useful tables for getting table and table column information, `information_schema.tables` and `information_schema.columns`.

```{r}
tables <- dbGetQuery(con
         ,"Select t.table_catalog
                 ,t.table_schema
                 ,t.table_type
                 ,count(*) count
             from information_schema.tables t
           group by t.table_catalog
                   ,t.table_schema
                   ,t.table_type
           order by t.table_catalog
                   ,t.table_schema
                   ,t.table_type
          ")
sp_print_df(tables)

info_schema <- dbGetQuery(con
         ,"Select t.table_catalog
                 ,t.table_schema
                 ,t.table_name
                 ,t.table_type
             from information_schema.tables t
            where t.table_schema = 'information_schema'
              and table_name in ('tables','columns')
          ")

sp_print_df(info_schema)
```


The next code block uses the `information_schema.columns` to return column information from any table in the dvdrental database.  


```{r}
table_str_sql <- function (table_name) {
dbGetQuery(
       con,
       "select c.table_name, c.ordinal_position seq
             , c.column_name
             , case when c.udt_name = 'varchar' 
                    then c.udt_name ||
                         case when c.character_maximum_length is not null 
                              then '('||cast(c.character_maximum_length as varchar)||')'
                              else ''
                         end 
                    when c.udt_name like ('int%')
                    then c.udt_name ||'-'||cast(c.numeric_precision as varchar)
                    else c.udt_name 
               end column_type
             , c.is_nullable 
             , c.column_default
--             , t.table_catalog,t.table_schema
          from dvdrental.information_schema.columns c
               join information_schema.tables t on c.table_name = t.table_name
         where 1 = 1 
           and c.table_catalog = 'dvdrental' 
           and c.table_name = $1"
       ,table_name
       )
}    
```

```{r}
table_str_sql('tables')

```

The next code block returns the customer metadata via a call to the previous function.

```{r}
table_str_sql('customer')
```

The metadata tells us the length of the three varchar, variable length, columns.  We can see that our two date columns are of different types, date and timestamp.  `is_nullable=NO` tells us the column is required to have a non-null value otherwise it can be null.  The database returns a default value if one is not supplied on insertion of a new row.

The `activebool` is either true or false.  Without a definitive description of the column, we will assume that the customer is active, `activebool=true` or inactive, `activebool=false.`  The active column, an int4 data type, can take on a large set of values. We cannot even venture a guess as to what this column tells us or its use.

As the business changes:

1.  The business re-purposes a column in a table and the column definition changes.
2.  New columns are added to tables to reflect new requirements of the business.  Sometimes new columns are just added to the end of the table and sometimes the table structure is modified so the new columns are logically next to similar columns.  If a table is wide and the new column is at the end, it is very easy to miss the new column when having to scroll across the screen to find it.

### Other Table Column Metadata

In the next code block, change the function parameter to different table names to get the associated column metadata.  Uncomment the dbListTable line to get a list of table names.

```{r}
dbListTables(con)
table_str_sql('customer')
```

## Primary and Foreign Key Constraints

The database or application designers implement constraints to help maintain referential integrity and improve performance.  One is the implementation of a primary key which must be unique for each row in the table.  The primary key is usually defined as the first column.  On occasion the primary key consists of multiple columns and none of these columns cannot be null.  

From the DVD Rental ERD, [here](https://www.postgresqltutorial.com/postgresql-sample-database), one can see that out of the 15 tables in the ERD, all but two tables have a single column primary key, film_category and the film_actor tables have two columns that define the primary key. The primary key columns have an asterisk to the left of the column name.  For the single column keys, the primary key column is the name of the table suffixed with `_id.`

The other constraint is a foreign key constraint which is one or more columns in one table that make up a primary key in another table.  

The following SQL code block returns a tables primary and foreign keys.

```{r tbl_pk_fk_sql}
tbl_pk_fk_sql <- function(table_name) {
    dbGetQuery(con
              ,"SELECT c.table_name
                      ,kcu.column_name
                      ,c.constraint_name
                      ,c.constraint_type
                      ,coalesce(c2.table_name, '') ref_table
                      ,coalesce(kcu2.column_name, '') ref_table_col
                  FROM information_schema.tables t
                       LEFT JOIN information_schema.table_constraints c
                         ON t.table_catalog = c.table_catalog
                        AND t.table_schema = c.table_schema
                        AND t.table_name = c.table_name
                       LEFT JOIN information_schema.key_column_usage kcu
                         ON c.constraint_schema = kcu.constraint_schema
                        AND c.constraint_name = kcu.constraint_name
                       LEFT JOIN information_schema.referential_constraints rc
                         ON c.constraint_schema = rc.constraint_schema
                        AND c.constraint_name = rc.constraint_name
                       LEFT JOIN information_schema.table_constraints c2
                         ON rc.unique_constraint_schema = c2.constraint_schema
                        AND rc.unique_constraint_name = c2.constraint_name
                       LEFT JOIN information_schema.key_column_usage kcu2
                         ON c2.constraint_schema = kcu2.constraint_schema
                        AND c2.constraint_name = kcu2.constraint_name
                        AND kcu.ordinal_position = kcu2.ordinal_position
                 WHERE c.constraint_type IN ('PRIMARY KEY', 'FOREIGN KEY')
                   AND c.table_catalog = 'dvdrental'
                   AND c.table_schema = 'public'
                   AND (c.table_name = $1 or coalesce(c2.table_name, '') = $1)
               ORDER BY c.table_name,c.constraint_type desc"
              ,param = list(table_name)
              )
}

```

### Customer primary and foreign key constraints

```{r}
tbl_pk_fk_sql('country')
```

When we initially looked at the customer columns, it was unclear if the primary key is `customer_id` or `customer_id` + `store_id`.  The table above tells us:

1.  The customer has customer_id as the primary key.
2.  The customer address_id is a foreign key to the address table, the ref_table column and joins on the ref_table_col, address_id.
3.  The payment and rental tables have customer_id as a foreign key back to the customer table.

The output above shows that the store_id column is not part of the customer primary key and it isn't foreign key to the store table.  

Look at the customer and store tables in the dvdrental system [here](https://www.postgresqltutorial.com/postgresql-sample-database).  It certainly looks like the customer store_id column links to the store table via the store_id column.  The ERD matches the Primary and Foreign Key information in the table above.

## We need documentation and/or a DBA.

The DBA team or project documentation may help explain the true relation between the customer and store tables.

Some possible explanations are:

1.  The ERD is incomplete or it excluded some foreign keys to highlight other relationships.
2.  The SQL above is wrong.
3.  The customer-store foreign key constraint was just missed.  On large systems this is not out of the realm of possibilities.
4.  The customer-store foreign key constraint was diabled.
5.  The customer-store foreign key constraint was designed out of the system.







[dvdrental grandfather](https://dev.mysql.com/doc/sakila/en/sakila-structure.html)

## Exercises

### 1. Where is the DVD Rental Business located?

To answer this question we look at the `store`, `address`, `city`, and `country` tables to answer this question.

```{r}
store_locations_sql <- dbGetQuery(con,
"select s.store_id
       ,a.address
       ,c.city
       ,a.district
       ,a.postal_code
       ,c2.country
       ,s.last_update
   from store s 
         join address a on s.address_id = a.address_id
         join city c on a.city_id = c.city_id
         join country c2 on c.country_id = c2.country_id
")
sp_print_df(store_locations_sql)
```

The DVD Rental business is international and operates in three countries, Canada, Austraila, and the United States.  Each country has one store.  The first two stores have a single employee.  The third store has no employees  yet.  Has this store recently closed or not yet opened?  The third store has a current last_update column.  It is most likely it has not yet opened.

#### Replicate the output above using dplyr syntax.

```{r}
store_table <- DBI::dbReadTable(con, "store")
address_table <- DBI::dbReadTable(con, "address")
city_table <- DBI::dbReadTable(con, "city")
country_table <- DBI::dbReadTable(con,"country")

store_locations_dplyr <- store_table %>%
    inner_join(address_table, by = c("address_id" = "address_id"), suffix(c(".s", ".a"))) %>%
    inner_join(city_table, by = c("city_id" = "city_id"), suffix(c(".a", ".c"))) %>%
    inner_join(country_table, by = c("country_id" = "country_id"), suffix(c(".a", ".c"))) %>%
    select (store_id,address,city,district,postal_code,country,last_update.x)
sp_print_df(store_locations_dplyr)
```
<!--
Discuss how to access common named columns.  Last_update.x above.  Figure out the mechanics of finding the suffix needed.
-->

### 2. How Many Employees Work in Each Store?  What is their contact information?

To answer this question we look at the `staff`, `address`, `city`, and `country` tables.


```{r}
store_employees_sql <- dbGetQuery(con,
"select s.first_name
       ,s.last_name
       ,s.email
       ,a.phone
       ,a.address
       ,c.city
       ,a.district
       ,a.postal_code
       ,c2.country
   from staff s 
         join address a on s.address_id = a.address_id
         join city c on a.city_id = c.city_id
         join country c2 on c.country_id = c2.country_id
")
sp_print_df(store_employees_sql)

```


The DVD Rental business is international and operates in three countries, Canada, Austraila, and the United States.    

#### Replicate the output above using dplyr syntax.

```{r}
staff_table <- DBI::dbReadTable(con, "staff")
address_table <- DBI::dbReadTable(con, "address")
city_table <- DBI::dbReadTable(con, "city")
country_table <- DBI::dbReadTable(con,"country")

store_locations_dplyr <- staff_table %>%
    inner_join(address_table, by = c("address_id" = "address_id"), suffix(c(".s", ".a"))) %>%
    inner_join(city_table, by = c("city_id" = "city_id"), suffix(c(".a", ".c"))) %>%
    inner_join(country_table, by = c("country_id" = "country_id"), suffix(c(".a", ".c"))) %>%
    select (first_name,last_name,email,phone,address,city,district,postal_code,country,last_update.x)
sp_print_df(store_locations_dplyr)
```

### 3. How Many Customers Does the DVD Rental Business Have?

```{r}
customer_cnt_sql <- dbGetQuery(con,
"SELECT count(*) customers from customer")

sp_print_df(customer_cnt_sql)
```

#### Replicate the output above using dplyr syntax.

```{r}
customer_table <- DBI::dbReadTable(con, "customer")

customer_cnt_dplyr <- customer_table %>%
    summarize(customers=n())

sp_print_df(customer_cnt_dplyr)
```

### 4. How Many Customers Are In Each Country?

We know that the DVD rental business has three stores, two active, and 604 customers.  The two stores are located in Canada and Australia.   

```{r}
customers_sql <- dbGetQuery(con,
                            
"select *
       ,sum(pct) over (order by pct desc rows between unbounded preceding and current row) running_pct
       ,sum(count) over (order by count desc rows between unbounded preceding and current row) running_total
  from (select c.active,country.country,count(*) count
              ,round(100 * count(*) / sum(count(*)) over(),4) as pct
         from customer c
              join address a on c.address_id = a.address_id
              join city  on a.city_id = city.city_id
              join country on city.country_id = country.country_id
         group by c.active,country
       ) ctry
 order by count desc
")
sp_print_df(customers_sql)
```

Based on the table above, the DVD Rental business has customers in 118 countries.  The DVD Rental business cannot have many walk in customers.  It must use a mail order distribution model.

#### Replicate the output above using dplyr syntax.

```{r}
customer_table <- DBI::dbReadTable(con, "customer")
address_table <- DBI::dbReadTable(con, "address")
city_table <- DBI::dbReadTable(con, "city")
country_table <- DBI::dbReadTable(con,"country")

customers_dplyr <- customer_table %>%
    inner_join(address_table, by = c("address_id" = "address_id"), suffix(c(".s", ".a"))) %>%
    inner_join(city_table, by = c("city_id" = "city_id"), suffix(c(".a", ".c"))) %>%
    inner_join(country_table, by = c("country_id" = "country_id"), suffix(c(".a", ".c"))) %>%
    group_by(active,country) %>%
    summarize(count=n()) %>%
    mutate(total=nrow(customer_table)
          ,pct=round(100 * count/total,4)
          ) %>%
    arrange(desc(count)) %>%
    mutate(running_pct=cumsum(pct)
          ,running_total=cumsum(count)) %>%
    select (country,count,total,pct,running_pct,running_total) 
sp_print_df(customers_dplyr)
```


### 5. How many customers are in Australia and Canada?

```{r}
customers_sql %>% filter(country == 'Australia' | country == 'Canada')
```

The two countries with a store have less the 2% of the business' customer world wide base.  

### 6. How Many Languages?

With an international customer base, how many languages does the DVD Rental business distribute DVD's in.

To answer this question we look at the `language` table.

```{r}
languages_sql <- dbGetQuery(con,
"
select * from language
")

sp_print_df(languages_sql)
```

#### Replicate the output above using dplyr syntax.

```{r}
language_table <- DBI::dbReadTable(con, "language")

sp_print_df(language_table)
```

### 7.  What is the distribution of DVD's by Language 

```{r}
language_distribution_sql <- dbGetQuery(con,
'
select l.language_id,name "language",count(f.film_id)
  from language l left join film f on l.language_id = f.language_id
group by l.language_id,name
order by l.language_id
')

sp_print_df(language_distribution_sql)
```

The DVD Rental business has three stores, two open.  Each open store has one employee each.  The customer base is in 118 countries.  The current stock of 1000 DVD's are all in English only.  

#### Replicate the output above using dplyr syntax.

```{r}
language_table <- DBI::dbReadTable(con, "language")
film_table <- DBI::dbReadTable(con, "film")

language_distribution_dplyr <- language_table %>%
    left_join(film_table, by = c("language_id" = "language_id"), suffix(c(".s", ".a"))) %>%
    group_by(language_id,name) %>%
    summarize(count = sum(!is.na(title)))
sp_print_df(language_distribution_dplyr)
```

### 8.  Rank Films Based on the Number of Times Rented

To answer this question we look at the `rental`, `inventory`, and `film` tables.

```{r}
film_rank_sql <- dbGetQuery(con,
"select f.film_id,f.title,count(*) 
   from rental r join inventory i on r.inventory_id = i.inventory_id
        join film f on i.film_id = f.film_id
 group by f.film_id,f.title
 order by count(*) desc")

sp_print_df(film_rank_sql)
```

#### Replicate the output above using dplyr syntax.

```{r}
rental_table <- DBI::dbReadTable(con, "rental")
inventory_table <- DBI::dbReadTable(con, "inventory")
film_table <- DBI::dbReadTable(con, "film")

film_rank_dplyr <- rental_table %>%
    inner_join(inventory_table, by = c("inventory_id" = "inventory_id"), suffix(c(".r", ".i"))) %>%
    inner_join(film_table, by = c("film_id" = "film_id"), suffix(c(".f", ".i"))) %>%
    group_by(film_id,title) %>%
    summarize(count = n()) %>%
    arrange(desc(count))
sp_print_df(film_rank_dplyr)
```

### 9.  DVD rental distribution.

DVD's get scratched or wear out through use.  The store managers would like to replace any DVD that has been rented more than 25 times.  This is similar to the previous exercise.  Instead of looking at the film level, it looks at the DVD level.

To answer this question we look at the `rental`, `inventory`, and `film` tables again.

```{r}
DVD_rank_sql <- dbGetQuery(con,
"select i.inventory_id,f.title,count(*) 
   from rental r join inventory i on r.inventory_id = i.inventory_id
        join film f on i.film_id = f.film_id
 group by i.inventory_id,f.title
 order by count(*) desc")

sp_print_df(DVD_rank_sql)
```

No DVD is close to needing to be replaced.

#### Replicate the output above using dplyr syntax.

```{r}
rental_table <- DBI::dbReadTable(con, "rental")
inventory_table <- DBI::dbReadTable(con, "inventory")
film_table <- DBI::dbReadTable(con, "film")

DVD_rank_dplyr <- rental_table %>%
    inner_join(inventory_table, by = c("inventory_id" = "inventory_id"), suffix(c(".r", ".i"))) %>%
    inner_join(film_table, by = c("film_id" = "film_id"), suffix(c(".f", ".i"))) %>%
    group_by(inventory_id,title) %>%
    summarize(count = n()) %>%
    arrange(desc(count))
sp_print_df(DVD_rank_dplyr)
```

```{r}
DVD_rental_distribution_sql <- dbGetQuery(con,
"select rented,count(*)
   from (
 select i.inventory_id,f.title,count(*) rented
   from rental r join inventory i on r.inventory_id = i.inventory_id
        join film f on i.film_id = f.film_id
 group by i.inventory_id,f.title) dvd
group by rented
 

sp_print_df(DVD_rank_sql)
```


There are two columns `activebool`, boolean, and `active`, integer, in the customer table.  We do not have a description for these two columns. Just based on the column names, they are some kind of customer active or inactive flag.  Earlier we saw that the `active` is an int4 data type.  An int4 takes on a large range of values.

1.  What is the distribution of the different activbool and active column values?  
2.  An int4 takes on a large range of values.  How many values does the active column take on.

```
sum analytic

SUM(quantity) OVER ({PARTITION BY partition column} {ORDER BY {order columns})
```

### Active SQL Analysis

In this code block summarize the activebool and active value combinations as a count of the two values combinations, a percent, and a running total.

```{r Active SQL Analysis}
active_sql <- dbGetQuery(
  con,
  "select c.activebool
         ,c.active,count(*), round(100 * count(*)/sum(count(*)) over (),2) as pct
         ,sum(count(*)) over (order by activebool, active) running_total
     from customer c
   group by c.activebool,c.active
  "
)
sp_print_df(active_sql)
```

The `activebool` column only takes on a single value, `true`.  The `active` column takes on only two values, {0,1}.  

Dplyr order_by

```
Description

This function makes it possible to control the ordering of window functions in R that don't have a specific ordering parameter. When translated to SQL it will modify the order clause of the OVER function.

Usage

order_by(order_by, call)
Arguments

order_by	
a vector to order_by
call	
a function call to a window function, where the first argument is the vector being operated on
```

??? how to implement multi-column order by in example below???  If there were more than two combinations, I would like to see it ordered by all combinations

```{r active dplyr analysis}
customer_table <- DBI::dbReadTable(con, "customer")
active_dplyr <- customer_table %>% group_by(activebool,active) %>% 
    summarize(cnt=n()) %>% 
    mutate(running=order_by(active,cumsum(cnt))
          ,total=sum(cnt)
          ,pct=round(100 * cnt/total,2)
          ) %>%
select(-running)    
sp_print_df(active_dplyr)
```

```{r}
rs <- dbGetQuery(
  con,
  "select * from customer where active = 0;
  ")

sp_print_df(rs)
```

### Find the Customer Store Distribution 

```{r}

```

### Find All customers who have never rented a movie.

Businesses spend a lot of time and money converting prospects to customers.  The manager would like you to generate a list of customers who have never rented a movie.

This type of question is what dplyr calls an anti-join.  SQL doesn't have a formal anti-join, but an anti-join can be implemented in multiple ways in SQL.  In this case, the anti-join returns customer rows from a left outer join from customer to the rental table with a null rental_id.  In the next three code blocks, we show three different ways to implement an Anti-Join

#### SQL ANTI JOIN -- Null Syntax 

```{r Customer SQL Anti-Join }
customer_rental_anti_join_sql <- dbGetQuery(
  con,
  "select c.first_name
         ,c.last_name
         ,c.email
         ,c.active 
         ,c.create_date
         ,c.last_update
     from customer c
          left outer join rental r on c.customer_id = r.customer_id
    where r.rental_id is null;
  "
)
sp_print_df(customer_rental_anti_join_sql)
```

#### SQL Anti Join - Not IN Syntax

```{r Customer SQL not in }
customer_rental_not_in_sql <- dbGetQuery(
  con,
  "select c.first_name
         ,c.last_name
         ,c.email
         ,c.active 
         ,c.create_date
         ,c.last_update
     from customer c
    where c.customer_id not in (select customer_id from rental)
  "
)
sp_print_df(customer_rental_not_in_sql)
```

### SQL ANTI Join -- Not EXISTS Syntax

```{r Customer SQL not exists }
customer_rental_not_in_sql <- customer_rental_not_in_sql <- dbGetQuery(
  con,
  "select c.first_name
         ,c.last_name
         ,c.email
         ,c.active 
         ,c.create_date
         ,c.last_update
     from customer c
    where not exists (select 1 from rental r where r.customer_id = c.customer_id)
  "
)
sp_print_df(customer_rental_not_in_sql)
```

In the three previous examples, each returned 5 rows.  Note that there are two Sophie rows in the previous three examples that look like duplicates.  In the next example, the code block uses a count(*)-group by-having syntax.  The customer_cnt column shows the number of customer rows and the rentals column shows the number of rentals rows involved in the join.


```{r}
customer_rental_groupby1_sql <- dbGetQuery(
  con,
  "select c.first_name
         ,c.last_name
         ,c.email
         ,c.active 
         ,c.create_date
         ,c.last_update
         ,count(*) customer_cnt
         ,count(r.rental_id) rentals
     from customer c
          left outer join rental r on c.customer_id = r.customer_id
   group by  c.first_name
            ,c.last_name
            ,c.email
            ,c.active 
            ,c.create_date
            ,c.last_update
   having count(r.rental_id) = 0
   order by count(r.rental_id)
  "
)
sp_print_df(customer_rental_groupby1_sql)
```


In the previous example only four rows were returned because the two Sophie entries were grouped together, see the customer_cnt column.  To avoid dropping one of the Sophie records, we can add the customer_id to prevent the group by operation combining the two rows,


```{r}
customer_rental_groupby2_sql <- dbGetQuery(
  con,
  "select c.customer_id cust_id
         ,c.first_name
         ,c.last_name
         ,c.email
         ,c.active 
         ,c.create_date
         ,c.last_update
         ,count(*) cust_cnt
         ,count(r.rental_id) rentals
     from customer c
          left outer join rental r on c.customer_id = r.customer_id
   group by  c.customer_id
            ,c.first_name
            ,c.last_name
            ,c.email
            ,c.active 
            ,c.create_date
            ,c.last_update
   having count(r.rental_id) = 0
   order by c.customer_id
  "
)
sp_print_df(customer_rental_groupby2_sql)
```

Exercise 

Use the dplyr anti_join verb to find customers who have never rented a movie

```{r}
customer_table <- DBI::dbReadTable(con, "customer")
rental_table   <- DBI::dbReadTable(con, "rental")

x <- customer_table %>%
    anti_join(rental_table, by = c("customer_id" = "customer_id"), suffix(c(".c", ".r"))) %>%
    select(first_name,last_name,email,active,create_date) 

sp_print_df(x)
```

### Which customers have rented the most films

Good customers rent many DVDs.  The managers would like you to generate a list of the best customers  

In the next SQL code block, we show the top 5 customers who have rented the most films.

```{r}
customer_rental_ij_sql <- dbGetQuery(
  con,
  "select c.customer_id cust_id
         ,c.first_name
         ,c.last_name
         ,c.email
         ,c.active 
         ,c.create_date
         ,c.last_update
         ,count(r.rental_id) rentals
     from customer c
          join rental r on c.customer_id = r.customer_id
   group by  c.customer_id
            ,c.first_name
            ,c.last_name
            ,c.email
            ,c.active 
            ,c.create_date
            ,c.last_update
   order by count(r.rental_id) desc
limit 5
  "
)
sp_print_df(customer_rental_ij_sql)
```

### Exercise

Use the dplyr inner_join verb to find the top 5 customers who have rented the most movies.

```{r}
customer_table <- DBI::dbReadTable(con, "customer")
rental_table   <- DBI::dbReadTable(con, "rental")

customer_rental_ij_d <- customer_table %>%
    inner_join(rental_table, by = c("customer_id" = "customer_id"), suffix(c(".c", ".r"))) %>%
    group_by(customer_id,first_name,last_name,email,active,create_date) %>%
    summarize(rentals=n()) %>%
    arrange(desc(rentals)) %>%
    select(customer_id,first_name,last_name,email,active,create_date,rentals) %>%
    head(n=5)

sp_print_df(customer_rental_ij_d)
```

### Combining the reports

The managers love the two reports, but they would like them combined into a single report.

```{r}
customer_rental_high_low_sql <- dbGetQuery(
  con,
  "select c.customer_id cust_id
         ,c.first_name
         ,c.last_name
         ,c.email
         ,c.active 
         ,c.last_update
         ,count(*) cust_cnt
         ,count(r.rental_id) rentals
     from customer c
          left outer join rental r on c.customer_id = r.customer_id
   group by  c.customer_id
            ,c.first_name
            ,c.last_name
            ,c.email
            ,c.active 
            ,c.last_update
   having count(r.rental_id) = 0 or count(r.rental_id) > 40
   order by count(r.rental_id) desc
  "
)
sp_print_df(customer_rental_high_low_sql)
```

### Exercise 

Recreate the SQL report with a corresponding dplyr code block.

```{r}

customer_table <- DBI::dbReadTable(con, "customer")
rental_table   <- DBI::dbReadTable(con, "rental")

customer_rental_ij_d <- customer_table %>%
    left_join(rental_table, by = c("customer_id" = "customer_id"), suffix(c(".c", ".r"))) %>%
    mutate(joins = if_else(is.na(inventory_id),0, 1)) %>%
    group_by(customer_id,first_name,last_name,email,active,create_date,joins) %>%
    summarize(rentals=sum(joins)) %>%
    filter( rentals == 0 | rentals > 40) %>%
    select(customer_id,first_name,last_name,email,active,create_date,rentals) %>%
    arrange(desc(rentals))

sp_print_df(customer_rental_ij_d)
```

## Top-n1 and bottom-n2 customers 

The issue with the two previous reports is that the top end is hardcoded.  Over time, the current customers will always be in the top section and new customers will get added.  Another way of looking at the previous report is to show the top 5 and bottom 5 customers.  

The managers would like to send a special promotion to the top n1 customers and exclude the bottom n2 customer from any new promotions.

### Inline SQL Block Syntax

An Inline SQL Block is an inner SQL statement that acts like a table within an outer SQL select statement.  The inner SQL select statement is enclosed in parens, () and aliased, TBL1 and TBL2 in the following examples.  


```
Form 1:
SELECT *
  FROM (SELECT * FROM A,B,C ...) AS TBL1
      ,(SELECT * FROM X,Y,Z ...) AS TBL2
 WHERE TBL1.COL_E = TBL2.COL_E ... 

Form 2:
SELECT *
  FROM (SELECT
          FROM (SELECT *
                  FROM A,B,C ...          
               ) AS TBL1
       ) AS TBL2
```

```{r}
customer_rentals_hi_low_sql <- function(high_n,low_n) {
    customer_rental_high_low_sql <- dbGetQuery(con,
        "select *
           from (     select *
                            ,ROW_NUMBER() OVER(ORDER BY rentals desc) hi_low
                            ,ROW_NUMBER() OVER(ORDER BY rentals ) low_hi
                       FROM (    
                                 select c.customer_id cust_id
                                       ,c.first_name
                                       ,c.last_name
                                       ,c.email
                                       ,c.active 
                                       ,c.last_update
                                       ,count(*) cust_cnt
                                       ,count(r.rental_id) rentals
                                  from customer c
                                       left outer join rental r on c.customer_id = r.customer_id
                                 group by c.customer_id
                                        ,c.first_name
                                        ,c.last_name
                                        ,c.email
                                        ,c.active 
                                        ,c.last_update
                            ) as summary
                ) row_nums
           where hi_low <= $1 or low_hi <= $2
          order by hi_low
        "
           ,c(high_n,low_n)
        )
    return (customer_rental_high_low_sql)
}
```

The next code block executes the function above.  With top_n = 5 and bot_n = 5, it replicates the hard coded version of the report. Change the two parameters to see the output from the different combinations.

```{r}
top_n = 5
bot_n = 5
sp_print_df(customer_rentals_hi_low_sql(top_n,bot_n))
```

## Exercise

Replicate the function above use dplyr syntax.

```{r}
customer_rentals_hi_low_dplr <- function(high_n,low_n) {
    customer_table <- DBI::dbReadTable(con, "customer")
    rental_table   <- DBI::dbReadTable(con, "rental")
    
    customer_rental_loj_hi_low_d <- customer_table %>%
        left_join(rental_table, by = c("customer_id" = "customer_id"), suffix(c(".c", ".r"))) %>%
        mutate(joins = if_else(is.na(inventory_id),0, 1)) %>%
        group_by(customer_id,first_name,last_name,email,active,create_date,joins) %>%
        summarize(rentals=sum(joins)) %>%
        select(customer_id,first_name,last_name,email,active,create_date,rentals) %>%
        arrange(desc(rentals)) 
    
    customer_rental_loj_hi_low_d <- cbind(customer_rental_loj_hi_low_d
                                         ,hi_low = 1:nrow(customer_rental_loj_hi_low_d)
                                         ,low_hi = nrow(customer_rental_loj_hi_low_d):1
                                         )
    customer_rental_loj_hi_low_d %>% 
        filter(hi_low <= high_n | low_hi <= low_n) %>%
        arrange(hi_low)
    
}
```

```{r}
top_n = 0
bot_n = 10
sp_print_df(customer_rentals_hi_low_dplr(top_n,bot_n))
```

### SQL Rows Per Table 

In the examples above, we looked at how many rows were involved in each of the join examples and which side of the join they came from.  It is often helpful to know how many rows are in each table as a sanity check on the joins.  

Below is the SQL version to return all the row counts from each table in the DVD Rental System.

```{r}
rs <- dbGetQuery(
  con,
  "select *
                 from (      select 'actor' tbl_name,count(*) from actor 
                       union select 'category' tbl_name,count(*) from category
                       union select 'film' tbl_name,count(*) from film
                       union select 'film_actor' tbl_name,count(*) from film_actor
                       union select 'film_category' tbl_name,count(*) from film_category
                       union select 'language' tbl_name,count(*) from language
                       union select 'inventory' tbl_name,count(*) from inventory
                       union select 'rental' tbl_name,count(*) from rental
                       union select 'payment' tbl_name,count(*) from payment
                       union select 'staff' tbl_name,count(*) from staff
                       union select 'customer' tbl_name,count(*) from customer
                       union select 'address' tbl_name,count(*) from address
                       union select 'city' tbl_name,count(*) from city
                       union select 'country' tbl_name,count(*) from country
                       union select 'store' tbl_name,count(*) from store
                       ) counts
                  order by tbl_name
                 ;
                "
)
sp_print_df(head(rs))
rs
```

#### Exercise dplyr Rows Per Table 

In the code block below 

1.  Get the row counts for a couple more tables
2.  What is the structure of film_table object?


```{r}
film_table <- tbl(con, "film") # DBI::dbReadTable(con, "customer")
language_table <- tbl(con, "language") # DBI::dbReadTable(con, "rental")

film_rows <- film_table %>% mutate(name = "film") %>% group_by(name) %>% summarize(rows = n())
language_rows <- language_table %>%
  mutate(name = "language") %>%
  group_by(name) %>%
  summarize(rows = n())
rows_per_table <- rbind(as.data.frame(film_rows), as.data.frame(language_rows))
rows_per_table
```

#### SQL film distribution based on language

The SQL below is very similar to the `SQL full Outer Join` above.  Instead of counting the joins, it counts the number films associated with each language.

```{r }
rs <- dbGetQuery(
  con,
  "select l.language_id id
                       ,l.name
                       ,sum(case when f.language_id is not null then 1 else 0 end) total
                   from language l
                        full outer join film f
                             on l.language_id = f.language_id
                  group by l.language_id,l.name 
                  order by l.name;
                 ;
                "
)
sp_print_df(head(rs))
rs
```

#### Exercise dplyr film distribution based on language

Below is the code block from the `dplyr Full Outer Join` section above.  Modify the code block to match the output from the SQL version.

```{r}
rs <- dbGetQuery(
  con,
  "select l.language_id,l.name,f.language_id language_id_f,count(*) fojs
   from language l full outer join film f on l.language_id = f.language_id
  group by l.language_id,l.name,f.language_id
order by l.language_id;"
)
sp_print_df(rs)
rs
```

## Store analysis

How are the stores performing.  

### SQL store revenue stream

How are the stores performing?  The SQL code shows the payments made to each store in the business.

```{r}
rs <- dbGetQuery(
  con,
  "select store_id,sum(p.amount) amt,count(*) cnt 
                   from payment p 
                        join staff s 
                          on p.staff_id = s.staff_id  
                 group by store_id order by 2 desc
                 ;
                "
)
sp_print_df(head(rs))
```

#### Exercise dplyr store revenue stream

Complete the following code block to return the payments made to each store.

```{r}
payment_table <- tbl(con, "payment") # DBI::dbReadTable(con, "payment")
staff_table <- tbl(con, "staff") # DBI::dbReadTable(con, "staff")

store_revenue <- payment_table %>%
  inner_join(staff_table, by = "staff_id", suffix = c(".p", ".s")) %>%
  head()

store_revenue
```

<!-- answer
    # group_by(store_id) %>%
    # summarize (amt=sum(amount,na.rm=TRUE),n=n()) %>%
    # arrange (desc(amt))
-->    


### SQL:Estimate Outstanding Balance

The following SQL code calculates for each store

1.  the number of payments still open and closed from the DVD Rental Stores customer base.
2.  the total amount that their customers have paid
3.  the average price per/movie based off of the movies that have been paid.
4.  the estimated outstanding balance based off the open unpaid rentals * the average price per paid movie.

```{r}
rs <- dbGetQuery(
  con,
  "SELECT s.store_id store,sum(CASE WHEN payment_id IS NULL THEN 1 ELSE 0 END) open
    ,sum(CASE WHEN payment_id IS NOT NULL THEN 1 ELSE 0 END) paid
    ,sum(p.amount) paid_amt
    ,count(*) rentals
    ,round(sum(p.amount) / sum(CASE WHEN payment_id IS NOT NULL 
                                    THEN 1 
                                    ELSE 0 
                               END), 2) avg_price
    ,round(round(sum(p.amount) / sum(CASE WHEN payment_id IS NOT NULL 
                                          THEN 1 
                                          ELSE 0 
                                     END), 2) * sum(CASE WHEN payment_id IS NULL 
                                                         THEN 1 
                                                         ELSE 0 
                                                    END), 2) est_balance
FROM rental r
LEFT JOIN payment p
    ON r.rental_id = p.rental_id
JOIN staff s
    ON r.staff_id = s.staff_id
group by s.store_id;
"
)
sp_print_df(head(rs))
rs
```

#### Exercise Dplyr Modify the following dplyr code to match the SQL output from above.

```{r}
payment_table <- tbl(con, "payment") # DBI::dbReadTable(con, "payment")
rental_table <- tbl(con, "rental") # DBI::dbReadTable(con, "rental")

est_bal <- rental_table %>%
  left_join(payment_table, by = c("rental_id", "rental_id"), suffix = c(".r", ".p")) %>%
  mutate(
    missing =
      ifelse(is.na(payment_id), 1, 0), found = ifelse(!is.na(payment_id), 1, 0)
  ) %>%
  summarize(
    open =
      sum(missing, na.rm = TRUE), paid =
      sum(found, na.rm = TRUE), paid_amt =
      sum(amount, na.rm = TRUE), rentals = n()
  ) %>%
  summarize(
    open =
      open, paid =
      paid, paid_amt =
      paid_amt, rentals =
      rentals, avg_price =
      paid_amt / paid, est_balance = paid_amt / paid * open
  )
est_bal
```

### SQL actual outstanding balance

In the previous exercise, we estimated the outstanding amount.  After reviewing the rental table, the actual movie rental rate is in the table.  We use that to calculate the outstanding balance below.

```{r}
rs <- dbGetQuery(
  con,
  "SELECT sum(f.rental_rate) open_amt
    ,count(*) count
FROM rental r
LEFT JOIN payment p
    ON r.rental_id = p.rental_id
INNER JOIN inventory i
    ON r.inventory_id = i.inventory_id
INNER JOIN film f
    ON i.film_id = f.film_id
WHERE p.rental_id IS NULL
;"
)
sp_print_df(head(rs))
rs
```

```{r}
payment_table <- tbl(con, "payment") # DBI::dbReadTable(con, "payment")
rental_table <- tbl(con, "rental") # DBI::dbReadTable(con, "rental")
inventory_table <- tbl(con, "inventory") # DBI::dbReadTable(con, "inventory")
film_table <- tbl(con, "film") # DBI::dbReadTable(con, "film")

act_bal <- rental_table %>%
  left_join(payment_table, by = c("rental_id", "rental_id"), suffix = c(".r", ".p")) %>%
  inner_join(inventory_table, by = c("inventory_id", "inventory_id"), suffix = c(".r", ".i")) %>%
  inner_join(film_table, by = c("film_id", "film_id"), suffix = c(".i", ".f")) %>%
  head()

act_bal
```

<!--
    filter(is.na(customer_id.p)) %>%
    summarize(open_amount=sum(rental_rate,na.rm = TRUE)
             ,open = n()
             )
-->             

### Rank customers with highest open amounts

```{r}

rs <- dbGetQuery(
  con,
  "select c.customer_id,c.first_name,c.last_name,sum(f.rental_rate) open_amt,count(*) count
                   from rental r 
                        left outer join payment p 
                          on r.rental_id = p.rental_id  
                        join inventory i
                          on r.inventory_id = i.inventory_id
                        join film f
                          on i.film_id = f.film_id
                        join customer c
                          on r.customer_id = c.customer_id
                  where p.rental_id is null
                  group by c.customer_id,c.first_name,c.last_name
                  order by open_amt desc
                  limit 25
                 ;"
)
sp_print_df(head(rs))
rs
```
### what film has been rented the most
```{r}

rs <- dbGetQuery(
  con,
  "SELECT i.film_id
    ,f.title
    ,rental_rate
    ,sum(rental_rate) revenue
    ,count(*) count --16044
FROM rental r
INNER JOIN inventory i
    ON r.inventory_id = i.inventory_id
INNER JOIN film f
    ON i.film_id = f.film_id
GROUP BY i.film_id
    ,f.title
    ,rental_rate
ORDER BY count DESC
LIMIT 25
;"
)
sp_print_df(head(rs))
rs
```

### what film has been generated the most revenue assuming all amounts are collected
```{r}

rs <- dbGetQuery(
  con,
  "select i.film_id,f.title,rental_rate
                       ,sum(rental_rate) revenue,count(*) count  --16044
                   from rental r 
                        join inventory i
                          on r.inventory_id = i.inventory_id
                        join film f
                          on i.film_id = f.film_id
                 group by i.film_id,f.title,rental_rate
                 order by revenue desc
                 ;"
)
sp_print_df(head(rs))
```

### which films are in one store but not the other.
```{r}

rs <- dbGetQuery(
  con,
  "select coalesce(i1.film_id,i2.film_id) film_id
                       ,f.title,f.rental_rate,i1.store_id,i1.count,i2.store_id,i2.count
                   from     (select film_id,store_id,count(*) count 
                               from inventory where store_id = 1 
                             group by film_id,store_id) as i1
                         full outer join 
                            (select film_id,store_id,count(*) count
                               from inventory where store_id = 2 
                             group by film_id,store_id
                            ) as i2
                           on i1.film_id = i2.film_id 
                         join film f 
                           on coalesce(i1.film_id,i2.film_id) = f.film_id
                  where i1.film_id is null or i2.film_id is null 
                 order by f.title  ;
               "
)
sp_print_df(head(rs))
```

### Compute the outstanding balance.
```{r}
rs <- dbGetQuery(
  con,
  "select sum(f.rental_rate) open_amt,count(*) count
                   from rental r 
                        left outer join payment p 
                          on r.rental_id = p.rental_id  
                        join inventory i
                          on r.inventory_id = i.inventory_id
                        join film f
                          on i.film_id = f.film_id
                  where p.rental_id is null
                 ;"
)
sp_print_df(head(rs))
```
### Which Stores Have Movies That Have Never Rented?

```{r}
not_rented <- dbGetQuery(con,
          "select i.store_id,f.film_id,f.title,f.description,i.last_update
             from inventory i left outer join rental r 
                      on i.inventory_id = r.inventory_id
                  join film f
                      on i.film_id = f.film_id
            where r.inventory_id is null 
          ")

sp_print_df(not_rented)
```

## Different strategies for interacting with the database


select examples
    dbGetQuery returns the entire result set as a data frame.  
        For large returned datasets, complex or inefficient SQL statements, this may take a 
        long time.

      dbSendQuery: parses, compiles, creates the optimized execution plan.  
          dbFetch: Execute optimzed execution plan and return the dataset.
    dbClearResult: remove pending query results from the database to your R environment

### Use dbGetQuery

How many customers are there in the DVD Rental System
```{r}
rs1 <- dbGetQuery(con, "select * from customer;")
sp_print_df(head(rs1))

pco <- dbSendQuery(con, "select * from customer;")
rs2 <- dbFetch(pco)
dbClearResult(pco)
sp_print_df(head(rs2))
```

### Use dbExecute


### Anti join -- Find Sophie who has never rented a movie.

```{r}
customer_table <- DBI::dbReadTable(con, "customer")
rental_table <- DBI::dbReadTable(con, "rental")

customer_tbl <- dplyr::tbl(con, "customer")
rental_tbl <- dplyr::tbl(con, "rental")

dplyr_tbl_loj <-
  left_join(customer_tbl, rental_tbl, by = "customer_id", suffix = c(".c", ".r")) %>%
  filter(is.na(rental_id)) %>%
  select(c("first_name", "last_name", "email")) %>%
  collect()

rs <- dbGetQuery(
  con,
  "select c.first_name
                        ,c.last_name
                        ,c.email
                    from customer c
                         left outer join rental r
                              on c.customer_id = r.customer_id
                   where r.rental_id is null;
                 "
)
sp_print_df(head(rs))
sp_print_df(dplyr_tbl_loj)
```

```{r echo = FALSE}
## www.dataquest.io/blog/postgres-internals
## Explain a `dplyr::join

tbl_pk_fk_df <- DBI::dbGetQuery(
  con,
  "
SELECT --t.table_catalog,t.table_schema,
   c.table_name
	,kcu.column_name
	,c.constraint_name
	,c.constraint_type
	,coalesce(c2.table_name, '') ref_table
	,coalesce(kcu2.column_name, '') ref_table_col
FROM information_schema.tables t
LEFT JOIN information_schema.table_constraints c
  ON t.table_catalog = c.table_catalog
    AND t.table_schema = c.table_schema
    AND t.table_name = c.table_name
LEFT JOIN information_schema.key_column_usage kcu
	ON c.constraint_schema = kcu.constraint_schema
		AND c.constraint_name = kcu.constraint_name
LEFT JOIN information_schema.referential_constraints rc
	ON c.constraint_schema = rc.constraint_schema
		AND c.constraint_name = rc.constraint_name
LEFT JOIN information_schema.table_constraints c2
	ON rc.unique_constraint_schema = c2.constraint_schema
		AND rc.unique_constraint_name = c2.constraint_name
LEFT JOIN information_schema.key_column_usage kcu2
	ON c2.constraint_schema = kcu2.constraint_schema
		AND c2.constraint_name = kcu2.constraint_name
		AND kcu.ordinal_position = kcu2.ordinal_position
WHERE c.constraint_type IN ('PRIMARY KEY', 'FOREIGN KEY')
  AND c.table_catalog = 'dvdrental'
	AND c.table_schema = 'public'
--  AND (c.table_name = 'customer' or coalesce(c2.table_name, '') = 'customer')
ORDER BY c.table_name;
"
)

sp_print_df(tbl_pk_fk_df)

tables_df <- tbl_pk_fk_df %>% distinct(table_name)
sp_print_df(tables_df)
```

```{r create nodes,echo = FALSE}
library(DiagrammeR)

table_nodes_ndf <- create_node_df(
  n <- nrow(tables_df),
  type <- "table",
  label <- tables_df$table_name,
  shape =
    "rectangle", width =
    1, height =
    .5, fontsize = 18
)

tbl_pk_fk_ids_df <- inner_join(tbl_pk_fk_df,
  table_nodes_ndf,
  by =
    c("table_name" = "label"), suffix(c("st", "s"))
) %>%
  rename("src_tbl_id" = id) %>%
  left_join(
    table_nodes_ndf,
    by =
      c("ref_table" = "label"), suffix(c("st", "t"))
  ) %>%
  rename("fk_tbl_id" = id)

tbl_fk_df <- tbl_pk_fk_ids_df %>% filter(constraint_type == "FOREIGN KEY")
tbl_pk_df <- tbl_pk_fk_ids_df %>% filter(constraint_type == "PRIMARY KEY")
# View(tbl_pk_fk_ids_df)
sp_print_df(tbl_fk_df)
sp_print_df(tbl_pk_df)
```

```{r echo = FALSE}
# Create an edge data frame, edf

fk_edf <-
  create_edge_df(
    from = tbl_fk_df$src_tbl_id,
    to = tbl_fk_df$fk_tbl_id,
    rel = "fk",
    label = tbl_fk_df$constraint_name,
    fontsize = 15
  )
sp_print_df(fk_edf)
```

```{r echo = FALSE}
graph <-
  create_graph(
    nodes_df = table_nodes_ndf,
    edges_df = fk_edf,
    graph_name = "Simple FK Graph"
  )

# View the graph
render_graph(graph, height = 3000)
```

```{r}
# diconnect from the db
dbDisconnect(con)

sp_docker_stop("sql-pet")
```

```{r}
knitr::knit_exit()
```
testit
```{r testit}

```

```{r}
# dbExecute(con, "drop table if exists film;")
```


<!-- 

-->
